<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/leaf-favicon-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/leaf-favicon-16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="码码更健康">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="码码更健康">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="乡村程序员">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>码码更健康</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">码码更健康</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">对代码永远保持敬畏</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/04/%E4%B8%80%E6%9D%A1SQL%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="乡村程序员">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码码更健康">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/04/%E4%B8%80%E6%9D%A1SQL%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/" class="post-title-link" itemprop="url">一条SQL是如何执行的</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-06-04 14:31:00 / 修改时间：19:08:57" itemprop="dateCreated datePublished" datetime="2021-06-04T14:31:00+08:00">2021-06-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/" itemprop="url" rel="index"><span itemprop="name">数据库系统概念</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一条SQL是如何执行的"><a href="#一条SQL是如何执行的" class="headerlink" title="一条SQL是如何执行的"></a>一条SQL是如何执行的</h1><ol>
<li><p>客户端</p>
<p>SQL语句首先再客户端创建。</p>
</li>
<li><p>服务器：主要包括连接器、查询缓存、分析器、优化器、执行器等，</p>
<ul>
<li>连接器（负责管理身份认证和权限相关的，登录MySQL时会发挥作用）。</li>
<li>查询缓存（SQL语句到达MySQL服务器后，会首先查询缓存，缓存命中后，返回结果）。</li>
<li>分析器（SQL缓存未命中的话，SQL语句就会经过分析器，分析器就是分析SQL语句要做什么，再检查你的SQL语句语法是否正确）。</li>
<li>优化器（可能你写的SQL语法没有问题，但是效率较低，比如没有很好地使用索引，这时候，优化器会对你的SQL语句进行优化）。</li>
<li>执行器（执行语句，然后从存储引擎（InnoDB，MyISAM）返回数据）。</li>
</ul>
</li>
</ol>
<ol>
<li><p>存储引擎：主要负责数据的存储和读取，采用可以替换的插件式架构。（下面假设是update操作）</p>
<ul>
<li>执行器检查数据是否在缓冲池中，不再则从磁盘上加载，并对该数据加独占锁。</li>
<li>将旧的数据写入到undo日志文件便于回滚。</li>
<li>更新缓冲池中的数据。</li>
<li>执行器更新数据写redo日志缓冲区。</li>
<li>redo日志写入磁盘，便于数据恢复。</li>
<li>执行器写binlog日志。</li>
<li>redo日志写入binlog文件名称和位置，同时写入commit标记，提交事务。</li>
</ul>
<p><img src="../images/%E4%B8%80%E6%9D%A1SQL%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/20200715202612868.jpg" alt="InnoDB执行流程"></p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/03/%E5%A4%A7%E6%95%B0%E6%8D%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="乡村程序员">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码码更健康">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/03/%E5%A4%A7%E6%95%B0%E6%8D%AE/" class="post-title-link" itemprop="url">大数据</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-03 20:06:00" itemprop="dateCreated datePublished" datetime="2021-06-03T20:06:00+08:00">2021-06-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-04 19:08:57" itemprop="dateModified" datetime="2021-06-04T19:08:57+08:00">2021-06-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">分布式系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h1><p>大数据的特点：</p>
<ul>
<li>Volume，传统的数据仓库计数处理GB到TB级别的数据，大数据技术处理的数据量往往超过PB。数据容量增长速度大大超过了硬件计数的发展速度，以至于引发了数据存储和处理的危机。</li>
<li>Variety：数据类型多。原来的数据都可以用二维表结构存储在数据库中,如常用的Excel软件所处理的数据，称为结构化数据。但是现在更多互联网多媒体应用的出现，使诸如图片、声音和视频等非结构化数据占到了很大比重。</li>
<li>Velocity，数据增长迅速。如果说大数据的特点是海量和非结构化，那也是不全面的。大数据带来的挑战还在于它的实时处理。</li>
<li>Value，价值密度低。以连续不间断的监控视频为例，可能有用的数据仅仅有一两秒钟。</li>
</ul>
<h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><p>Mapreduce使得普通程序员可以在不了解分布式底层细节的前提下开发分布式程序。使用者只需要编写两个称为MapReduce的函数即可，MapReduce框架会自动处理数据划分、多机并行执行、任务之间的协调，并且能够处理某个任务执行失败或者机器出现故障的情况。</p>
<p>MapReduce框架 包含三种角色：</p>
<p>主控进程（Master）：执行任务划分、调度、任务之间的协调等等；</p>
<p>Map工作进程（Map）、Reduce工作进程（Reduce）。</p>
<p>工作流程如下：</p>
<p>1）首先从用户提交的程序fork出主控进程，主控进程启动后将切分任务并根据输入文件所在的位置和集群信息选择机器fork出Map或者Reduce进程。用户提交的程序可以根据不同的命令行参数执行不同的行为。</p>
<p>2）主控进程将切分好的任务分配给Map进程和Reduce进程执行，任务切分和任务分配可以并行执行。</p>
<p>3）Map进程执行Map任务：读取相应的输入文件，根据指定的输入格式不断地读取<Key,Value>对并对每个<key,value>对执行用户自定义的Map函数。</p>
<p>4）Map进程执行用户定义的Map函数：不断地往本地内存缓冲区输出中间<key,value>对结果，等到缓冲区超过一定大小时写入到本地缓存中。Map进程根据分割函数将中间结果组织成R份，便于后续Reduce进程获取。</p>
<p>5）Map任务执行完成时，Map进程通过心跳向主控进程汇报，主控进程进一步将该消息通知Reduce进程。Reduce进程向Map进程通过心跳向主控进程汇报，主控进程进一步将该消息通知Reduce进程。Reduce进程向Map进程请求传输生成的中间结果数据。这个过程称为Shuffle。当Reduce进程获取完所有的Map任务生成的中间结果时，需要进行排序操作。</p>
<p>6）Reduce进程执行Reduce任务：对中间结果的每一个相同的key及value集合，执行用户自定义的Reduce函数。Reduce函数的输出结果被写入到最终的输出结果，例如分布式文件系统或者分布式表格。</p>
<p>该框架实现时主要做了两点优化：</p>
<ul>
<li>本地化：尽量将任务分配给离输入文件最近的Map进程，如同一台机器或者同一个机架。通过本地化策略，能够大大减少传输的数据量。</li>
<li>备份任务：如果某个Map或者Reduce任务执行的时间较长，主控进程会生成一个该任务的备份并分配给另外一个空闲的Map或者Reduce进程。在大集群环境下，即使所有机器的配置相同，机器的负载不同也会导致处理能力相差很大，通过备份任务减少“拖后腿”的任务，从而降低整个作业的总体执行时间。</li>
</ul>
<h2 id="流式计算"><a href="#流式计算" class="headerlink" title="流式计算"></a>流式计算</h2><p>MapReduce及其扩展解决了离线批处理问题，但是无法保证实时性。对于实时性要求高的场景，可以采用流式计算或者实时分析系统进行处理。</p>
<p>流式计算解决在线聚合、在线过滤等问题，流氏计算同时具有存储系统和计算系统的特点，经常应用在一些类似反作弊、交易异常监控等场景。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>MapReduce系统主要解决的是对静态数据的批量处理，当MapReduce作业启动时，已经准备好了输入数据，比如保存在分布式文件系统上。而流式计算系统在启动时，输入数据一般并没有完全到位，而是经由外部数据流源源不断地流入。另外，流式计算并不像批处理系统那样，重视数据处理的总吞吐量，而是更加重视对数据处理的延迟。</p>
<p>源数据写入到流处理节点，流处理节点内部运行用户自定义的钩子函数对输入流进行处理，处理完后根据一定的规则转发给下游的流处理节点继续处理。另外，系统中往往还有管理节点，用来管理流处理节点的状态以及节点之间的路由规则。</p>
<p>典型钩子函数包括：</p>
<ul>
<li>聚合函数：计算最近一段时间窗口内的数据的聚合值。</li>
<li>过滤函数：过滤最近一段时间窗口内满足某些特性的数据。</li>
</ul>
<p>如果考虑机器故障，问题变得复杂。上游的处理节点出席那故障时，下游有两种选择：第一种选择是等待上游恢复服务，保证数据一致性；第二种选择是继续处理，优先保证可用性，等到上游恢复后再修复错误的计算结果。</p>
<p>流处理节点可以通过主备同步的方式容错，即将数据强同步到备机，如果主机出现故障，备机自动切换为主机继续提供服务。然而，这种方式的代价很高，且流式处理系统往往对错误有一定的容忍度，实际应用时经常选择其他代价更低的容错方式。</p>
<h2 id="实时分析"><a href="#实时分析" class="headerlink" title="实时分析"></a>实时分析</h2><p>海量数据离线分析对于MapReduce这样的批处理系统挑战并不大，如果要求实时，又分为两种情况：如果查询模式单一，那么，可以通过MapReduce预处理后将最终结果导入到在线系统提供实时查询；如果查询模式复杂，例如涉及多个列任意组合查询，那么，只能通过实时分析系统解决。实时分析系统融合了并行数据库和云计算这类技术，能够从海量数据中快速分析出汇总结果。</p>
<h3 id="MPP架构"><a href="#MPP架构" class="headerlink" title="MPP架构"></a>MPP架构</h3><p>并行数据库往往采用MPP（Massively Parallel Processing，大规模并行处理）架构。MPP架构是一种不共享的结构，每个节点可以运行自己的操作系统、数据库等。每个节点内的CPU不能访问一个节点的内存，节点之间的信息交互是通过节点互联网络实现的。</p>
<p>将数据分布到多个节点，每个节点扫描本地数据，并由Merge操作符执行结果汇总。</p>
<p>常见的数据分布算法有两种：</p>
<ul>
<li>范围分区（Range partitioning）：按照范围划分数据。</li>
<li>哈希分区（Hashing）：根据哈希函数计算结果将每个元组分配给相应的节点。</li>
</ul>
<p>Merge操作符：系统中存在一个或者多个合并节点，它会发送命令给各个数据分片请求相应的数据。每个数据片所在节点扫描本地数据，排序后回复合并节点，由合并节点通过merge操作符执行数据汇总。</p>
<p>如果Merge节点处理的数据特别大、可以通过Split操作符将数据划分到多个节点，每个节点对一部分数据执行group by、join等操作后再合并最终结果。</p>
<p>并行数据库的SQL查询和MapReduce计算有些类似，可以认为MapReduce模型是一种更高层次的抽象。由于考虑问题的角度不同，并行数据库处理的SQL查询执行时间通常很短，出现异常时整个操作重做即可。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/03/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="乡村程序员">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码码更健康">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/03/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" class="post-title-link" itemprop="url">分布式存储引擎</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-03 13:26:00" itemprop="dateCreated datePublished" datetime="2021-06-03T13:26:00+08:00">2021-06-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-04 19:08:57" itemprop="dateModified" datetime="2021-06-04T19:08:57+08:00">2021-06-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">分布式系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="分布式存储引擎"><a href="#分布式存储引擎" class="headerlink" title="分布式存储引擎"></a>分布式存储引擎</h1><h2 id="RootServer实现机制"><a href="#RootServer实现机制" class="headerlink" title="RootServer实现机制"></a>RootServer实现机制</h2><p>功能包括：</p>
<ul>
<li>管理集群中的所有ChunkServer，处理ChunkServer下线。</li>
<li>管理所有UpdateServer，处理UpdateServer选主。</li>
<li>管理集群中所有子表数据分布，发起子表复制、迁移以及合并操作。</li>
<li>与ChunkServer保持心跳，接受ChunkServer汇报，处理子表分裂；</li>
<li>接受UpdateServer汇报的大版本冻结消息，通知ChunkServer定期执行合并。</li>
<li>实现主备RootServer，数据强同步，支持主RootServer宕机自动切换。</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>RootServer的中心数据结构为一张存储了子表数据结构分布的有序表格，称为RootTable。每个子表存储的信息包括：子表主键范围、子表各个副本所在ChunkServer的编号、子表各个副本的数据行数、占用的磁盘空间、CRC校验值以及基线数据版本。</p>
<p>RootTable读多写少，所以设计成了有序数组，每次要添加子表信息的时候，先拷贝当前RootTable，然后将子表信息追加到新的RootTable，并对新的RootTable重新排序。原子的修改指针使得当前服务的RootTable指向新的RootTable。</p>
<p>为了提高性能，采取批处理优化，一次处理一批子表信息。</p>
<h3 id="子表复制与负载均衡"><a href="#子表复制与负载均衡" class="headerlink" title="子表复制与负载均衡"></a>子表复制与负载均衡</h3><p>RootServer有一个线程定期执行子表复制与负载均衡：</p>
<ol>
<li>子表复制：扫描RootTable中的子表，如果某个<strong>子表的副本数小于阈值</strong>，选取某台包含子表副本的ChunkServer为迁移源，另一台符合要求的ChunkServer作为迁移目的地。</li>
<li>负载均衡：扫描RootTable中的子表，如果某台<strong>ChunkServer包含的某个表格的子表</strong>个数超过平均个数以及可容忍个数之和，以这台ChunkServer为迁移源，并选择一台符合要求的ChunkServer，生成子表迁移任务。</li>
</ol>
<h3 id="子表分裂和合并"><a href="#子表分裂和合并" class="headerlink" title="子表分裂和合并"></a>子表分裂和合并</h3><p>难点：如何确保多个副本之间的分裂点保持一致称为问题的关键。</p>
<p>OceanBase采用了一种比较直接的做法：每台ChunkServer使用相同的分裂规则。由于每个子表的不同副本之间的基线数据完全一致，并且定期合并过程中冻结的增量数据也完全相同，只要分裂规则一致，分裂后的子表主键范围也保证相同。</p>
<p>分裂规则：只要定期合并过程产生的数据量超过256MB，就生成一个新的子表。</p>
<p>合并步骤相对麻烦：</p>
<ol>
<li>合并准备：RootServer选择若干个主键范围连续的小子表。</li>
<li>子表迁移：将待合并的若干个小子表迁移到相同的ChunkServer机器。</li>
<li>子表合并：往ChunkServer机器发送子表合并命令，生成合并后的子表范围。</li>
</ol>
<h3 id="UpdateServer选主"><a href="#UpdateServer选主" class="headerlink" title="UpdateServer选主"></a>UpdateServer选主</h3><p>通过租约机制来保证只有一个主UpdateServer。每当租约快要过期时就请求延长租期。如果RootServer发现租约过期了，UpdateServer还没有请求延长租约，则选择其他UpdateServer为主UpdateServer。</p>
<h3 id="RootServer主备"><a href="#RootServer主备" class="headerlink" title="RootServer主备"></a>RootServer主备</h3><p>RootServer主备之间需要同步的数据包括：RootTable中记录的子表分布信息、ChunkServerManager中记录的ChunkServer机器变化信息以及UpdateServer机器信息。这些数据的变化都将以操作日志的形式同步到备RootServer。备RootServer通过实时回放这些操作日志来与主RootServer保持同步。</p>
<p>OceanBase中的其他模块，比如ChunkServer/UpdateServer，以及客户端都是通过VIP(virtual IP)来访问RootServer的。正常情况下，VIP总是指向主RootServer。当主RootServer出现故障之后，部署在备RootServer上的Linux HA，软件能够检测到，并将VIP漂移到备RootServer。</p>
<h2 id="UpdateServer实现机制"><a href="#UpdateServer实现机制" class="headerlink" title="UpdateServer实现机制"></a>UpdateServer实现机制</h2><p>UpdateServer用于存储增量数据，它是一个单机存储系统，由如下几个部分组成：</p>
<ul>
<li><p>内存存储引擎，在内存中存储修改增量，支持冻结以及转储操作；</p>
</li>
<li><p>任务处理模型，包括网络框架、任务队列、工作线程等，针对小数据包做了专门的优化；</p>
</li>
<li>主备同步模块，将更新事务以操作日志的形式同步到备UpdateServer。</li>
</ul>
<p>UpdateServer是OceanBase性能瓶颈点，核心是高效、实现时对锁、索引结构、内存占用、任务处理模型以及主备同步都需要专门做优化。</p>
<h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>UpdateServer存储引擎包含几个部分：操作日志、MemTable以及SSTable。更新操作首先记录到操作日志中，接着更新内存中活跃的MemTable，活跃的MemTable到达一定大小后将被冻结，称为Frozen MemTable，同时创建新的Active MemTable。冻结内存表将以SSTable的形式转储到SSD磁盘中。</p>
<ol>
<li><p>操作日志</p>
<p>OceanBase中有一个专门的提交线程负责确定多个写事务的顺序，将这些写事务的操作追加到日志缓冲区，并将日志缓冲区的内容写入日志文件。为了防止写操作日志污染操作系统的缓存，写操作日志文件采用Direct IO的方式实现。</p>
</li>
<li><p>MemTable</p>
<p>底层是要给高性能内存B树。每个叶子节点对应MemTable中的一行数据，key为行主键，value为行操作链表的指针。每行的操作按照时间顺序构成一个行操作链表。</p>
</li>
<li><p>SSTable</p>
<p>当活跃的MenTable超过一定大小或者管理员主动发起冻结命令时，活跃的MemTable将被冻结，生成冻结的MemTable，并同时以SSTable的形式转储到SSD磁盘中。</p>
<p>当然，如果内存不够时需要丢弃冻结MemTable，大量请求只能读取SSD磁盘，UpdateServer性能将大幅下降。因此，希望能够在丢弃冻结MemTable之前的一段时间，每隔一段时间，将一定比率的请求发给SSTable，而不是冻结MemTable。这样，SSTable上的读请求将从5%到10%，再到15%，依次类推，直到100%，很自然地实现了缓存预热。</p>
</li>
</ol>
<h3 id="任务模型"><a href="#任务模型" class="headerlink" title="任务模型"></a>任务模型</h3><p>UpdateServer有多个网络读写线程，每个线程通过Linux epoll监听一个套接字集合上的网络读写事件，每个套接字只能同时分配给一个线程。当网络读写线程收到网络包后，立即调用任务处理函数，如果任务处理时间很短，可以很快完成并回复客户端，不需要加锁，避免了上下文切换。UpdateServer中大部分任务为短任务，比如随机读取内存表，另外还有少量任务需要等待共享资源上的锁，可以将这些任务加入到长任务队列中，交给专门的长任务处理线程处理。</p>
<h3 id="主备同步"><a href="#主备同步" class="headerlink" title="主备同步"></a>主备同步</h3><p>OceanBase选择了强一致性，主UpdateServer往备UpdateServer同步操作日志，如果同步成功，主UpdateServer操作本地后返回客户端更新成功，否则，主UpdateServer之前需要通知RootServer，从而防止RootServer将不一致的备UpdateServer选为主UpdateServer。</p>
<h2 id="ChunkServer实现机制"><a href="#ChunkServer实现机制" class="headerlink" title="ChunkServer实现机制"></a>ChunkServer实现机制</h2><p>ChunkServer用于存储基线数据，它由如下基本部分组成：</p>
<ul>
<li>管理子表，主动实现子表分裂，配合RootServer实现子表迁移、删除、合并；</li>
<li>SSTable，根据主键有序存储每个子表的基线数据；</li>
<li>基于LRU实现块缓存以及行缓存；</li>
<li>实现Direct IO，磁盘IO和CPU计算并行化；</li>
<li>通过定期合并&amp;数据分发获取UpdateServer的冻结数据。</li>
</ul>
<h3 id="缓存实现"><a href="#缓存实现" class="headerlink" title="缓存实现"></a>缓存实现</h3><ol>
<li>OceanBase一次分配1MB的连续内存块，每个memblock包含若干缓存项。添加缓存项，只需要简单地将item追加到memblock的尾部。另外，缓存淘汰以memblock为单位，而不是以item为单位。</li>
<li>OceanBase没有维护LRU链表，而是对每个memblock都维护了访问次数和最近频繁访问时间。访问memblock中的item时将增加memblock的访问次数，如果最近一段时间之内的访问次数超过了一定值，那么，更新最近频繁访问时间；淘汰memblock时，对所有的memblock按照最近频繁访问时间排序，淘汰最近一段时间访问较少的memblock。可以看出，读取时只需要更新memblock的访问次数和最近频繁访问事件，不需要移动LRU链表。这种实现方式通过牺牲LRU算法的精确性，来规避LRU链表的全局锁冲突。</li>
<li><p>每个memblock维护了引用计数，读取缓存项时所在memblock的引用计数加1，淘汰memblock时引用计数减1，引用计数为0时，memblock可以挥手重用。通过引用计数，实现读取memblock中的缓存项不加锁。</p>
</li>
<li><p>惊群效应</p>
</li>
<li><p>缓存预热</p>
<p>为了避免定期合并后，大量请求同时读取新的SSTable文件，将使得ChunkServer的服务能力在切换SSTable瞬间大幅下降。因此，这里需要一个缓存预热的过程。OceanBase这样做：扫描原来的缓存，根据每个缓存项的key读取新的SSTable并将结果加入到新的缓存中。例如，原来缓存数据项的主键分别为100、200、500，那么只需要从SSTable中读取主键为100、200、500的数据并加入新的缓存。</p>
</li>
</ol>
<h3 id="IO实现"><a href="#IO实现" class="headerlink" title="IO实现"></a>IO实现</h3><p>TODO:</p>
<h3 id="定期合并-amp-数据分发"><a href="#定期合并-amp-数据分发" class="headerlink" title="定期合并&amp;数据分发"></a>定期合并&amp;数据分发</h3><h3 id="定期合并限速"><a href="#定期合并限速" class="headerlink" title="定期合并限速"></a>定期合并限速</h3><h2 id="消除更新瓶颈"><a href="#消除更新瓶颈" class="headerlink" title="消除更新瓶颈"></a>消除更新瓶颈</h2><h3 id="读写优化回顾"><a href="#读写优化回顾" class="headerlink" title="读写优化回顾"></a>读写优化回顾</h3><h3 id="数据分区"><a href="#数据分区" class="headerlink" title="数据分区"></a>数据分区</h3><h2 id="消除更新瓶颈-1"><a href="#消除更新瓶颈-1" class="headerlink" title="消除更新瓶颈"></a>消除更新瓶颈</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/03/OceanBase%E5%88%9D%E6%8E%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="乡村程序员">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码码更健康">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/03/OceanBase%E5%88%9D%E6%8E%A2/" class="post-title-link" itemprop="url">OceanBase初探</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-03 10:27:00" itemprop="dateCreated datePublished" datetime="2021-06-03T10:27:00+08:00">2021-06-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-04 19:08:57" itemprop="dateModified" datetime="2021-06-04T19:08:57+08:00">2021-06-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">分布式系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="OceanBase架构初探"><a href="#OceanBase架构初探" class="headerlink" title="OceanBase架构初探"></a>OceanBase架构初探</h1><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>OceanBase的设计目标是支持数百TB的数据量以及数十万的TPS、数百万的QPS的访问量。</p>
<p>一种常见的做法就是对数据库进行水平拆分，通常的做法是根据某个业务字段哈希后取模，根据取模的结果将数据分布到不停的数据库服务器上，客户端请求通过数据库中间层路由到不同的分区。这种方式目前存在一定的弊端：</p>
<ul>
<li>数据和负载增加后添加机器的操作比较负载，往往需要人工介入；</li>
<li>有些范围查询需要访问几乎所有的分区，例如，按照user_id分区，查询收藏了一个商品的所有用户需要访问的所有的分区。</li>
<li>目前广泛使用的关系型数据库存储引擎都是针对机械硬盘的特点设计的，不能够完全发挥新硬件的能力。</li>
</ul>
<p>另一种做法是参考分布式表格系统的做法，例如Google Bigtable系统，将大表划分为几万、几十万甚至上百万的子表，子表之间按照主键有序，如果某台服务器发生故障，它上面服务的数据能够在很短时间内自动迁移到集群中所有的其他服务器。这种方式解决了可扩展性的问题，少量突发的服务器故障或者增加服务器对使用者基本是透明的，能够轻松应对促销或者热点事件等突发流量增长。</p>
<p>万事有其利必有一弊，分布式表格系统虽然解决了可扩展性的问题，但是往往无法支持事务，例如Bigtable只支持单行事务。而OceanBase希望能够支持跨行跨表事务，这样使用起来会比较方便。</p>
<p>通过分析，Oceanbase团队发现，虽然在线业务的数据量十分庞大，例如几十亿条、上百亿条甚至更多记录，但最近一段时间的修改量并不多。因此，他们决定采用单台更新服务器来记录最近一段时间的修改增量，而以前的数据保持不变，以前的数据成为基线数据。基线数据以类似分布式文件系统的方式存储于多台基线数据服务器上，每次查询都要把基线数据和增量数据融合后返回给客户端。这样，写事务都集中在单台更新服务器上，避免了复杂的分布式事务，高效地实现了跨行跨表事务；另外，更新服务器上的修改增量能够定期分发到多台基线数据服务器中，避免成为瓶颈，实现了良好的扩展性。</p>
<h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p>OceanBase的整体架构如图所示：</p>
<ul>
<li>客户端：用户使用OceanBase的方式和MySQL数据库完全相同，支持JDBC、C客户端访问，等等。基于MySQL数据库开发的应用程序、工具能够直接迁移到OceanBase。</li>
<li>RootServer：管理处集群中的所有服务器，子表（tablet）数据分布以及副本管理。一般为一主一备，主备之间数据强同步。</li>
<li>UpdateServer：存储OceanBase系统的增量更新数据。UpdateServer一般为一主一备，可以配置不同的同步模式。部署时，UpdateServer进程和RootServer进程往往共用物理服务器。</li>
<li>ChunkServer：存储OceanBase系统的基线数据。基线数据一般存储两份或者三份，可配置。</li>
<li>MergeServer：接收并解析用户SQL请求，经过词法分析、语法分析、查询优化等一系列操作后转发给相应的ChunkServer或者UpdateServer。如果请求的数据分布在多台ChunkServer上面，MergeServer还需要对多台ChunkServer返回的结果进行合并。客户端和MergeServer之间采用原生的MySQL通信协议。</li>
</ul>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端只要将服务器的地址配置为任意一台MergeServer的地址，就可以直接使用了。</p>
<p>集群有多台MergeServer，这些MergeServer的服务器地址存储在OceanBase服务器端的系统表内。OceanBase客户端先获取MergeServer地址列表，接着按照一定的策略将读写请求发送给某台MergeServer，并负责对出现事故的MergeServer进行容错处理。</p>
<p>大致流程：</p>
<ol>
<li>请求RootServer获取集群中MergeServer的地址列表。</li>
<li>按照一定的策略选择某台MergeServer发送读写请求。客户端与MergeServer之间的通信协议兼容原生的MySQL协议。客户端支持的策略主要有两种：随机以及一致性哈希。一致性hash的主要目的是将相同的SQL请求发送到同一台MergeServer，方便MergeServer对查询结果进行缓存。</li>
<li>如果请求MergeServer失败，则冲MergeServer列表中重新选择一台MergeServer重试。如果请求某台MergeServer失败超过一定的次数，将这台MergeServer加入黑名单并从MergeServer列表删除。</li>
</ol>
<h3 id="RootServer"><a href="#RootServer" class="headerlink" title="RootServer"></a>RootServer</h3><p>​    RootServer的功能主要包括：集群管理、数据分布以及副本管理。</p>
<p>​    一个集群内部同一时刻只允许一个UpdateServer提供写服务，这个UpdateServer称为主UpdateServer。这种方式牺牲一定的可用性获取强一致性。</p>
<p>​    RootServer通过租约机制选择唯一的主UpdateServer，当原先的主UpdateServer发生故障后，RootServer能够在原先的租约失效后选择一台新的UpdateServer作为主UpdateServer。当原先的主UpdateServer发生故障后，RootServer能给个在原先租约失效后选择一台新的UpdateServer作为主UpdateServer。另外，RootServer和MergeServer&amp;ChunkServer之间保持心跳，从而能够感受到在线和已经下线的MergeServer&amp;ChunkServer机器列表。</p>
<p>​    OceanBase内部使用主键进行排序和存储。OceanBase采取的是根表一级索引结构。每个子表包含多个副本。分布在多台ChunkServer中。当其中某台ChunkServer发生故障时，RootServer能够检测到，并且触发对这台ChunkServer上的子表增加副本的操作。</p>
<p>RootServer也会定期执行负载均衡，选择某些子表从负载较高的机器上迁移到负载较低的机器上。</p>
<p>RootServer采用一主一备的结构，主备之间数据强同步，并通过Linux HA软件实现高可用性。</p>
<h3 id="MergeServer"><a href="#MergeServer" class="headerlink" title="MergeServer"></a>MergeServer</h3><p>功能：协议解析、SQL解析、请求转发、结果合并、多表操作。</p>
<p>MergeServer缓存了子表分布信息，根据请求涉及到的子表将请求转发给多个孩子表所在的ChunkServer。如果是写操作，还会转发给UpdateServer。某些请求需要跨多个子表，此时MergeServer会将请求拆分后发送给多台ChunkServer，并合并这些ChunkServer返回的结果。MergeServer支持并发请求多台ChunkServer，即将多个请求发给多台ChunkServer。MergeServer本身无状态，宕机不会被用户感知到。</p>
<h3 id="ChunkServer"><a href="#ChunkServer" class="headerlink" title="ChunkServer"></a>ChunkServer</h3><p>功能：存储子表、提供读取服务，执行定期合并以及数据分发。</p>
<p>大表-&gt;子表-&gt;SSTable-&gt;块（4KB-64KB）。</p>
<p>SSTable支持块缓存和行缓存。</p>
<p>MergeServer将每个子表读取请求发送到子表所在ChunkServer，ChunkServer首先读取SSTable中包含的基线数据与增量更新融合后得到最终结果。</p>
<p>由于每次读取都需要从UpdateServer中获取最新的增量更新，为了保证读取性能，需要限制UpdateServer中增量更新的数据量，最好能够全部存放在内存中。</p>
<h3 id="UpdateServer"><a href="#UpdateServer" class="headerlink" title="UpdateServer"></a>UpdateServer</h3><p>UpdateServer是整个集群中唯一能接受写入的模块，每个集群中只有一个主UpdateServer。UpdateServer中的更新操作首先写入到内存表，当内存表的数据量超过一定值时，可以生成快照文件并转储到SSD中。快照的组织方式与ChunkServer中的SSTable类似。</p>
<p>UpdateServer宕机重启后需要首先加载转储的快照文件，接着回放快照点之后的操作日志。由于集群中只有一台主UpdateServer提供写服务，因此，OceanBase很容易地实现跨表事务。而不需要采用传统的两阶段提交协议。当然，这样也带来了一系列的问题。由于整个集群所有的读写操作都必须经过UpdateServer，UpdateServer的性能至关重要。而UpdateServer只需要服务最新一段时间新增的数据，这些数据往往可以全部存放在内存当中。</p>
<h3 id="定期合并-amp-数据分发"><a href="#定期合并-amp-数据分发" class="headerlink" title="定期合并&amp;数据分发"></a>定期合并&amp;数据分发</h3><p>定期合并和数据分发都将UpdateServer中的增量更新分发到ChunkServer中的手段，二者的整体流程比较类似：</p>
<p>1）UpdateServer冻结当前的活跃内存表，生成冻结内存表，并开启新的活跃内存表，后续的更新操作都写入新的活跃内存表。</p>
<p>2）UpdateServer通知RootServer数据版本发生了变化之后，之后RootServer通过心跳消息通知ChunkServer。</p>
<p>3）每台ChunkServer启动定期合并或者数据分发操作，从UpdateServer获取每个子表对应的增量更新数据。</p>
<p>定期合并的开销大于数据分发。数据分发只需要每个chunkserver获得updateServer冻结表中的增量更新数据缓存在本地即可。而定期合并需要ChunkServer将本地的SStable中的基线数据与冻结内存表的增量更新数据执行一次多路归并，融合后生成新的基线数据并存放到新的SSTable中。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/31/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="乡村程序员">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码码更健康">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/31/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-title-link" itemprop="url">分布式数据库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-31 08:20:00" itemprop="dateCreated datePublished" datetime="2021-05-31T08:20:00+08:00">2021-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-04 19:08:57" itemprop="dateModified" datetime="2021-06-04T19:08:57+08:00">2021-06-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h1><h2 id="数据库中间层"><a href="#数据库中间层" class="headerlink" title="数据库中间层"></a>数据库中间层</h2><p>为了扩展关系型数据库，最简单也是最为常见的做法就是应用层按照规则将数据拆分为多个分片，分布到多个数据库节点，并引入一个中间层来对应用屏蔽后端的数据库拆分细节。</p>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>以MySQL Sharding架构为例，分为几个部分：中间层dbproxy集群、数据库组、元数据服务器、常驻进程。</p>
<p>（1）MySQL客户端库</p>
<p>应用程序通过MySQL原生的客户端与系统交互，支持JDBC，原有的单机访问数据库程序可以无缝迁移。</p>
<p>（2）中间层dbproxy</p>
<p>中间层解析客户端SQL请求并转发到后端的数据库。具体来讲，它解析MySQL协议，执行SQL路由，SQL过滤，读写分离，结果归并，排序以及分组，等等。中间层由多个无状态的dbproxy进程组成，不存在单点的情况。还可以再客户端和dbproxy之间引入LVS（Linux Virtual Server）进行负载均衡。不过这会造成请求需要增加一层通信开销，常见做法是直接再客户端配置中间层服务器列表。由客户端处理请求负载均衡以及中间层服务器故障等情况。</p>
<p>（3）数据库组dbgroup</p>
<p>每个dbgroup由N台数据库机器组成，其中一台为主机（Master），另外N-1台为备机（Slave）。</p>
<p>主机负责所有写事务及强一致事务，并将操作以binlog的形式复制到备机，备机可以支持有一定延迟的读事务。</p>
<p>（4）元数据服务器</p>
<p>元数据服务器主要负责维护dbgroup拆分规则并用于dbgroup选主。dbproxy通过元数据服务器获取拆分规则从而确定SQL语句的执行计划。另外，如果dbgroup的主机出现故障，需要通过元数据服务器选主。元数据服务器本身也需要多个副本实现HA，一种常见方式是采用Zookeeper实现。</p>
<p>（5）常驻进程agents</p>
<p>部署再每台数据库服务器上的常驻进程，用于实现监控、单点切换、安装、卸载程序等。</p>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>MySQL Sharding集群一般按照用户id进行哈希分区，这存在两个问题：</p>
<ol>
<li>集群容量不够怎么办？</li>
<li>单个用户数据量太大怎么办？</li>
</ol>
<p>对于第一个问题，MySQL Sharding集群往往会采用双倍扩容的方案，即从2台服务器扩到4台，再扩到8台，依次类推。</p>
<p>扩容的基本策略：</p>
<p>先进行主备同步，然后暂停写服务等待主备完全同步，接触主备关系，然后修改中间层的映射关系，让一部分数据映射到之前备机（现在已经不是了），然后给当前的机器分配一台备机。</p>
<p>第二个问题可以通过再应用层定期统计大用户，并且将这些用户的数据按照数据量拆分到多个dbgroup。</p>
<h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>引用数据库中间层将后端分库分表对应用透明化，在大型互联网公司内部很常见。这种做法实现简单，对应用友好，但也有一些问题：</p>
<ul>
<li>数据库复制：MySQL主备之间只支持异步复制，而且主库压力较大时可能产生很大的延迟，因此，主备切换可能会丢失最后一部分更新事务，这时往往需要人工介入。</li>
<li>扩容问题：如果系统压力过大需要增加新得机器，这个过程涉及数据重新划分，整个过程比较复杂，且容易出错。</li>
<li>动态数据迁移问题：如果某个数据库组压力过大，需要将其中部分数据迁移出去，迁移过程需要总控节点整体协调，以及数据库节点得配合。</li>
</ul>
<h2 id="GoogleSpanner"><a href="#GoogleSpanner" class="headerlink" title="GoogleSpanner"></a>GoogleSpanner</h2><p>Spanner的扩展性达到了全球级，可以扩展数百个数据中心，数百万台机器，上万亿行记录。更重要的是，它还能通过同步复制和多版本控制来满足外部一致性，支持数据中心事务。</p>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>Spanner的表是层次化的，最底层的表是目录表。</p>
<h3 id="架构-1"><a href="#架构-1" class="headerlink" title="架构"></a>架构</h3><p>Spanner是全球性的，因此它有两个其他分布式存储系统没有的概念：</p>
<ul>
<li>Universe。一个Spanner部署的实例称为一个Universe。目前全世界有3个，一个开发、一个测试、一个线上。</li>
<li>Zones。每个Zone属于一个数据中心，而一个数据中心可能有多个Zone。一般来说mZone内部的网络通信代价较低，而Zone和Zone之间的通信代价很高。</li>
</ul>
<p>组件：</p>
<ul>
<li>Universe Masters：监控这个Universe里的Zone级别的状态信息。</li>
<li>Placement Driver：提供了跨Zone数据迁移功能。</li>
<li>Location Proxy：提供了获取数据的位置信息服务。客户端需要通过它才能够知道数据由哪台Spanserver服务。</li>
<li>Spanserver：提供存储服务，功能上相当于BigTable系统中的Tablet Server。</li>
</ul>
<p>发送读写请求时候，首先查找目录所在Spanserver，接着从Spanserver读写数据。</p>
<h3 id="复制与一致性"><a href="#复制与一致性" class="headerlink" title="复制与一致性"></a>复制与一致性</h3><p>每个数据中心运行着一套Colossus，每个机器由有100~1000个子表，每个子表会在多个数据中心部署多个副本。为了同步系统中的操作日志，每个子表上会运行一个Paxos状态机。Paxos协议会选出一个副本作为主副本，这个主副本的寿命默认是10s，正常情况下，这个主副本会在快要到期的时候将自己再次选为主副本。</p>
<p>通过Paxos协议，实现了跨数据中心的多个副本之间的一致性。另外，每个主副本所在Spanserver还会实现一个锁表用于并发控制，读写事务操作某个子表上的目录时需要通过缩表避免多个事务之间的互相干扰。</p>
<p>除了锁表，每个主副本上还有一个事务管理器。如果事务在一个Paxos组里面，可以绕过事务管理器。但是一旦事务跨多个Paxos组，就需要事务管理器来协调。</p>
<p>锁表实现单个Paxos组内的单机事务，事务管理器实现跨多个Paxos组的分布式事务。为了实现分布式事务，需要2PC，有一个Paxos组的主副本会成为协调者。</p>
<h3 id="True-Time"><a href="#True-Time" class="headerlink" title="True Time"></a>True Time</h3><p>数据库需要给每个事务分配全局唯一的事务id。然而，在分布式系统中，很难生成全局唯一id。Spanner通过全球时钟同步机制Tru</p>
<p>eTime。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="乡村程序员">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码码更健康">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">分布式系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-27 23:17:00" itemprop="dateCreated datePublished" datetime="2021-05-27T23:17:00+08:00">2021-05-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-31 08:19:37" itemprop="dateModified" datetime="2021-05-31T08:19:37+08:00">2021-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">分布式系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h1><h2 id="GFS（Google-File-System）"><a href="#GFS（Google-File-System）" class="headerlink" title="GFS（Google File System）"></a>GFS（Google File System）</h2><h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><p>GFS的节点可以分为三种：GFS Master（主控服务器）、GFS ChunkServer（CS，数据块服务器）以及GFS客户端。</p>
<p>客户端是GFS提供给应用程序的访问接口，客户端访问GFS的时候，首先访问主控服务器节点，获取与之进行交互的CS信息，然后直接访问这些CS，完成数据交互工作。</p>
<h3 id="Master设计"><a href="#Master设计" class="headerlink" title="Master设计"></a>Master设计</h3><p>Master维护了系统中的元数据，包括文件及chunk命名空间、文件到chunk之间的映射、chunk副本的位置信息。</p>
<p>负载均衡：</p>
<p>为了提高系统的可用性，GFS会避免将同一个chunk的所有副本都存放在同一个机架的情况。</p>
<p>三种创建chunk副本的情况：chunk创建、chunk复制以及负载均衡。</p>
<h2 id="BigTable"><a href="#BigTable" class="headerlink" title="BigTable"></a>BigTable</h2><p>BigTable系统保证强一致性，同一时刻同一个子表只能被一台Tablet Server服务。这通过Chubby的互斥锁机制保证。当Tablet Server启动时候需要获取Chubby互斥锁，当Tablet Server出现故障，Master需要等到互斥锁失效，才能把它上面的子表迁移到其他Tablet Server。</p>
<p>BitTable的底层存储系统使用GFS。GFS本质是一个弱一致模型，只保证“同一个记录至少成功写入一次”，但可能存在一些补零记录、重复记录。</p>
<p>BigTable写入GFS的数据分为两种：</p>
<ul>
<li>操作日志：当Tablet Server发生故障时，它上卖弄服务的子表会被集群中的其他Tablet Server加载继续提供服务。加载子表可能需要回放操作日志，每条操作日志都有唯一序号，通过它可以去除重复的操作日志。</li>
<li>每个子表的SSTable数据：如果GFS写入失败，可以重试并产生多条重复记录，但是BigTable只会索引最后一条写入成功的记录。</li>
</ul>
<p><strong>BigTable本质上是构建 在GFS之上的一层分布式索引，通过它解决了GFS遗留的一致性问题</strong></p>
<p>为了提高性能，Tablet Server没有为它服务的每个子表单独存储日志，而是讲它服务的所有子表看的操作日志混在一起写入GFS，每条日志通过&lt;表格编号，行主键，日志序列号&gt;来唯一标识。</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>子表是负载均衡的基本单位。</p>
<p>Tablet Server定期向Master汇报状态，当状态检测时发现某个Tablet Server上的负载过重的时候，Master会自动对其进行负载均衡，即执行子表迁移工作。</p>
<ul>
<li>第一步请求原有的Tablet Server卸载子表；</li>
<li>第二部选择一台负载较低的Tablet Server加载子表。</li>
</ul>
<p>为了尽量减少停服务的时间，BigTable内部的策略是Minor Compaction。</p>
<ul>
<li>对原有的子表执行一遍Minor Compaction操作，操作过程中仍然允许写操作。</li>
<li>停止子表服务，对子表再执行一边Minor Compaction操作，由于第一次Minor Compaction过程中写的数据一般比较少，所以第二次写入的数据一般比较少。</li>
</ul>
<h3 id="分裂和合并"><a href="#分裂和合并" class="headerlink" title="分裂和合并"></a>分裂和合并</h3><p>BigTable中如果写入过多，可能出现某些子表过大，某些子表过小的情况，需要执行分裂和合并操作。</p>
<p>每个子表的数据分为内存中的MemTable和GFS中的多个SSTable，由于同一个子表只被一台Tablet Server服务，进行分裂比较简单，不需要进行实际的数据拷贝工作，只要将内存中的索引分成两个范围即可。</p>
<p>合并操作由Master发起，相比分类操作会更加复杂，由于两个子表可能被不同的Tablet Server加载，合并的第一步需要迁移其中一个子表，以使它们在同一个Tablet Server上，接着通知Tablet Server执行子表合并。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>BigTable把可扩展性做到了极致，但是也面临了一些问题：</p>
<ul>
<li>BigTable非常适合离线或者半线上业务，然而Tablet Server节点出现故障时，部分数据短时间内无法提供读写服务，不适合实时性要求特别高的业务，比如交易类业务。</li>
<li>架构的复杂性导致问题特别难定位：BigTable依赖GFS和Chubby，而这两者本身就非常复杂，这将导致使用的过程中很难发现问题。</li>
</ul>
<h2 id="Megastore"><a href="#Megastore" class="headerlink" title="Megastore"></a>Megastore</h2><p>Megastore 融合了 NoSQL 的扩展性(scalability)和 RDBMS 的便利性(convenience)， 提供强一致性保证(strong consistency guarantees) 和高可用性(high availability)。 在数据的细粒度分区(fine-grained partitions)中提供了完全可序列化的 ACID 语义。 在广域网同步复制(synchronously replicate)每一次写操作，具有合理的延迟(reasonable latency)， 支持在数据中心间无缝故障转移(seamless failover)。</p>
<p>Megastore由三个部分组成：</p>
<ul>
<li>客户端库，应用程序通过客户端操作Megastore的实体组。Megastore系统大部分功能集中在客户端，包括映射Megastore操作到BigTable，事务即并发控制，基于Paxos的复制。</li>
<li>复制服务器：接受客户端的用户请求并转发到所在机房的BigTable实例（解决跨机房连接数太多的问题）。</li>
<li>协调者：存储每个机房本地的实体组是否最新状态的信息，用于实现快速读。</li>
</ul>
<p>Megastore功能主要三个部分：映射Megastore数据模型到BigTable，事务及并发控制，跨机房数据复制及读写优化。</p>
<p>Megastore首先解析用户通过客户端传入的SQL请求，接着根据用户定义的Megastore数据模型讲SQL请求转化为对底层BigTable的操作。</p>
<h3 id="实体组"><a href="#实体组" class="headerlink" title="实体组"></a>实体组</h3><p>每个实体组内的操作日志采用Paxos的方式同步到多个机房，保证强一致性。实体组之间通过分布式队列的方式保证最终一致性或者两阶段提交协议的方式实现分布式事务。</p>
<ul>
<li><p>单集群实体组内部：同一个实体内部支持满足ACID特性的事务。通过REDO日志的方式来实现。</p>
</li>
<li><p>单集群实体组之间：实体组之间一般采用分布式队列的方式提供最终一致性，子表服务器上有定时扫描线程，发送跨实体组的操作到目的实体组。如果需要保证多个实体组之间的强一致性，即分布式事务，只能通过两阶段提交协议加锁协调。</p>
</li>
</ul>
<h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><p>三种读方式：</p>
<ul>
<li>最新读取</li>
<li>快照读取</li>
<li>非一致性读取</li>
</ul>
<p>前两种方式都是在单个实体组内部完成的，在读取之前确保所有已提交的写操作已经全部生效，然后读取最后一个版本的数据。对于快照读取，系统已知的最后一个完整数据十五版本并取出该版本的数据。这两种读取方式利用率BigTable存储多版本数据的特性，保证不会读到未提交的事务。非一致性读取忽略日志的状态而直接读取BigTable内存中最新的值。</p>
<p>写事务：</p>
<p>先将所有的操作都在日志中记录下来后，写操作才会对数据库执行修改。</p>
<p>大致流程：</p>
<ul>
<li>读取：获取最后一次提交事务的时间戳和日志位置。</li>
<li>应用逻辑：从BigTable读取并且讲写操作聚集到日志缓冲区中；</li>
<li>提交：将缓冲区中的操作日志追加到多个机房的BigTable集群，通过Paxos的协议保证一致性；</li>
<li>生效：应用操作日志，更新BigTable中的实体和索引；</li>
<li>清理：删除不需要的数据。</li>
</ul>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>Megastore数据模型中有一个非常重要的概念：索引，分为两大类：</p>
<ul>
<li>局部索引：只在单个实体组内部的，用于加速单个实体组内部的查找。局部索引属于某个实体组，实体组内部数据和局部索引的更新操作是原子里的。</li>
<li>全局索引：全局索引横跨多个实体组。</li>
</ul>
<h3 id="协调者"><a href="#协调者" class="headerlink" title="协调者"></a>协调者</h3><h4 id="快速读"><a href="#快速读" class="headerlink" title="快速读"></a>快速读</h4><p>Paxos协议要求读取最新的数据至少需要经过一半以上的副本，然而，如果不出现故障，每个副本基本都是最新的。也就是说，能够利用本地读取实现快速读，减少读取延时和跨机操作。Megastore引入协调者来记录每个本机房Bigtable实例中的每个实体组的数据是否最新。如果最新，读取操作只需要本地读取，没有跨机房操作。实体组有更新操作时，写操作需要将协调者记录的实体组状态更新为无效。如果某个机房的Bigtable集群写入失败，需要首先使得相应的协调者记录实体组状态失效以后写操作才可以成功返回客户端。</p>
<h4 id="协调者的可用性"><a href="#协调者的可用性" class="headerlink" title="协调者的可用性"></a>协调者的可用性</h4><p>每次写操作都要涉及协调者，因此协调者出现故障将会导致系统不可用。当协调者因为网络或者主机故障等原因不可用时，需要检测到协调者故障并将它隔离。</p>
<p>Megastore使用了Chubby锁服务，协调者在启动时从数据中心获取Chubby锁。为了处理请求，协调者必须持有Chubby锁。一旦因为出现问题导致锁失效，协调者会恢复到一个默认的保守状态：认为所有它所能看见的实体组都是失效的。然后，从协调者不可用到锁失效有一个短暂的Chubby锁过期时间，这个时间段写操作都会失败。所有的写入者都必须等待协调者的Chubby锁过期。</p>
<h3 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h3><p>除了可用性问题，对于协调者的读写协议必须满足一系列的竞争条件。失效操作总是安全的，但是生效操作必须谨慎处理。在异步网络环境中，消息可能乱序达到协调者。每条生效和失效消息都带有日志位置信息。如果协调者先收到较晚的是小操作再收到较早的生效操作，生效操作将被忽略。</p>
<h3 id="读取流程"><a href="#读取流程" class="headerlink" title="读取流程"></a>读取流程</h3><p>Megastore的读取流程如图所示，Megastore最新读取流程如下：</p>
<p><img src="../images/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/QQ%E5%9B%BE%E7%89%8720210530231200.jpg" alt="QQ图片20210530231200"></p>
<h3 id="写入流程"><a href="#写入流程" class="headerlink" title="写入流程"></a>写入流程</h3><p><img src="../images/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20210530232408623.png" alt="image-20210530232408623"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>Megastore的创新点：</p>
<ul>
<li>提出实体组的数据模型，通过实体组内部维持关系型数据库的ACID特性。实体组之间维持类似NoSQL的弱一致性，有效地融合了SQL和NoSQL两者的优势。</li>
<li>通过Paxos协议保证高可靠性和高可用性，即把数据强同步到多个机房，又做到发生故障时，自动切换不影响读写服务。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/22/C-%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E6%A8%A1%E5%9E%8B%E7%B2%BE%E8%A6%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="乡村程序员">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码码更健康">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/22/C-%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E6%A8%A1%E5%9E%8B%E7%B2%BE%E8%A6%81/" class="post-title-link" itemprop="url">C++编译链接模型精要</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-22 21:38:00 / 修改时间：21:38:11" itemprop="dateCreated datePublished" datetime="2021-05-22T21:38:00+08:00">2021-05-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/22/C++%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E6%A8%A1%E5%9E%8B%E7%B2%BE%E8%A6%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="乡村程序员">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码码更健康">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/22/C++%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E6%A8%A1%E5%9E%8B%E7%B2%BE%E8%A6%81/" class="post-title-link" itemprop="url">C++编译链接模型精要</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-22 21:38:00" itemprop="dateCreated datePublished" datetime="2021-05-22T21:38:00+08:00">2021-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-31 08:19:37" itemprop="dateModified" datetime="2021-05-31T08:19:37+08:00">2021-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;foo(int);\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;foo(char);\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">bar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++的函数重载决议，当C++编译器读到一个函数调用语句时，它必须从目前已看到的同名函数中选出最佳函数。哪怕后面的代码中出现了最合适的匹配。这意味着如果我们交换两个namespace级的函数定义在源代码中的位置，那么有可能改变程序的行为。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/13/%E7%B4%A2%E5%BC%95%E4%B8%8E%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="乡村程序员">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码码更健康">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/13/%E7%B4%A2%E5%BC%95%E4%B8%8E%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">索引与算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-13 23:03:00" itemprop="dateCreated datePublished" datetime="2021-05-13T23:03:00+08:00">2021-05-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-22 21:36:34" itemprop="dateModified" datetime="2021-05-22T21:36:34+08:00">2021-05-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">MySQL学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL%E5%AD%A6%E4%B9%A0/InnoDB/" itemprop="url" rel="index"><span itemprop="name">InnoDB</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="索引与算法"><a href="#索引与算法" class="headerlink" title="索引与算法"></a>索引与算法</h1><h2 id="InnoDB存储引擎概述"><a href="#InnoDB存储引擎概述" class="headerlink" title="InnoDB存储引擎概述"></a>InnoDB存储引擎概述</h2><p>InnoDB存储引擎支持以下几种常见索引：</p>
<ul>
<li>B+树索引</li>
<li>全文索引</li>
<li>哈希索引</li>
</ul>
<h3 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h3><p>聚集索引就是按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子节点称为数据页。聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。同时B+树数据结构一样，每个数据页都通过双向链表来进行链接。</p>
<p>每张表只能拥有一个聚集索引哦！</p>
<p>数据页上存放的是完整的每行的记录，而在非数据页的索引页中，存放的仅仅是键值及指向数据页的偏移量，而不是一个完整的行记录。</p>
<p>聚集索引的存储并不是物理上连续的，而是逻辑上连续的。这其中有两点：一是前面说过的页通过双向链表链接，页按照主键的顺序排序；另一点是每个页中的记录也是通过双向链表进行维护的，物理存储上可以同样不按照主键存储。</p>
<p>聚集索引的一个好处就是：对于主键的排序查找和范围查找速度非常快。叶子节点的数据就是用户要查询的数据。</p>
<h3 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h3><p>对于辅助索引，叶子节点并不包含行记录的全部数据。叶子节点除了包含键值以外，每个叶子节点中的索引行中还包含了一个书签。该书签用来告诉InnoDB存储引擎哪里可以找到与索引相对应的行数据。由于InnoDb存储引擎表是索引组织表，因此InnoDB存储引擎中辅助索引与聚集索引的关系。</p>
<p>辅助索引的存在并不影响数据在聚集索引中的组织，因此每张表上可以有多个辅助索引。当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键。然后再通过主键索引来找到一个完整的行记录。</p>
<p>聚集索引和非聚集索引的优缺点：</p>
<ul>
<li>聚集索引：检索效率高，索引占用的空间少，对数据新增/修改/删除的速度影响比较大。</li>
<li>非聚集索引：不影响表中的数据存储顺序，检索效率比聚集索引低，索引占用硬盘存储空间大，对数据新增/修改/删除的影响很少。</li>
</ul>
<p>MySQL数据库对于索引的添加或者删除的这类DDL操作，MySQL数据库的操作过程为：</p>
<ul>
<li>首先创建一张新的临时表，表结构为通过命令ALTER TABLE新定义的结构。</li>
<li>然后把原表中数据导入到临时表。</li>
<li>接着删除原表。</li>
<li>最后把临时表重名为原来的表名。</li>
</ul>
<p>这个操作会导致数据库服务暂时不可用（要修改的表）。</p>
<p>InnoDB存储引擎后面开始支持一种称为Fast Index Creation的索引创建方式——简称FIC。</p>
<p>对于辅助索引的建立，InnoDB存储引擎会对创建索引的表上加上一个S锁。在创建的过程中，不需要重建表，因此速度较之前提高了很多，并且数据结构的可用性也得到了提高。删除辅助索引操作就更简单了，InnoDB存储引擎只需要更新内部视图，并将辅助索引的空间标记为可用，同时删除MySQL数据库内部视图上对该表的索引定义即可。</p>
<p>由于FIC在索引的创建过程中加上了S锁，因此在创建过程中只能对该表进行读操作，若有大量的事务需要对目标表进行写操作，那么数据库的服务同样不可用。</p>
<p><strong>Online Schema Change</strong></p>
<p>OSC（在线架构改变）最早是FaceBook实现的一种在线执行DDL的方式，并广泛地应用于Facebook的MySQL数据库。所谓”在线“是指在事务的创建过程中，可以有读写事务对表进行操作，这提高了原有的MySQL数据库在DDL操作时的并发性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/11/%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="乡村程序员">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码码更健康">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/11/%E8%A1%A8/" class="post-title-link" itemprop="url">表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-11 11:12:00" itemprop="dateCreated datePublished" datetime="2021-05-11T11:12:00+08:00">2021-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-22 21:36:34" itemprop="dateModified" datetime="2021-05-22T21:36:34+08:00">2021-05-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">MySQL学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL%E5%AD%A6%E4%B9%A0/InnoDB/" itemprop="url" rel="index"><span itemprop="name">InnoDB</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="表"><a href="#表" class="headerlink" title="表"></a>表</h1><h2 id="InnoDB逻辑存储结构"><a href="#InnoDB逻辑存储结构" class="headerlink" title="InnoDB逻辑存储结构"></a>InnoDB逻辑存储结构</h2><p>从InnoDB存储引擎的逻辑存储结构看，所有数据都被逻辑地存放在一个空间中，称之为表空间。</p>
<p>表空间（tablespace）又由段（segment）、区（extent）、页（page）组成。页在一些文档中有时也称为块。</p>
<h3 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h3><p>在默认情况下InnoDB存储引擎有一个共享表空间ibddata1，即所有的数据都存放在这个表空间内。如果启用了innodb_file_per_table。则每张表内的数据可以单独放在一个表空间内。</p>
<p>如果启用了innodb_file_per_table的参数，需要注意的是每张表的表空间内存放的只是数据、索引和插入缓冲Bitmap页。其他类型的数据，比如回滚信息，插入缓冲索引页，系统事务信息，二次写缓冲等还是存放在原来的共享表空间内。</p>
<h3 id="段"><a href="#段" class="headerlink" title="段"></a>段</h3><p>表空间是由各种段组成的，常见的段有数据段、索引段、回滚段等。数据段和索引段其实就是B+树的叶子节点和非叶子节点。</p>
<h3 id="区"><a href="#区" class="headerlink" title="区"></a>区</h3><p>区是由连续的页组成的空间，在任何情况下每个区的大小都为1MB。在默认情况下一个区中有64个连续的页。</p>
<h2 id="InnoDB数据页结构"><a href="#InnoDB数据页结构" class="headerlink" title="InnoDB数据页结构"></a>InnoDB数据页结构</h2><p>InnoDB数据页由以下7个部分组成：</p>
<ul>
<li>File Header（文件头）</li>
<li>Page Header（页头）</li>
<li>Infimun和Supremum Records</li>
<li>User Records（用户记录，即行记录）</li>
<li>Free Space（空闲空间）</li>
<li>Page Directory（页目录）</li>
<li>File Trailer（文件结尾信息）</li>
</ul>
<h3 id="File-Header"><a href="#File-Header" class="headerlink" title="File Header"></a>File Header</h3><p>File Header用来记录页的一些头信息，由8个部分组成，共占用38字节。</p>
<h3 id="Page-Header"><a href="#Page-Header" class="headerlink" title="Page Header"></a>Page Header</h3><p>该部分用于记录数据页的状态信息，由14个部分组成，共占用56字节。</p>
<h3 id="Infimum和Supremum-Record"><a href="#Infimum和Supremum-Record" class="headerlink" title="Infimum和Supremum Record"></a>Infimum和Supremum Record</h3><p>InnoDB引擎中，每个数据页都有两个虚拟的行记录用来限定记录的边界，Infimum记录是比该页中任何主键值都要小的值，Supremum指比任何可能大的值还要大的值。这两个值在页创建时被建立，并且在任何情况下不会被删除。</p>
<h3 id="User-Record和Free-Space"><a href="#User-Record和Free-Space" class="headerlink" title="User Record和Free Space"></a>User Record和Free Space</h3><p>User Record就是实际存储行记录的内容。</p>
<p>强调：InnoDb存储引擎表从事B+索引组织的。</p>
<p>Free Space很明显指的是空闲空间，同样也是个链表数据结构。在一条记录被删除后，该空间会被加入到空闲链表中。</p>
<h3 id="Page-Directory"><a href="#Page-Directory" class="headerlink" title="Page Directory"></a>Page Directory</h3><p>Page Directory中存放了记录的相对位置，有些时候这些记录指针称为Slots或目录槽。与其他数据库不同的是，在InnoDB中并不是每个记录拥有一个槽，InnoDB存储引擎的槽是一个稀疏目录，即也给槽中可能包含多个记录。</p>
<h3 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h3><p>为了检测页是否完整的写入磁盘，InnoDB存储引擎的页中设置了File Trailer部分。</p>
<p>File Trailer只有Fil_PAGE_END_LSN部分，占用8个字节，前4个字节代表了该页的checksum值，最后4个字节和File Header中的FIL_PAGE_LSN相同。将这两个值和File Header中的两个值进行对比，，看是否一致。</p>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><h3 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h3><p>InnoDB存储引擎提供了以下几种约束：</p>
<ul>
<li>Primary Key</li>
<li>Unique Key</li>
<li>Foreign Key</li>
<li>Default</li>
<li>NOT NULL</li>
</ul>
<h3 id="约束的创建和查找"><a href="#约束的创建和查找" class="headerlink" title="约束的创建和查找"></a>约束的创建和查找</h3><p>约束的创建的两种方式：</p>
<ul>
<li>表建立时就进行约束定义</li>
<li>利用ALTER TABLE命令来进行创建约束</li>
</ul>
<h3 id="触发器约束"><a href="#触发器约束" class="headerlink" title="触发器约束"></a>触发器约束</h3><p>触发器的作用就是在执行insert、update、delete命令之后或之前自动调用SQL命令或存储过程。</p>
<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>MyISAM存储引擎本身并不支持外键，对于外键的定义只是起到一个注释的作用。而InnoDB存储引擎则完整支持外键约束。</p>
<p>一般来说，被引用的表为父表，引用的表称为子表。外键定义时的ON DELETE和ON UPDATE表示在对父表进行DELETE和UPDATE操作时，对子表所做的操作。</p>
<p>有以下几种可定义的子表操作：</p>
<ul>
<li><p>CASCADE：父表发生delete、update时，对相应的子表中的数据也进行delete、update操作。</p>
</li>
<li><p>SET NULL：父表发生delete、update操作时，相应的子表中的数据被更新为NULL值，但是子表中相对应的列必须允许为NULL值。</p>
</li>
<li>NO ACTION表示当父表发生DELETE或UPDATE操作时，抛出错误，不允许这类操作发生。</li>
<li>RESTRICT表示当父表发生DELETE或UPDATE操作时，抛出错误，不允许这类操作发生。</li>
</ul>
<h2 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h2><p>分区功能不是在存储引擎层完成的，因此不是只有InnoDB存储引擎支持分区，常见的存储引擎MyISAM、NDB等都支持。但也并不是所有的存储引擎都支持。</p>
<p>分区的过程是将一个表或索引分解为多个更小、更可管理的部分。就访问数据库的应用而言，从逻辑上讲只有一个表或一个索引，但是物理上这个表或索引可能由数十个物理分区组成。每个分区都是独立的对象，可以独自处理，也可以作为一个更大的对象进行处理。</p>
<p>MySQL数据库支持的分区为水平分区，并不支持垂直分区。此外，MySQL数据库的分区是局部分区索引，一个分区中既有数据又有索引。</p>
<p>MySQL支持以下几种类型的分区：</p>
<ul>
<li>RANGE分区：行数据基于属于给定连续区间的列值被放入分区。</li>
<li>LIST分区：和RANGE分区差不多，只不过面向的是离散的值。</li>
<li>HASH分区：根据用户定义的表达式的返回值来进行分区，返回值不能为负数。</li>
<li>KEY分区：根据MySQL数据库提供的哈希函数来进行分区。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="乡村程序员"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">乡村程序员</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">136</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wujiah251" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wujiah251" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/wujiahao.mail@gmail.com" title="E-Mail → wujiahao.mail@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">乡村程序员</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='45,45,200' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
