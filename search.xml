<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>表</title>
      <link href="2021/05/11/%E8%A1%A8/"/>
      <url>2021/05/11/%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="表"><a href="#表" class="headerlink" title="表"></a>表</h1><h2 id="InnoDB逻辑存储结构"><a href="#InnoDB逻辑存储结构" class="headerlink" title="InnoDB逻辑存储结构"></a>InnoDB逻辑存储结构</h2><p>从InnoDB存储引擎的逻辑存储结构看，所有数据都被逻辑地存放在一个空间中，称之为表空间。</p><p>表空间（tablespace）又由段（segment）、区（extent）、页（page）组成。页在一些文档中有时也称为块。</p><h3 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h3><p>在默认情况下InnoDB存储引擎有一个共享表空间ibddata1，即所有的数据都存放在这个表空间内。如果启用了innodb_file_per_table。则每张表内的数据可以单独放在一个表空间内。</p><p>如果启用了innodb_file_per_table的参数，需要注意的是每张表的表空间内存放的只是数据、索引和插入缓冲Bitmap页。其他类型的数据，比如回滚信息，插入缓冲索引页，系统事务信息，二次写缓冲等还是存放在原来的共享表空间内。</p><h3 id="段"><a href="#段" class="headerlink" title="段"></a>段</h3><p>表空间是由各种段组成的，常见的段有数据段、索引段、回滚段等。数据段和索引段其实就是B+树的叶子节点和非叶子节点。</p><h3 id="区"><a href="#区" class="headerlink" title="区"></a>区</h3><p>区是由连续的页组成的空间，在任何情况下每个区的大小都为1MB。在默认情况下一个区中有64个连续的页。</p><h2 id="InnoDB数据页结构"><a href="#InnoDB数据页结构" class="headerlink" title="InnoDB数据页结构"></a>InnoDB数据页结构</h2><p>InnoDB数据页由以下7个部分组成：</p><ul><li>File Header（文件头）</li><li>Page Header（页头）</li><li>Infimun和Supremum Records</li><li>User Records（用户记录，即行记录）</li><li>Free Space（空闲空间）</li><li>Page Directory（页目录）</li><li>File Trailer（文件结尾信息）</li></ul><h3 id="File-Header"><a href="#File-Header" class="headerlink" title="File Header"></a>File Header</h3><p>File Header用来记录页的一些头信息，由8个部分组成，共占用38字节。</p><h3 id="Page-Header"><a href="#Page-Header" class="headerlink" title="Page Header"></a>Page Header</h3><p>该部分用于记录数据页的状态信息，由14个部分组成，共占用56字节。</p><h3 id="Infimum和Supremum-Record"><a href="#Infimum和Supremum-Record" class="headerlink" title="Infimum和Supremum Record"></a>Infimum和Supremum Record</h3><p>InnoDB引擎中，每个数据页都有两个虚拟的行记录用来限定记录的边界，Infimum记录是比该页中任何主键值都要小的值，Supremum指比任何可能大的值还要大的值。这两个值在页创建时被建立，并且在任何情况下不会被删除。</p><h3 id="User-Record和Free-Space"><a href="#User-Record和Free-Space" class="headerlink" title="User Record和Free Space"></a>User Record和Free Space</h3><p>User Record就是实际存储行记录的内容。</p><p>强调：InnoDb存储引擎表从事B+索引组织的。</p><p>Free Space很明显指的是空闲空间，同样也是个链表数据结构。在一条记录被删除后，该空间会被加入到空闲链表中。</p><h3 id="Page-Directory"><a href="#Page-Directory" class="headerlink" title="Page Directory"></a>Page Directory</h3><p>Page Directory中存放了记录的相对位置，有些时候这些记录指针称为Slots或目录槽。与其他数据库不同的是，在InnoDB中并不是每个记录拥有一个槽，InnoDB存储引擎的槽是一个稀疏目录，即也给槽中可能包含多个记录。</p><h3 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h3><p>为了检测页是否完整的写入磁盘，InnoDB存储引擎的页中设置了File Trailer部分。</p><p>File Trailer只有Fil_PAGE_END_LSN部分，占用8个字节，前4个字节代表了该页的checksum值，最后4个字节和File Header中的FIL_PAGE_LSN相同。将这两个值和File Header中的两个值进行对比，，看是否一致。</p><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><h3 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h3><p>InnoDB存储引擎提供了以下几种约束：</p><ul><li>Primary Key</li><li>Unique Key</li><li>Foreign Key</li><li>Default</li><li>NOT NULL</li></ul><h3 id="约束的创建和查找"><a href="#约束的创建和查找" class="headerlink" title="约束的创建和查找"></a>约束的创建和查找</h3><p>约束的创建的两种方式：</p><ul><li>表建立时就进行约束定义</li><li>利用ALTER TABLE命令来进行创建约束</li></ul><h3 id="触发器约束"><a href="#触发器约束" class="headerlink" title="触发器约束"></a>触发器约束</h3><p>触发器的作用就是在执行insert、update、delete命令之后或之前自动调用SQL命令或存储过程。</p><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>MyISAM存储引擎本身并不支持外键，对于外键的定义只是起到一个注释的作用。而InnoDB存储引擎则完整支持外键约束。</p><p>一般来说，被引用的表为父表，引用的表称为子表。外键定义时的ON DELETE和ON UPDATE表示在对父表进行DELETE和UPDATE操作时，对子表所做的操作。</p><p>有以下几种可定义的子表操作：</p><ul><li><p>CASCADE：父表发生delete、update时，对相应的子表中的数据也进行delete、update操作。</p></li><li><p>SET NULL：父表发生delete、update操作时，相应的子表中的数据被更新为NULL值，但是子表中相对应的列必须允许为NULL值。</p></li><li>NO ACTION表示当父表发生DELETE或UPDATE操作时，抛出错误，不允许这类操作发生。</li><li>RESTRICT表示当父表发生DELETE或UPDATE操作时，抛出错误，不允许这类操作发生。</li></ul><h2 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h2><p>分区功能不是在存储引擎层完成的，因此不是只有InnoDB存储引擎支持分区，常见的存储引擎MyISAM、NDB等都支持。但也并不是所有的存储引擎都支持。</p><p>分区的过程是将一个表或索引分解为多个更小、更可管理的部分。就访问数据库的应用而言，从逻辑上讲只有一个表或一个索引，但是物理上这个表或索引可能由数十个物理分区组成。每个分区都是独立的对象，可以独自处理，也可以作为一个更大的对象进行处理。</p><p>MySQL数据库支持的分区为水平分区，并不支持垂直分区。此外，MySQL数据库的分区是局部分区索引，一个分区中既有数据又有索引。</p><p>MySQL支持以下几种类型的分区：</p><ul><li>RANGE分区：行数据基于属于给定连续区间的列值被放入分区。</li><li>LIST分区：和RANGE分区差不多，只不过面向的是离散的值。</li><li>HASH分区：根据用户定义的表达式的返回值来进行分区，返回值不能为负数。</li><li>KEY分区：根据MySQL数据库提供的哈希函数来进行分区。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>客户端</title>
      <link href="2021/05/01/%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
      <url>2021/05/01/%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<p>本文是《Redis设计与实现》中关于客户端的内容的笔记。<br> <span id="more"></span></p><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>Redis服务器对于每个与之连接的客户端都建立了相应的redisClient结构（客户端状态），这个结构保存了客户端当前的状态信息，以及执行相关功能时需要用到的数据结构，其中包括客户端名字、客户端的套接字描述符、客户端的标志值、客户端正在使用的数据库指针、客户端的的输入缓冲区和输出缓冲区等等。</p><p>Redis服务器状态结构的clients属性是一个链表，这个链表保存了所有与服务器连接的客户端的状态信息。</p><h3 id="客户端属性"><a href="#客户端属性" class="headerlink" title="客户端属性"></a>客户端属性</h3><p>分为两类：</p><ul><li>比较通用的属性，这些属性很少与特定功能相关，无论客户端执行的是什么工作，它们都要用到这些属性。</li><li>另一类是和特定功能相关的属性，比如操作数据库时需要用到的db属性和dictid属性，执行事务时需要用到的mstate属性等等。</li></ul><h3 id="套接字描述符"><a href="#套接字描述符" class="headerlink" title="套接字描述符"></a>套接字描述符</h3><p>根据客户端的类型不同，fd属性的值可以说-1或者是大于-1的整数：</p><ul><li>伪客户端的fd属性值为-1:伪客户端处理的命令请求来源于AOF脚本或者Lua脚本，而不是网络，所以这种客户端不需要套接字连接。</li><li>普通客户端的fd属性的值为1个大于-1的整数。</li></ul><h3 id="名字"><a href="#名字" class="headerlink" title="名字"></a>名字</h3><p>在默认情况下客户端是没有名字的，但是可以使用client setname命令为客户端设置一个名字，让客户端的身份变得清晰。</p><h3 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h3><p>客户端的标志属性flags记录了客户端的角色（role），以及客户端目前所处的状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span>&#123;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">int</span> flags;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;redisClient;</span><br></pre></td></tr></table></figure><p>flags属性的值可以是单个标志：</p><p>flags = <flags1> | <flags2> | …</p><p>每个标志使用一个常量表示：</p><ul><li>REDIS_MASTER：标志表示客户端代表的是一个主服务器，REDIS_SLAVE标志表示客户端代表的是一个从服务器。</li><li>REDIS_PRE_PSYNC标志表示客户端代表的是一个版本低于Redis2.8的从服务器，主服务器不能使用PSYNC命令与这个从服务器进行同步。</li><li>REDIS_LUA_CLIENT标识表示客户端是专门用于处理Lua脚本里面包含的Redis命令的伪客户端。</li><li>REDIS_MONITOR标志表示客户端正在执行MONITOR命令。</li><li>REDIS_UNIX_SOCKET标志表示服务器使用UNIX套接字来连接客户端。</li><li>REDIS_BLOCKED标志表示客户端正在被BRPOP、BLPOP等命令阻塞。</li><li>REDIS_UNBLOCKED标志表示客户端已经从REDIS_BLOCKED标志所表示的阻塞状态中脱离出来。</li></ul><p>还有很多标志，都定义在redis.h文件里面，这里不一一列举。</p><h2 id="输入缓冲区"><a href="#输入缓冲区" class="headerlink" title="输入缓冲区"></a>输入缓冲区</h2><p>客户端状态的输入缓冲区用于保存客户端发送的命令请求：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span>&#123;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">sds querybuf;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;redisClient;</span><br></pre></td></tr></table></figure><p>举个例子，如果客户端向服务器发送了以下命令请求：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key value</span><br></pre></td></tr></table></figure><p>那么客户端状态的query属性将是一个包含以下内容的SDS值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*<span class="number">3</span>\r\n$<span class="number">3</span>\r\nSET\r\n$<span class="number">3</span>\r\nkey\r\n$<span class="number">5</span>\r\nvalue\r\n</span><br></pre></td></tr></table></figure><p>输入缓冲区的大小会根据输入内容动态地缩小或者扩大，但它最大大小不能超过1GB，否则服务器将关闭这个客户端。</p><h3 id="命令与命令参数"><a href="#命令与命令参数" class="headerlink" title="命令与命令参数"></a>命令与命令参数</h3><p>在服务器将客户端发送的命令请求保存到客户端状态的querybuf属性之后，服务器将对命令请求的内容进行分析，并将得出的命令参数以及命令参数的个数分别保存到客户端状态的argv属性和argc属性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span>&#123;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">robj **argv;</span><br><span class="line"><span class="keyword">int</span> argc;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>argv属性是一个数组，数组中每个项都是一个字符串对象，其中argv[0]是要执行的命令，之后的其他项是传给命令的参数。</p><h3 id="命令的实现函数"><a href="#命令的实现函数" class="headerlink" title="命令的实现函数"></a>命令的实现函数</h3><p>当服务器从协议内容中分析并得出argv属性和argc属性的值之后，服务器将根据选项argv[0]的值，在命令表中查找命令所对应的命令实现函数。</p><p>该表是一个字典，字典的键是一个SDS结构，保存了命令的名字，字典的值是命令所对应的redisCommand结构，，这个结构保存了命令的实现函数，命令的标志、命令应该给定的参数个数、命令的总执行次数和总消耗时长等统计信息。</p><h3 id="输出缓冲区"><a href="#输出缓冲区" class="headerlink" title="输出缓冲区"></a>输出缓冲区</h3><p>执行命令所得的命令回复会被保存在客户端状态的输出缓冲区里面，每个客户端都有两个输出缓冲区可用，一个缓冲区的大小是固定的，另一个缓冲区的大小是可变的：</p><ul><li>固定缓冲区用于保存那些长度比较小的回复，比如OK、间断的字符串值等等。</li><li>可变大小的缓冲区用于保存那些长度比较大的回复，比如一个非常长的字符串值，一个由很多项组成的列表，一个包含了很多元素的集合等等。</li></ul><h3 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h3><p>客户端状态的authenticated属性用于记录客户端是否通过了身份验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span>&#123;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">int</span> authenticated;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;redisClient;</span><br></pre></td></tr></table></figure><p>如果authenticated的值为0，表示这个客户端未通过身份验证；如果authenticated的值为1，那么客户端已经通过身份验证。</p><p>举个例子，对于尚未进行身份验证的客户端来说，客户端状态的authenticated属性将如图13-10所示。</p><p>当客户端authenticated属性的值为0时，除了AUTH命令成功进行身份验证之后，客户端状态authenticated属性的值就会从0变成1，如果13-11所示，这时客户端就可以像往常一样向服务器发送命令请求了。</p><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><p>客户端还有几个与时间相关的属性：ctime、lastinteraction、obuf_soft_limit_reached_time。</p><p>ctime属性记录了创建客户端的时间，这个时间可以用来计算客户端与服务器已经连接了多少秒。</p><p>lastinteraction属性记录了客户端与服务器最后一次进行互动的时间，这里的互动可以是向客户端发送命令请求，也可以是服务器向客户端发送命令回复。</p><p>obuf_soft_limit_reached_time属性记录了输出缓冲区的第一次到达软性限制的时间。</p><h2 id="客户端的创建与关闭"><a href="#客户端的创建与关闭" class="headerlink" title="客户端的创建与关闭"></a>客户端的创建与关闭</h2><h3 id="创建客户端"><a href="#创建客户端" class="headerlink" title="创建客户端"></a>创建客户端</h3><p>当一个新的客户端连接到服务器，服务器会调用事件处理器，为客户端创建相应的客户端状态，并将其添加到clients链表的后端。</p><h3 id="关闭普通客户端"><a href="#关闭普通客户端" class="headerlink" title="关闭普通客户端"></a>关闭普通客户端</h3><p>一个普通客户端可以因为多种原因而被关闭：</p><ul><li>如果客户端进程退出或者被杀死，那么客户端与服务器之间的网络连接将被关闭，从而造成客户端被关闭。</li><li>如果客户端向服务器设置了timeout配置选项，那么客户端的空转时间超过timeout选项设置的值时，客户端将被关闭。</li><li>如果客户端发送的命令请求超出了缓冲区的限制大小，那么这个客户端会被服务器关闭。</li><li>如果要发送给客户端命令回复的大小超过了输出缓冲区的限制大小，那么这个客户端会被服务器关闭。</li><li>如果要发送给客户端的命令回复的大小超过了输出缓冲区限制的大小，那么这个客户端会被服务器关闭。</li></ul><p>服务器使用了两种模式来限制客户端输出缓冲区的大小：硬性限制和软性限制。</p><h3 id="Lua脚本的伪客户端"><a href="#Lua脚本的伪客户端" class="headerlink" title="Lua脚本的伪客户端"></a>Lua脚本的伪客户端</h3><p>服务器会在初始化时创建负责执行Lua脚本中包含Redis命令的伪客户端，并将这个伪客户端关联在服务器状态结构的lua_client属性中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">redisClient *lua_client;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>lua_client伪客户端在服务器运行的整个生命周期中会一直存在，只有服务器关闭时，这个客户端才会被关闭。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> 单机数据库的实现 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>服务器</title>
      <link href="2021/05/01/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>2021/05/01/%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>本文是《Redis设计与实现》中关于服务器的内容的笔记。<br> <span id="more"></span></p><h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><h1 id="命令的请求过程"><a href="#命令的请求过程" class="headerlink" title="命令的请求过程"></a>命令的请求过程</h1><h3 id="命令请求发送"><a href="#命令请求发送" class="headerlink" title="命令请求发送"></a>命令请求发送</h3><h3 id="读取命令请求"><a href="#读取命令请求" class="headerlink" title="读取命令请求"></a>读取命令请求</h3><p>客户端和服务器之间的连接套接字变成可读的时候，服务器调用命令请求处理器来执行以下操作：</p><ol><li>读取套接字中的协议格式的命令请求，并将其保存到客户端状态的输入缓冲区里面。</li><li>对输入缓冲区中的命令请求进行分析，提取出命令请求中的包含的命令参数，以及命令的个数，然后分别将参数和参数个数保存到客户端状态的argv属性和argc属性里面。</li><li>调用命令执行器，执行客户端指定的命令。</li></ol><h3 id="命令执行器（1）：查找命令实现"><a href="#命令执行器（1）：查找命令实现" class="headerlink" title="命令执行器（1）：查找命令实现"></a>命令执行器（1）：查找命令实现</h3><p>命令查找器要做的第一件事就是根据客户端状态的argv[0]参数，在命令表中查找参数所指定的命令，并将找到的命令保存到客户端状态的cmd属性里面。</p><p>命令表是一个字典，键是命令名字，比如set、get等等；值则是一个个redisCommand结构，每个redisCommand结构记录了一个Redis命令的实现信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> &#123;</span></span><br><span class="line">    <span class="comment">// 命令名字</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="comment">// 实现函数</span></span><br><span class="line">    redisCommandProc *proc;</span><br><span class="line">    <span class="comment">// 参数个数</span></span><br><span class="line">    <span class="keyword">int</span> arity;</span><br><span class="line">    <span class="comment">// 字符串表示的 FLAG，这个值记录了命令的属性，比如是写还是读</span></span><br><span class="line">    <span class="keyword">char</span> *sflags; </span><br><span class="line">    <span class="comment">// 实际 FLAG，对sflags标识进行分析得出的二进制标识，由程序自动生成</span></span><br><span class="line">    <span class="keyword">int</span> flags;    </span><br><span class="line">    <span class="comment">// 从命令中判断命令的键参数。在 Redis 集群转向时使用。</span></span><br><span class="line">    redisGetKeysProc *getkeys_proc;</span><br><span class="line">    <span class="comment">/* What keys should be loaded in background when calling this command? */</span></span><br><span class="line">    <span class="comment">// 指定哪些参数是 key</span></span><br><span class="line">    <span class="keyword">int</span> firstkey; <span class="comment">/* The first argument that&#x27;s a key (0 = no keys) */</span></span><br><span class="line">    <span class="keyword">int</span> lastkey;  <span class="comment">/* The last argument that&#x27;s a key */</span></span><br><span class="line">    <span class="keyword">int</span> keystep;  <span class="comment">/* The step between first and last key */</span></span><br><span class="line">    <span class="comment">// 统计信息</span></span><br><span class="line">    <span class="comment">// microseconds 记录了命令执行耗费的总毫微秒数</span></span><br><span class="line">    <span class="comment">// calls 是命令被执行的总次数</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> microseconds, calls;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="命令执行器（2）：执行预备操作"><a href="#命令执行器（2）：执行预备操作" class="headerlink" title="命令执行器（2）：执行预备操作"></a>命令执行器（2）：执行预备操作</h3><p>在真正执行命令之前，程序还需要进行一些预备操作，从而确保命令可以正确执行：</p><ul><li>检查客户端状态的cmd指针是否指向NULL；</li><li>根据客户端cmd属性指向的redisCommand的arity属性，检查命令请求所给定的参数个数是否正确，当参数个数不正确时，不再执行后续步骤，直接向客户端返回一个错误；</li><li>检查客户端是否通过了身份验证；</li><li>如果服务器打开了maxmemory功能，那么在执行命令之前，先检查服务器的内存占用情况，并在有需要时进行内存回收，从而使得接下来的命令可以顺利执行。</li></ul><p>还有很多预备操作，这里不一一列举。</p><h3 id="命令执行器（3）调用命令的实现函数"><a href="#命令执行器（3）调用命令的实现函数" class="headerlink" title="命令执行器（3）调用命令的实现函数"></a>命令执行器（3）调用命令的实现函数</h3><p>当服务器决定要执行命令的时候，它只需要执行以下语句就可以了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client-&gt;cmd-&gt;proc(client)</span><br></pre></td></tr></table></figure><p>被调用的命令实现函数会执行指定的操作，并产生相应的命令恢复，这些回复会被保存在客户端状态的输出缓冲区里面，之后实现函数还会为客户端的套接字关联命令回复处理器，这个处理器负责将回复返回给客户端。</p><h3 id="命令执行器（4）：执行后续操作"><a href="#命令执行器（4）：执行后续操作" class="headerlink" title="命令执行器（4）：执行后续操作"></a>命令执行器（4）：执行后续操作</h3><p>在执行晚实现函数之后，服务器还会做一些后续操作：</p><ul><li>如果服务器开启了慢查询日志功能，那么慢查询日志模块，会检查是否需要为刚刚执行完的命令请求添加一条新的慢查询日志。</li><li>根据刚刚执行命令所耗费的时长，更新被执行命令的redisComand结构的milliseconds属性，并将命令的redisCommand结构的calls计数器的值增一。</li><li>根据是否开启了AOF持久化，将命令请求写入AOF缓冲区（也可能还包括重写缓冲区）。</li><li>如果有其他从服务器正在复制当前这个服务器，那么服务器会将刚刚执行的命令传播给所有从服务器。</li></ul><h3 id="将命令回复发送给客户端"><a href="#将命令回复发送给客户端" class="headerlink" title="将命令回复发送给客户端"></a>将命令回复发送给客户端</h3><p>当客户端套接字编程可写状态时，服务器会执行命令回复处理器，将输出缓冲区中的命令回复发送给客户端。</p><h3 id="客户端接收并打印命令回复"><a href="#客户端接收并打印命令回复" class="headerlink" title="客户端接收并打印命令回复"></a>客户端接收并打印命令回复</h3><p>当客户端收到协议格式的命令回复之后，它会将这些回复转换成人类可读的格式，并将打印给用户观看。</p><h2 id="serverCron函数"><a href="#serverCron函数" class="headerlink" title="serverCron函数"></a>serverCron函数</h2><p>Redis服务器中的serverCron函数默认每隔100毫秒执行一次，这个函数负责管理服务器的资源，并保持服务器自身的良好运转。</p><h3 id="更新服务器时间缓存"><a href="#更新服务器时间缓存" class="headerlink" title="更新服务器时间缓存"></a>更新服务器时间缓存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 保存了秒级精度的系统当前UNIX时间戳</span></span><br><span class="line"><span class="keyword">time_t</span> unixtime</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mstime;</span><br><span class="line"><span class="comment">// 保存了毫秒精度的系统当前时间UNIX时间戳</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为serverCron函数默认会以100毫秒一次的频率更新unixtime属性和mstime属性，所以这两个属性记录的时间的精确度并不高：</p><ul><li>服务器只会在打印日志、更新服务器的LRU时钟、决定是否执行持久化任务、计算服务器上线时间这类对精确度要求不高的功能上使用unixtime和mstime属性。</li><li>对于键设置过期时间、添加慢查询日志这种需要高精度的时间功能来说，服务器还是会再次执行系统调用，从而获得最准确的系统当前时间。</li></ul><h3 id="更新LRU时钟"><a href="#更新LRU时钟" class="headerlink" title="更新LRU时钟"></a>更新LRU时钟</h3><p>当服务器要计算一个数据库键的空转时间，程序会用服务器的lrulock（服务器时间缓存的一种）属性记录的时间减去对象的lru属性记录的时间，得出的计算结果就是这个对象的空转时间。</p><p>serverCron函数默认以10秒一次的频率更新lrulock属性的值。</p><h3 id="更新服务器每秒执行命令次数"><a href="#更新服务器每秒执行命令次数" class="headerlink" title="更新服务器每秒执行命令次数"></a>更新服务器每秒执行命令次数</h3><p>serverCron函数中的trackOperationsPerSecond函数会以每100毫秒一次的频率执行，这个函数的功能是以抽样计算的方式，估算并将记录服务器在最近一次秒钟处理的命令请求数量，这个值可以通过INFO status命令的instantaneous_ops_per_sec域查看。</p><h3 id="更新服务器内存峰值记录"><a href="#更新服务器内存峰值记录" class="headerlink" title="更新服务器内存峰值记录"></a>更新服务器内存峰值记录</h3><p>服务器状态中的stat_peak_memory属性记录了服务器内存的峰值大小：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 已使用内存峰值</span></span><br><span class="line"><span class="keyword">size_t</span> stat_peak_memory;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>serverCron函数每次执行，都会查看服务器当前使用的内存数量，并更新stat_peak_memory。</p><h3 id="处理SIGTERM信号"><a href="#处理SIGTERM信号" class="headerlink" title="处理SIGTERM信号"></a>处理SIGTERM信号</h3><p>在启动服务器时，Redis会为服务器进程的SIGTERM信号关联处理器sigtermHandler函数，这个信号处理器负责在服务器接到SIGTERM信号时，打开服务器状态的shutdown_asap标识。</p><p>每次serverCron函数运行时，都会对服务器状态的shutdown_asap属性进行检查，并根据属性的值决定是否关闭服务器。</p><h3 id="管理客户端资源"><a href="#管理客户端资源" class="headerlink" title="管理客户端资源"></a>管理客户端资源</h3><p>serverCron函数每次执行都会调用clientCron函数、clientCron函数会对一定数量的客户端进行以下两个检查：</p><ul><li>如果客户端与服务器之间的连接已经超时，那么程序释放这个客户端。</li><li>如果客户端在上一次执行命令请求之后，输入缓冲区的大小超过了一定的长度，那么程序会释放客户端当前的输入缓冲区，并重新创建一个默认大小的输入缓冲区，从而防止客户端的输入缓冲区耗费了过多的内存。</li></ul><h3 id="管理数据库资源"><a href="#管理数据库资源" class="headerlink" title="管理数据库资源"></a>管理数据库资源</h3><p>serverCron函数每次执行都会调用databaseCron函数，这个函数会对服务器中的一部分数据库进行检查，删除其中的过期键，并且有需要时，对字典进行收缩操作。</p><h3 id="执行被延迟的BGREWRITEAOF"><a href="#执行被延迟的BGREWRITEAOF" class="headerlink" title="执行被延迟的BGREWRITEAOF"></a>执行被延迟的BGREWRITEAOF</h3><p>在服务器执行BGSAVE命令的期间，如果客户端向服务器发来的BGREWIRTEAOF命令，那么服务器会将BGREWIRTAOF命令的执行时间延迟到BGSAVE命令执行完毕之后。</p><h3 id="检查持久化操作的运行状态"><a href="#检查持久化操作的运行状态" class="headerlink" title="检查持久化操作的运行状态"></a>检查持久化操作的运行状态</h3><p>服务器状态持久化使用rdb_child_pid属性和aof_child_pid属性记录执行BGSAVE命令和BGREWRITEAOF命令的子进程的ID，这两个属性也可以用于检查BGSAVE命令或者BGREWRITEAOF命令是否正在执行。</p><h2 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h2><h3 id="初始化服务器状态结构"><a href="#初始化服务器状态结构" class="headerlink" title="初始化服务器状态结构"></a>初始化服务器状态结构</h3><p>初始化服务器的第一步是创建一个redisServer类型的实例变量，server作为服务器的状态，并为结构中的各个属性设置默认值。</p><p>初始化server变量的工作由initServerConfig函数完成。主要工作包括：</p><ul><li>设置服务器的运行ID。</li><li>设置服务器的默认允许频率。</li><li>设置服务器的默认配置文件路径。</li><li>设置服务器的允许架构。</li><li>设置服务器的默认端口号。</li><li>设置服务器的默认RDB持久化条件和AOF持久化条件。</li><li>初始化服务器的LRU时钟。</li><li>创建文件表。</li></ul><h3 id="载入配置选项"><a href="#载入配置选项" class="headerlink" title="载入配置选项"></a>载入配置选项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-server --port 10086</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-server redis.conf</span></span><br></pre></td></tr></table></figure><p>我们可以通过指定配置文件的方式修改了服务器的数据库数量，以及RDB持久化模块的压缩功能。</p><h3 id="初始化服务器的数据结构"><a href="#初始化服务器的数据结构" class="headerlink" title="初始化服务器的数据结构"></a>初始化服务器的数据结构</h3><p>在之前执行initServerConfig函数初始化server状态时，程序只创建了命令表一个数据结构，不过除了命令表之外，服务器状态还包含了其他数据结构，比如：</p><ul><li>server.clients链表；</li><li>server.db数据；</li><li>用于保存订阅信息的server.pubsub_channels字典；</li></ul><p>当初初始服务器进行到这一步，服务器将调用initServer函数，为以上的数据结构分配内存，并且这个函数还负责设置信号处理器、创建共享对象等重要工作。</p><h3 id="还原数据库状态"><a href="#还原数据库状态" class="headerlink" title="还原数据库状态"></a>还原数据库状态</h3><p>如果服务器启用了AOF持久化功能，服务器需要载入RDB文件或者AOF文件，并根据文件记录的内容来还原服务器的数据库状态。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> 单机数据库的实现 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>事务</title>
      <link href="2021/04/30/%E4%BA%8B%E5%8A%A1/"/>
      <url>2021/04/30/%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>Redis服务器需要处理以下两类事件：</p><ul><li>文件事件：Redis服务器通过套接字与客户端进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。</li><li>时间事件：Redis服务器中的一些操作需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。</li></ul><h2 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h2><p>Redis基于Reactor模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器：</p><ul><li>文件事件处理器使用I/O多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li><li>当被监听的套接字准备执行连接应答、读取、写入、关闭等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><h3 id="文件事件处理器的构成"><a href="#文件事件处理器的构成" class="headerlink" title="文件事件处理器的构成"></a>文件事件处理器的构成</h3><p>下图展示了文件事件处理器的构成，它们分别是套接字、I/O多路复用程序、文件事件分派器，以及事件处理程序。</p><p><img src="../images/%E4%BA%8B%E5%8A%A1/image-20210430000136863.png" alt="image-20210430000136863"></p><p>I/O多路复用负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。</p><h3 id="I-O多路复用程序的实现"><a href="#I-O多路复用程序的实现" class="headerlink" title="I/O多路复用程序的实现"></a>I/O多路复用程序的实现</h3><p>Redis的多路复用程序所有功能都是通过包装常见的select、epoll、evport和kqueue这些I/O多路复用函数库来实现的。每个I/O多路复用函数库在Redis源码中都对应一个单独的文件，比如ae_select.c、ae_epoll.c、ae_kqueue.c，诸如此类。</p><h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h3><p>I/O多路复用程序可以监听多个套接字的<strong>ae.h/AE_READABLE事件和ae.h/AE_WRITABLE事件</strong></p><p>I/O多路复用程序运行服务器同时监听套接字的读事件和写事件，如果一个套接字同时产生这两种事件，那么文件事件分派器会优先处理AE_READABLE事件。等AE_READABLE事件处理完才处理AE_WRITABLE事件。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>ae.c中提供了这样几个api：</p><p>aeCreateFileEvent（将给定套接字的给定事件加入到I/O多路复用的监听范围之内）。</p><p>aeDeleteFileEvent（取消对给定给定套接字给定事件的监听，并取消事件和事件处理器之间的关联）。</p><p>aeGetFileEvents（返回给定套接字被监听的事件）。</p><p>aeWait（给定定时间内阻塞并等待套接字的给定类型事件的产生，产生或者超时函数返回）。</p><p>aeApiPoll（阻塞指定时间直到至少一个事件产生）。</p><p>aeProcessEvents（这是文件事件分派器，先调用aeApiPoll函数来等待事件产生，然后遍历所有已产生事件，并且调用相关的事件处理函数）。</p><p>aeGetApiName（返回I/O多路复用程序底层所使用的I/O多路复用函数库的名称，比如返回“epoll”、“select”）。</p><h3 id="文件事件的处理器"><a href="#文件事件的处理器" class="headerlink" title="文件事件的处理器"></a>文件事件的处理器</h3><p>连接应答处理器、命令请求处理器、命令回复处理器、复制处理器。</p><h3 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h3><p>Redis的时间事件分为定时事件和周期性事件。一个时间事件主要由三个属性组成：id（全局唯一标识）、when（毫秒精度UNIX时间戳）、timeProc（时间事件处理器）。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。</p><h3 id="时间事件应用实例：serverCron函数"><a href="#时间事件应用实例：serverCron函数" class="headerlink" title="时间事件应用实例：serverCron函数"></a>时间事件应用实例：serverCron函数</h3><p>持续运行的Redis服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务可以长期、稳定地运行，这些定期操作由redis.c/serverCron函数负责执行，它的主要工作包括：</p><ul><li>更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等。</li><li>清理数据库中的过期键值对。</li><li>关闭和清理连接失效的客户端。</li><li>尝试进行AOF或RDB持久化操作。</li><li>如果服务器是主服务器，那么对从服务器进行定期同步。</li><li>如果处于集群模式，对集群进行定期同步和连接测试。</li></ul><h2 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h2><p>因为服务器中同时存在文件事件和时间事件两种事件类型，所以服务器必须对这两种事件进行调度，决定何时应该处理这些文件事件，何时又该处理时间事件。事件的调度是由ae.c/aeProcessEvents函数负责的。</p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><ul><li>Redis服务器是一个事件驱动程序，服务器处理的事件分为时间事件和文件事件两类。</li><li>文件事件处理器是基于Reactor模式实现的网络通信程序。</li><li>文件事件是对套接字操作的抽象：每次套接字变为可应答（acceptable）、可写（writable）或者可读（readable）时，相应的文件事件就会产生。</li><li>文件事件分为AE_READABLE事件和AE_WRITABLE事件两类。</li><li>时间事件分为定时事件和周期性事件：定时事件只在指定的时间到达一次，而周期性事件每隔一段时间到达一次。</li><li>服务器在一般情况下只执行serverCron函数一个时间事件，并且这个事件是周期性事件。</li><li>文件事件和时间事件之间是合作关系，服务器会轮流处理这两种事件，并且处理事件的过程中也不会进行抢占。</li><li>时间事件的实际处理时间通常会比设定的时间晚一些。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> 单机数据库的实现 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AOF持久化</title>
      <link href="2021/04/29/AOF%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>2021/04/29/AOF%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>本文是《Redis设计与实现》中关于AOF持久化的内容的笔记。<br> <span id="more"></span></p><h1 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h1><p>本文是《Redis设计与实现》中关于RDB持久化的内容的笔记。<br> <!-- more --></p><p>与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的。</p><h2 id="AOF持久化的实现"><a href="#AOF持久化的实现" class="headerlink" title="AOF持久化的实现"></a>AOF持久化的实现</h2><p>当AOF持久化功能处于打开状态时，服务器执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区末尾。</p><h3 id="AOF文件的写入和同步"><a href="#AOF文件的写入和同步" class="headerlink" title="AOF文件的写入和同步"></a>AOF文件的写入和同步</h3><p>Redis服务器就是一个时间循环，这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像serverCron函数这样需要定时运行的函数。</p><p>服务器在每次结束一个时间循环之前，它都会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区内容写入和保存在AOF文件里面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eventLoop</span>():</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">processFileEvents()</span><br><span class="line">processTimeEvents()</span><br><span class="line">flushAppendOnlyFile()</span><br></pre></td></tr></table></figure><p>flushAppendOnlyFile()函数的行为由服务器配置的appendfsync选项的值来决定，各个不同值产生的行为如表所示：</p><h2 id="AOF文件的载入与数据还原"><a href="#AOF文件的载入与数据还原" class="headerlink" title="AOF文件的载入与数据还原"></a>AOF文件的载入与数据还原</h2><p>AOF文件中包含了重建数据库状态的所需所有写命令，所以服务器只需要读入并重新执行一遍AOF文件里面保存的写命令，就可以还原服务器关闭之前的数据库状态。详细步骤：</p><ol><li>创建一个不带网络连接的伪客户端（因为Redis命令只能在客户端上下文中执行）。</li><li>从AOF文件中分析并读取出一条写命令。</li><li>使用伪客户端执行被读出的命令。</li><li>一直执行步骤2和步骤3，直到AOF文件中所有的写命令都被处理完毕为止。</li></ol><h2 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h2><p>为了解决AOF体积膨胀的问题，Redis提供了AOF文件重写功能。通过该功能，Redis服务器可以创建一个新的AOF文件来替代线有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，但新AOF文件不会包含任何浪费空间冗余命令。所以新AOF文件的体积通常会比旧AOF文件的体积要小很多。</p><h3 id="AOF文件重写的实现"><a href="#AOF文件重写的实现" class="headerlink" title="AOF文件重写的实现"></a>AOF文件重写的实现</h3><p>虽然Redis服务器将生成新的AOF文件替换旧的AOF文件的功能命名为AOF重写。但实际上，AOF文件重写并不需要对现有的AOF文件进行任何读取、分析或者写入操作。这个功能实际上是通过读取服务器当前的数据库状态来实现。伪代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aof_write</span>(<span class="params">new_aof_file_name</span>):</span></span><br><span class="line">  <span class="comment"># 创建新的AOF文件</span></span><br><span class="line">  f = create_file(new_aof_file_name)</span><br><span class="line">  <span class="comment"># 遍历数据库</span></span><br><span class="line">  <span class="keyword">for</span> db <span class="keyword">in</span> redisServer.db:</span><br><span class="line">    <span class="comment"># 忽略空数据库</span></span><br><span class="line">    <span class="keyword">if</span> db.is_empty():<span class="keyword">continue</span></span><br><span class="line">    <span class="comment"># 写入select命令，指定数据库号码</span></span><br><span class="line">    f.write_command(<span class="string">&quot;SELECT&quot;</span> + db.<span class="built_in">id</span>)</span><br><span class="line">    <span class="comment"># 遍历数据库中所有的键</span></span><br><span class="line">   <span class="keyword">for</span> key <span class="keyword">in</span> db:</span><br><span class="line">      <span class="keyword">if</span> key.is_expired():<span class="keyword">continue</span></span><br><span class="line">      <span class="comment"># 根据键的类型对键进行重写</span></span><br><span class="line">      <span class="keyword">if</span> key.<span class="built_in">type</span> == String:</span><br><span class="line">        rewrite_string(key)</span><br><span class="line">      <span class="keyword">elif</span> key.<span class="built_in">type</span> == <span class="type">List</span>:</span><br><span class="line">        rewrite_list(key)</span><br><span class="line">      <span class="keyword">elif</span> key.<span class="built_in">type</span> == Hash:</span><br><span class="line">        rewrite_hash(key)</span><br><span class="line">      <span class="keyword">elif</span> key.<span class="built_in">type</span> == <span class="type">Set</span>:</span><br><span class="line">        rewrite_set(key)</span><br><span class="line">      <span class="keyword">elif</span> key.<span class="built_in">type</span> == SortedSet:</span><br><span class="line">        rewrite_sorted_set(key)</span><br><span class="line">      <span class="comment"># 如果键带有过期时间，那么过期时间也要被重写</span></span><br><span class="line">      <span class="keyword">if</span> key.have_expire_time():</span><br><span class="line">        rewrite_expire_time(key)</span><br><span class="line"> <span class="comment"># 写入完毕，关闭文件</span></span><br><span class="line">  f.close()</span><br></pre></td></tr></table></figure><p>因为aof_rewrite函数所生成的新的AOF文件只包含还原当前数据库状态所必须的命令，所以新的AOF文件不会浪费任何硬盘空间。</p><h3 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h3><p>上面介绍的AOF重写程序aof_write函数可以很好地完成创建一个新的AOF文件的任务，但是因为这个函数会进行大量的写入操作，所以调用这个函数的线程将长时间阻塞，因为Redis服务器使用单线程来处理命令请求，所以服务器直接调用aof_rewrite函数的话，那么在重写AOF文件期间，服务将无法处理客户端发来的命令请求。</p><p>很明显作为一种辅佐性的维护手段，Redis不希望AOF重写造成服务器无法处理请求，所以Redis决定将AOF重写程序放在子进程当中。这样可以同时做到两个不同的目的：</p><ul><li>子进程进行AOF重写期间，服务器进程（父进程）可以继续处理命令请求。</li><li>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以避免使用锁的情况下，保证数据的安全性。</li></ul><p>但是这还有一个问题，就是重写过程中，服务器接受到了新的命令，如果不写入新的AOF文件当中，会产生不一致的问题。</p><p>为了解决这种数据不一致的问题，Redis服务器设置了一个AOF重写缓冲区。</p><p>当Redis服务器执行完成一个写命令之后会把这个命令发送给AOF缓冲区和AOF重写缓冲区。</p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><ul><li>AOF文件通过保存所有修改数据库的写命令请求来记录服务器的数据库状态。</li><li>AOF文件中的所有命令都以Redis命令请求协议的格式保存。</li><li>命令请求会先保存到AOF缓冲区里面，之后再定期写入并同步到AOF文件。</li><li>appendfsync选项的不同值对AOF持久化功能的安全性以及Redis服务器的性能有很大影响。</li><li>服务器只要载入并重新执行保存在AOF文件中的命令，就可以还原数据库本来的状态。</li><li>AOF重写可以产生一个新的AOF文件中的命令，这个新的AOF文件的和原来相比保存的数据库状态一样，但体积更小。</li><li>在执行BGREWRITEAOF命令时，Redis服务器会维护一个AOF重写缓冲区，该缓冲区会在子进程创建新的AOF文件期间，记录服务器执行的所有写命令，当子进程创建新AOF文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> 单机数据库的实现 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RDB持久化</title>
      <link href="2021/04/27/RDB%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>2021/04/27/RDB%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>本文是《Redis设计与实现》中关于RDB持久化的内容的笔记。<br> <span id="more"></span></p><h1 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h1><p>RDB持久化既可以手动完成也可以根据服务器的配置选项定期完成。</p><h2 id="RDB文件的创建与载入"><a href="#RDB文件的创建与载入" class="headerlink" title="RDB文件的创建与载入"></a>RDB文件的创建与载入</h2><p>有两个命令可以用于生成RDB文件，一个是SAVE，另一个是BGSAVE。</p><p>SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求：</p><p>和SAVE命令直接阻塞服务器进程的做法不同，BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程继续处理命令请求。</p><p>和创建不同的是，RDB文件的载入是在服务器启动时自动完成的，没有专门用来载入的命令。</p><p>因为AOF的更新频率通常比RDB文件的更新频率高，所以：</p><ul><li>如果服务器开启了AOF持久化功能，服务器优先使用AOF文件来还原数据库状态。</li><li>只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。</li></ul><h3 id="SAVE命令执行时的服务器状态"><a href="#SAVE命令执行时的服务器状态" class="headerlink" title="SAVE命令执行时的服务器状态"></a>SAVE命令执行时的服务器状态</h3><p>当服务器执行SAVE命令时，Redis服务器会阻塞，客户端发出的所有请求都会被阻塞。</p><h3 id="BGSAVE命令执行时的服务器状态"><a href="#BGSAVE命令执行时的服务器状态" class="headerlink" title="BGSAVE命令执行时的服务器状态"></a>BGSAVE命令执行时的服务器状态</h3><p>BGSAVE执行时，Redis服务器仍然可以继续处理客户端请求，但是SAVE、BGSAVE、BGREWRITEAOF三个命令会被拒绝。前两者是为了避免竞争条件，后者是机遇性能的考虑，毕竟这两个子进程都是执行大量的磁盘读写操作。</p><h3 id="RDB文件载入时的服务器状态"><a href="#RDB文件载入时的服务器状态" class="headerlink" title="RDB文件载入时的服务器状态"></a>RDB文件载入时的服务器状态</h3><p>服务器在载入RDB期间，会一直处于阻塞状态，直到载入工作完成为止。</p><h2 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a>自动间隔性保存</h2><p>因为BGSAVE命令可以在不阻塞服务器进程的情况下执行，所以Redis允许用户通过设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令。用户可以通过save选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行BGSAVE命令。</p><h2 id="设置保存条件"><a href="#设置保存条件" class="headerlink" title="设置保存条件"></a>设置保存条件</h2><p>当Redis服务器启动时，用户可以通过指定配置文件或者传入启动参数的方式设置save选项，如果用户没有主动设置save选项，那么服务器会为save选项设置默认条件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><p>接着，服务器会根据save选项所设置的保存条件，设置服务器状态redisServer结构的saveparams属性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">saveparams</span>;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>saveparams属性是一个数组，数组中每个元素都是一个saveparam结构，每个saveparam结构都保存了一个save选项设置的保存条件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span>&#123;</span></span><br><span class="line"><span class="comment">// 秒数</span></span><br><span class="line"><span class="keyword">time_t</span> seconds;</span><br><span class="line"><span class="comment">// 修改数</span></span><br><span class="line"><span class="keyword">int</span> changes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dirty计数器和lastsave属性"><a href="#dirty计数器和lastsave属性" class="headerlink" title="dirty计数器和lastsave属性"></a>dirty计数器和lastsave属性</h3><p>服务器还维持着一个dirty计数器，以及一个lastsave属性：</p><ul><li>dirty计数器记录距离上一次成功执行SAVE命令或者BGSAVE命令之后，服务器对数据库状态进行了多少次修改。</li><li>lastsave属性是一个UNIX时间戳，记录了服务器上一次成功执行SAVE命令或者BGSAVE命令的时间。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dirty;</span><br><span class="line"><span class="keyword">time_t</span> lastsave;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="检查保存条件是否满足"><a href="#检查保存条件是否满足" class="headerlink" title="检查保存条件是否满足"></a>检查保存条件是否满足</h3><p>Redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的保存条件是否已经满足，如果满足的话，就执行BGSAVE命令。</p><p>程序会遍历saveparams数组中的所有保存条件，只要有任意一个条件被满足，那么服务器就会执行BGSAVE命令。</p><h3 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h3><p>下图展示了一个完整的RDB文件所包含的各个部分：</p><p><img src="../images/RDB%E6%8C%81%E4%B9%85%E5%8C%96/image-20210427231327280.png" alt="image-20210427231327280"></p><p>REDIS部分的长度为5字节，保存着“REDIS”五个字符。通过这五个字符，程序可以在读入的时候判断所载入的文件是否是RDB文件。</p><p>db_version长度为4字节，它的值是一个字符串表示的整数，这个整数记录了RDB文件的版本号。</p><p>databases部分包含了零个或任意多个数据库，以及各个数据库中的键值对数据：</p><ul><li>如果服务器的数据库状态为空，那么这个部分也为空，长度为0字节。</li><li>如果服务器的数据库状态为非空，那么这个部分也为非空，根据数据库所保存键值对的数量、类型和内容不同，这个部分的长度也会有所不同。</li></ul><p>EOF常量的长度为1字节，这个常量标志着RDB文件正文内容的结束，当读入程序遇到这个值的时候，它知道所有数据库的所有键值对都已经载入完毕了。</p><p>check_sum是一个8字节长的无符号整数，保存着一个校验和，这个校验和事程序通过对REDIS、db_version、databases、EOF四个部分的内容进行计算得出的。服务器在载入RDB文件时，会将载入数据所计算出的校验和与check_sum所记录校验和进行对比，以此来检查RDB文件是否有出错或者损坏的情况出现。</p><h3 id="databases部分"><a href="#databases部分" class="headerlink" title="databases部分"></a>databases部分</h3><p>如果服务器的0号数据库和3号数据库非空的话，那么服务器将创建一个如图所示的RDB数据库：</p><p><img src="../images/RDB%E6%8C%81%E4%B9%85%E5%8C%96/image-20210427231349502.png" alt="image-20210427231349502"></p><p>每个非空数据库在RDB文件中都可以保存为SELECTDB、db_number、key_value_pairs三个部分，如图所示：</p><p><img src="../images/RDB%E6%8C%81%E4%B9%85%E5%8C%96/image-20210427231406992.png" alt="image-20210427231406992"></p><p>SELECTDB常量的长度为1字节，当读入程序遇到这个值的时候，它知道接下来要读入的将是一个数据库号码。</p><p>db_number保存着一个数据库号码，根据号码的大小不同，这个部分的长度可以是1字节、2字节或者5字节。当程序读入db_number部分之后，服务器会调用select命令，根据读入的数据库号码进行数据库切换，使得之后读入的键值对可以载入到正确的数据库中。</p><p>key_value_pairs部分保存了数据库中的所有键值对数据，如果键值对带有过期时间，那么过期时间也会和键值对保存在一起。根据键值对的数量、类型、内容以及是否有过期时间等条件的不同，key_value_pairs部分的长度也会有所不同。</p><h3 id="key-value-pairs部分"><a href="#key-value-pairs部分" class="headerlink" title="key_value_pairs部分"></a>key_value_pairs部分</h3><p>不带过期时间的键值对在RDB文件中由TYPE、key、value三部分组成，如图所示：</p><p><img src="../images/RDB%E6%8C%81%E4%B9%85%E5%8C%96/image-20210427231426094.png" alt="image-20210427231426094"></p><p>TYPE 记录了value的类型，长度为1字节，值可以是以下常量的其中一个：</p><p><img src="../images/RDB%E6%8C%81%E4%B9%85%E5%8C%96/image-20210427231446483.png" alt="image-20210427231446483"></p><p>当服务器读入RDB文件中的键值对数据时，程序会根据TYPE的值来决定如何读入和解释value的数据。</p><p>带有过期时间的键值对在RDB文件中的结构如图所示：</p><p><img src="../images/RDB%E6%8C%81%E4%B9%85%E5%8C%96/image-20210427231509645.png" alt="image-20210427231509645"></p><h3 id="value的编码"><a href="#value的编码" class="headerlink" title="value的编码"></a>value的编码</h3><p>RDB文件中每个value部分都保存了一个值对象，每个值对象的类型都由与之对应的TYPE记录，根据类型的不同，value部分的结构、长度也会有所不同。</p><h2 id="分析RDB文件"><a href="#分析RDB文件" class="headerlink" title="分析RDB文件"></a>分析RDB文件</h2><p>可以这样分析RDB文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> od -c dump.rdb //使用ASCII编码打印RDB文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> od -cx dump.rdb //同时以ASCII编码和16进制格式打印RDB文件</span> </span><br></pre></td></tr></table></figure><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><ul><li>RDB文件用于保存和还原Redis服务器所有数据结构中的所有键值对数据。</li><li>SAVE命令由服务器进程直接执行保存操作，所以该命令会阻塞服务器。</li><li>BGSAVE命令由子进程执行保存操作，所以该命令不会阻塞服务器。</li><li>服务器状态中会保存所有用save选项设置的保存条件，当任意一个保存条件被满足时，服务器会自动执行BGSAVE命令。</li><li>对于不同类型的键值对，RDB文件会使用不同方式来保存它们。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> 单机数据库的实现 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库</title>
      <link href="2021/04/27/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>2021/04/27/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>本文是《Redis设计与实现》中关于数据库的内容的笔记。<br> <span id="more"></span></p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h2><p>Redis服务器将所有数据库都保存在服务器状态redisServer的数组中，db数组的每个项都是一个redis.h/redisDb结构，每个redisDB结构都代表一个数据库。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 一个数组，保存着服务器中所有的数据库</span></span><br><span class="line">redisDb *db;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dbnum默认为16，由服务器配置的database选项决定。</p><h2 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h2><p>每个Redis客户端都有自己的目标数据库当每个客户端执行数据库写命令或者数据库读写命令的时候，目标数据库就会成为这些命令的操作对象。</p><p>默认情况下，Redis客户端的目标数据库为0号数据库，但客户端可以通过执行select命令来切换目标数据库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> <span class="built_in">set</span> msg <span class="string">&quot;hello world&quot;</span></span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> get msg</span></span><br><span class="line">&quot;hello world&quot;</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> select 2</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">redis[2]&gt;</span><span class="bash"> <span class="built_in">set</span> msg <span class="string">&quot;another world&quot;</span></span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">redis[2]&gt;</span><span class="bash"> get msg</span></span><br><span class="line">&quot;another world&quot;</span><br></pre></td></tr></table></figure><p>在服务器内部，客户端状态redisClient结构的db属性记录了客户端当前的目标数据库，这个属性是一个指向redisDb结构的指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span>&#123;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">redisDb *db;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;redisClient;</span><br></pre></td></tr></table></figure><p>由于redis不提供显示返回当前数据库的命令。所以建议在执行较为危险的指令的时候显示地执行一个select命令，切换到指定的数据库。</p><h3 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h3><p>redisDb结构中的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span>&#123;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">dict *dict;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>键空间和用户所见的数据库是直接对应的：</p><ul><li>键空间的键也就是数据库的键，每个键都是一个字符串对象。</li><li>键空间的值也就是数据库的值，每个值可以说字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象。</li></ul><h3 id="读写键空间时的维护操作"><a href="#读写键空间时的维护操作" class="headerlink" title="读写键空间时的维护操作"></a>读写键空间时的维护操作</h3><p>当Redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作，还会执行一些额外的维护操作，其中包括：</p><ul><li>读取一个键之后会根据键是否存在来更新服务器的键空间命中次数或键空间不命中次数，这两个值可以在INFO stats命令的keyspace_hits属性和keyspace_misses属性中查看。</li><li>读取一个键盘之后，服务器会更新键的LRU时间（最后一次使用时间），这个值可以用于计算键的闲置时间。</li><li>如果服务器在读取一个键时发现该键已经过期，那么服务器会删除这个过期键，然后才执行余下的其他操作。</li><li>如果客户端使用watch命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏（dirty），从而让事物程序注意到这个键已经被修改过。</li><li>服务器每次修改一个键之后，都会对脏（dirty）键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作。</li><li>如果数据库开启了数据库通知功能，那么在对键进行修改之后，服务器按配置发送相应的数据库通知。</li></ul><h2 id="设置键的生存时间或过期时间"><a href="#设置键的生存时间或过期时间" class="headerlink" title="设置键的生存时间或过期时间"></a>设置键的生存时间或过期时间</h2><p>Redis提供了expire或者pexpire命令设置键的生存时间，当经过了指定的时间之后，服务器会自动删除生存时间为0的键。</p><p>客户端还可以通过expireat命令或者pexpireat命令，以秒或者毫秒精度给数据库中的某个键设置过期时间。</p><h3 id="保存过期时间"><a href="#保存过期时间" class="headerlink" title="保存过期时间"></a>保存过期时间</h3><p>redisDb结构的expires字典保存了数据库所有键的过期时长，我们称这个为字典的过期字典：</p><ul><li><p>过期字典的键是一个指针，这个指针指向键空间的某个键对象。</p></li><li><p>过期字典的值一个是long long类型的整数，这个整数保存了键指向的数据库键的过期时间（毫秒精度的UNIX时间戳）。</p></li></ul><h2 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h2><h3 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h3><p>定时删除策略对内存最友好：通过使用定时器，定时删除策略可以保证过期键会尽可能快地删除，并释放过期键所占用的内存。</p><p>缺点：对CPU时间非常不友好：过期键比较多时，删除过期键可能会占用相当一部分CPU时间，在内存不紧张但是cPU时间非常紧张的情况下，将CPU时间浪费在删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。</p><h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><p>惰性删除对CPU时间来说是最友好的：程序只会在取出键时才对键进行过期检查，这可以保证删除过期键的操作只会在非做不可的情况下进行，并且删除目标仅限于当前处理的键，不会在无关键上浪费CPU时间。</p><h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h3><p>从上面的分析来看，这两种删除方式在单一使用时都有明显的缺陷：</p><ul><li><p>定时删除占用太多CPU时间，影响服务器的响应时间和吞吐量。</p></li><li><p>惰性删除浪费太多内存，有内存泄露的危险</p></li></ul><p>定期删除是两个策略的折中：</p><ul><li>每隔一段时间执行一次删除过期操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。</li><li>除此之外，通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的内存浪费。</li></ul><h2 id="Redis的过期键删除策略"><a href="#Redis的过期键删除策略" class="headerlink" title="Redis的过期键删除策略"></a>Redis的过期键删除策略</h2><p>Redis服务器实际上使用的是惰性删除和定期删除两种策略：通过配合使用这两种删除策略，服务器可以很好地在使用CPU时间和避免浪费内存空间之间取得平衡。</p><h2 id="AOF、RDB和复制功能对过期键的处理"><a href="#AOF、RDB和复制功能对过期键的处理" class="headerlink" title="AOF、RDB和复制功能对过期键的处理"></a>AOF、RDB和复制功能对过期键的处理</h2><h3 id="生成RDB文件"><a href="#生成RDB文件" class="headerlink" title="生成RDB文件"></a>生成RDB文件</h3><p>在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。</p><h3 id="载入RDB文件"><a href="#载入RDB文件" class="headerlink" title="载入RDB文件"></a>载入RDB文件</h3><p>在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入。</p><ul><li>如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。</li><li>如果服务器以从服务器模式运行，那么载入RDB文件时，文件保存的所有键，无论是否过期都会被载入数据库中。</li></ul><h3 id="AOF文件写入"><a href="#AOF文件写入" class="headerlink" title="AOF文件写入"></a>AOF文件写入</h3><p>当服务器以AOF持久化模式允许时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。</p><p>当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加一条DEL命令，来显式地记录该键已被删除。</p><h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><p>和生成RDB文件时类似，在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。</p><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制：</p><ul><li>主服务器在删除一个过期键之后，会显示地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。</li><li>从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键。</li><li>从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键。</li></ul><h2 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h2><p>数据库通知是Redis2.8版本新增的功能，这个功能可以让客户端通过订阅给定的平道或者模式，来获知数据库中键的变化，以及数据库命令的执行情况。</p><p>服务器配置的notify-keyspace-events选项决定了服务器所发送通知的类型。</p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><ul><li>Redis服务器的所有数据库都保存在redisServer.db数组中，而数据库的数量则由redisServer.dbnum属性保存。</li><li>客户端通过修改目标数据库的指针，让它指向redisServer.db数组中的不同元素来切换不同的数据库。</li><li>数据库主要由dict和expires两个字典构成，其中dict字典负责保存键值对，而expires字典则负责保存键的过期时间。</li><li>因为数据库由字典构成，所以对数据库的操作都是建立在字典操作之上的。</li><li>数据库的键总是一个字符串对象，而值则可以是任意一种Redis对象类型，包括字符串对象、哈希表对象、集合对象等等。</li><li><p>expires字典的键指向数据库中的某个键，而值则记录了数据库键的过期时间，过期时间是一个以毫秒为单位的UNIX时间戳。</p></li><li><p>Redis使用惰性删除和定期删除两种策略来删除过期的键。</p></li><li>执行SAVE命令或者BGSAVE命令所产生的新RDB文件不会包含已经过期的键。</li><li>执行BGREWRITEAOF命令所产生的重写AOF文件不会抱憾已经过期的键。</li><li>当一个过期键被删除之后，服务器会追加一条DEL命令到现有的AOF文件的末尾，显示地删除过期键。</li><li>当主服务器删除一个过期键之后，它会向所有服务器发送一条DEL命令，显示地删除过期键。</li><li>从服务器即使发现过期键也不会自作主张地删除它，而是等待主节点发来DEL命令，这种统一、中心化的过期键删除策略可以保证主从服务器数据的一致性。</li><li>当Redis命令对数据库进行修改之后，服务器会根据配置向客户端发送数据库通知。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> 单机数据库的实现 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对象</title>
      <link href="2021/04/24/%E5%AF%B9%E8%B1%A1/"/>
      <url>2021/04/24/%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>本文是《Redis设计与实现》中关于对象的内容的笔记。<br> <span id="more"></span></p><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="对象的类型与编码"><a href="#对象的类型与编码" class="headerlink" title="对象的类型与编码"></a>对象的类型与编码</h2><p>Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象）。  </p><p>Redis中的每个对象都由一个redisObject结构表示，该结构中和保存数据有关的三个属性分别是type属性、encoding属性和ptr属性：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">  <span class="comment">//类型</span></span><br><span class="line">  <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">  <span class="comment">// 编码</span></span><br><span class="line">  <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">  <span class="comment">// 指向底层实现数据结构的指针</span></span><br><span class="line">  <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>type属性记录了对象的类型，这个属性的值可以是表中列出的常量的其中一个。  </p><p><img src="../images/%E5%AF%B9%E8%B1%A1/image-20210424232016862.png" alt="image-20210424232016862"></p><p>对于redis数据库保存的键值对来说，键总是一个字符串对象，而值可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种。  </p><p>注意的是：我们对一个数据库键执行TYPE命令时，命令返回的结果为数据库键对应的值对象的类型，而不是键对象的类型。  </p><h3 id="编码和底层实现"><a href="#编码和底层实现" class="headerlink" title="编码和底层实现"></a>编码和底层实现</h3><p>对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。  </p><p>encoding属性记录了对象所使用的编码，也即是说这个对象使用了什么数据结构作为对象的底层实现，这个属性的值可以是下表列出的常量的其中一个。  </p><p><img src="../images/%E5%AF%B9%E8%B1%A1/image-20210424232122061.png" alt="image-20210424232122061"></p><p>每种类型都至少使用了两种不同的编码，可以看下表。  </p><p><img src="../images/%E5%AF%B9%E8%B1%A1/image-20210424232135278.png" alt="image-20210424232135278"></p><p>通过encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，极大地提高了Redis的灵活性和效率，因为Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率。  </p><p>举个例子，在列表对象包含的元素比较少时，Redis使用压缩列表作为列表对象的底层实现：  </p><ul><li>因为压缩列表比双端链表更节约内存，并且在元素数量较少的时，在内存中以连续块方式保存的压缩列表比起双端队列更容易被载入到缓存中来。  </li><li>随着列表对象包含的元素越来越多，使用压缩列表来保存元素的优势逐渐消失时，对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端队列上了。  </li></ul><p>其他类型的对象也会通过使用多种不同的编码来进行类似的优化。  </p><h2 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h2><p>字符串对象可以是int、raw或者embstr。</p><p>如果一个字符串对象保存的是整数值，并且这个整数可以用long类型来表示，那么字符串对象会将整个整数值保存在字符串对象结构的ptr属性里面。（将void*转换成long），并将字符串对象的编码设置为int。  </p><p>如果字符串对象保存的是一个字符串值，并且这个字符串长度大于等于39字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw。</p><p>如果字符串对象保存的是要给字符串值，并且这个字符串值得长度小于等于39字节，那么字符串对象将使用embstr编码得方式来保存这个字符串字面值。  </p><p>embstr编码是专门用于保存短字符串的一种优化编码方式，这种编码和raw编码一样，都使用redisObject结构和sdshdr结构，而embstr编码则通过调用一次内存分配函数来分配一块连续的空间，空间中一次包含redisObject和sdshdr两个结构。  </p><p>embstr编码的字符串对象在执行命令时，产生的效果和raw编码的字符串对象执行命令时产生的效果是相同的，但使用embstr编码字符串对象来保存短字符串值有以下好处：  </p><ul><li>embstr编码将创建字符串对象所需的内存分配次数从raw编码的两次降低为一次。</li><li>释放embstr编码的字符串对象只需要调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次内存释放函数。</li><li>因为embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起raw编码的字符串对象能够更好的利用缓存带来的优势。</li></ul><p>最后说一下啊，可以用long double类型表示的浮点数在Redis中也是作为字符串值来保存的。如果我们要保存一个浮点数到字符串对象里面，那么程序会先将这个浮点数转换成字符串值，然后再保存转换所得的字符串值。</p><h3 id="编码的转换"><a href="#编码的转换" class="headerlink" title="编码的转换"></a>编码的转换</h3><p>int编码的字符串对象和embstr编码的字符串对象在满足条件的情况下，会被转换为为raw编码的字符串对象。  </p><p>比如我们set了一个键number，值为10086。它的编码方式这时是int，但是如果我们<code>append number &quot;something&quot;</code> 会导致number先转换成raw类型，然后再执行append操作。  </p><p>下面列举了一些字符串命令：</p><p><img src="../images/%E5%AF%B9%E8%B1%A1/image-20210424235844316.png" alt="image-20210424235844316"></p><h2 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h2><p>列表的编码可以为ziplist或者linkedlist。</p><p>ziplist编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点保存了一个列表元素。举个例子，如果我们执行一下RPUSH命令，那么服务器将创建一个列表对象作为numbers键的值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> RPUSH numbers 1 <span class="string">&quot;three&quot;</span> 5</span></span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><p>这两种编码的区别，下面两张图可以很清晰的表现出来：</p><p><img src="../images/%E5%AF%B9%E8%B1%A1/image-20210425000413538.png" alt="image-20210425000413538"></p><p><img src="../images/%E5%AF%B9%E8%B1%A1/image-20210425000424675.png" alt="image-20210425000424675"></p><h3 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h3><p>当列表对象可以同时满足以下两个条件时，列表对象使用ziplist编码：</p><ul><li><p>列表对象保存的所有字符串元素的长度都小于64字节；</p></li><li><p>列表对象保存的元素数量小于512个；不能满足这两个条件的列表对象需要使用linkedlist编码。</p></li></ul><p>注意：这两个条件的上限值都是可以修改的，具体请看配置文件中关于list-max-ziplist-value选项和list-max-ziplist-entries选项的说明。</p><p>下面列出了一部分的列表命令：</p><p><img src="../images/%E5%AF%B9%E8%B1%A1/image-20210425000839273.png" alt="image-20210425000839273"></p><h2 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h2><p>哈希对象的编码可以是ziplist或者hashtable。</p><p>ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩队列节点推入到压缩列表表尾，然后再将保存了值得压缩列表节点推入到压缩列表表尾。因此：</p><ul><li><p>保存了统一键值对得两个节点总是紧挨在一起，保存键得节点在前，保存值的节点在后。</p></li><li><p>先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。</p></li></ul><p><img src="../images/%E5%AF%B9%E8%B1%A1/image-20210425150536031.png" alt="image-20210425150536031"></p><p>另一方面，hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都是用一个字典键值对来保存：</p><ul><li>字典的每个键都是一个字符串对象，对象中保存了键值对的键；</li><li>字典中每个值都是一个字符串对象，对象中保存了键值对的值。</li></ul><p><img src="../images/%E5%AF%B9%E8%B1%A1/image-20210425150550462.png" alt="image-20210425150550462"></p><h3 id="编码转换-1"><a href="#编码转换-1" class="headerlink" title="编码转换"></a>编码转换</h3><p>当哈希对象可以同时满足以下两个条件是，哈希对象使用ziplist编码：</p><ul><li>哈希对象保存的所有键和值的字符串长度都小于64字节；</li><li>哈希对象保存的键值对数量小于512个；不能满足这两个条件的哈希对象需要使用hashtable编码。</li></ul><h3 id="哈希命令的实现"><a href="#哈希命令的实现" class="headerlink" title="哈希命令的实现"></a>哈希命令的实现</h3><p><img src="../images/%E5%AF%B9%E8%B1%A1/image-20210425150641574.png" alt="image-20210425150641574"></p><h2 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h2><p>集合对象的编码可以是intset或者hashtable。</p><p>intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面。</p><h3 id="编码的转换-1"><a href="#编码的转换-1" class="headerlink" title="编码的转换"></a>编码的转换</h3><p>当集合对象可以同时满足以下两个条件时，对象使用intset编码：</p><ul><li>集合对象保存的所有元素都是整数值；</li><li>集合对象保存的元素数量不超过512个。</li></ul><p>不能满足这两个条件的集合对象使用hashtable编码。</p><h3 id="集合命令的实现"><a href="#集合命令的实现" class="headerlink" title="集合命令的实现"></a>集合命令的实现</h3><p><img src="../images/%E5%AF%B9%E8%B1%A1/image-20210425165006536.png" alt="image-20210425165006536"></p><p><img src="../images/%E5%AF%B9%E8%B1%A1/image-20210425165021809.png" alt="image-20210425165021809"></p><h3 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h3><p>有序集合的编码可以是ziplist或者skiplist。</p><p>ziplist编码的有序集合对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存成员（member），而第二个元素则保存分值。</p><p>压缩列表内的集合元素按照分值从小到大进行排序。</p><p>skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span>&#123;</span></span><br><span class="line">zskiplist *zsl;</span><br><span class="line">dict *dict;</span><br><span class="line">&#125;zset;</span><br></pre></td></tr></table></figure><p>zset结构中的zsl跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素：跳跃表节点的object属性保存了元素的成员，而跳跃表节点的score属性则保存了元素的分值。通过这个跳跃表，程序可以对有序集合进行范围操作，比如ZRANK、ZRANGE等命令就是基于跳跃表API来实现的。</p><p>有序集合每个元素的成员是一个字符串对象，而每个元素的分值都是一个double类型浮点数。值得一提，虽然zset结构同时使用跳跃表和字典来保存有序集合，但是这两种数据结构通过指针来共享相同元素的成员和分值。</p><p>同时使用字典和跳跃表的优点：</p><ul><li>跳跃表可以用来高效地执行范围操作。</li><li>字典可以实现O(1)根据，成员查找分值。</li></ul><h3 id="编码转换-2"><a href="#编码转换-2" class="headerlink" title="编码转换"></a>编码转换</h3><p>当有序集合对象可以同时满足以下两个条件时，对象使用ziplist编码：</p><ul><li><p>有序集合保存的元素数量小于128个；</p></li><li><p>有序集合保存的所有元素成员长度超过都小于64字节。</p></li></ul><h2 id="类型检查与命令多态"><a href="#类型检查与命令多态" class="headerlink" title="类型检查与命令多态"></a>类型检查与命令多态</h2><p>Redis中用于操作键的命令基本上可以分为两种类型。其中一种命令可以对任何类型的键执行，比如说DEL命令、EXPIRE命令、RENAME命令、TYPE命令、OBJECT命令等。</p><p>而另一种命令只能对特定类型的键执行，比如说：</p><p><img src="../images/%E5%AF%B9%E8%B1%A1/image-20210425222741769.png" alt="image-20210425222741769"></p><p>举个例子，我们可以用SET命令创建一个字符串键，然后用GET命令和APPEND命令操作这个键，但如果我们试图对这个字符串键执行只有列表键才能执行的LLEN命令，那么Redis将向我们返回一个类型错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> <span class="built_in">set</span> msg <span class="string">&quot;hello world&quot;</span></span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> get msg</span></span><br><span class="line">&quot;hello world&quot;</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> append msg <span class="string">&quot; again!&quot;</span></span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> get msg</span></span><br><span class="line">&quot;hello world again!&quot;</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> LLEN msg</span></span><br><span class="line">(error) WRONGTYPE Operation against a key holding the wrong kind of values</span><br></pre></td></tr></table></figure><h3 id="类型检查的实现"><a href="#类型检查的实现" class="headerlink" title="类型检查的实现"></a>类型检查的实现</h3><p>从上面发生的类型错误代码示例可以看出，为了确保只有指定类型的键可以执行某些特定的命令，在执行一个类型特定的命令之前，Redis会先检查输入键的类型是否正确，然后再决定是否执行给定的命令。</p><p>类型特定命令所进行的检查是通过redisObject结构的type属性来实现的。</p><h3 id="多态命令的实现"><a href="#多态命令的实现" class="headerlink" title="多态命令的实现"></a>多态命令的实现</h3><p>Redis会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。</p><h2 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h2><p>因为C语言并不具备自动回收内存功能，所以Redis在自己的对象系统中构建了一个引用计数技术实现内存回收机制，通过这一机制，程序员可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。</p><h2 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h2><p>除了用于实现引用计数内存回收机制之外，对象的引用计数属性还带有对象共享的作用。举个例子，假设键A创建了一个包含整数值100的字符串对象作为值对象，如图所示。</p><p>如果这时键B也创建一个同样包含整数值100的字符串对象作为值对象，那么服务器有两种做法：</p><ul><li>为键B新创建一个包含整数值100的字符穿对象；</li><li>让键A和键B共享同一个字符串对象；</li></ul><p>以上两种方法很明显第二种更见节省内存。</p><p><img src="../images/%E5%AF%B9%E8%B1%A1/image-20210425231121597.png" alt="image-20210425231121597"></p><p>但是由于考虑需要检查对象是否一致来决定是否共享，所以实际上Redis只对包含整数值的字符串对象进行共享。</p><h2 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h2><p>除了前面介绍过的type、encoding、ptr和refcount四个属性之外，redisObject结构包含的最后一个属性为lru属性，该属性记录了对象最后一次被命令程序访问的时间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">unsigned</span> lru:<span class="number">22</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>object idletime</code>可以打印出给定键的空转时长，这一空转时长就是当前时间减去lru计算出来的。</p><p>出来可以被 <code>object idletime</code>命令打印出来之外，键的空转时长还有另外一项作用：如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，那么服务器占用的内存数超过了maxmemory选项所设置的上限，空转时长较高的那部分键会优先被服务器释放掉，从而回收内存。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> 数据结构与对象 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>压缩列表</title>
      <link href="2021/04/23/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/"/>
      <url>2021/04/23/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h1><h2 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h2><p><img src="../images/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/压缩列表的各个组成部分.png" alt="压缩列表的各个组成部分"></p><div class="table-container"><table><thead><tr><th style="text-align:left">属性</th><th>类型</th><th>长度</th><th>用途</th></tr></thead><tbody><tr><td style="text-align:left">zlbytes</td><td>uint32_t</td><td>4字节</td><td>记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配，或者计算zlend的位置时使用</td></tr><tr><td style="text-align:left">zltail</td><td>uint32_t</td><td>4字节</td><td>记录压缩列表距离列表尾节点的起始地址有多少字节</td></tr><tr><td style="text-align:left">zllen</td><td>uint32_t</td><td>2字节</td><td>记录压缩列表包含的节点数量，当这个属性的值下于UINT16_MAX（65535）时，则个值才是正确的，超过时候需要遍历整个列表才能计算得出</td></tr><tr><td style="text-align:left">entryX</td><td>列表节点</td><td>不定</td><td>压缩列表包含的各个节点长度并不一定相同，长度由节点保存的内容决定</td></tr><tr><td style="text-align:left">zlend</td><td>uint8_t</td><td>1字节</td><td>特殊值0xFF，用于标记压缩列表的末端</td></tr></tbody></table></div><h2 id="压缩列表的节点构成"><a href="#压缩列表的节点构成" class="headerlink" title="压缩列表的节点构成"></a>压缩列表的节点构成</h2><p>每个压缩列表节点都可以保存一个字节数组或者一个整数值，其中字节数组可以是以下三种长度之一：</p><ul><li>长度小于等于63（$2^6-1$）字节的字节数组；  </li><li>长度小于等于16383（$2^{14}-1$）字节的字节数组；  </li><li>长度小于等于4294967295（$2^{32}-1$）字节的字节数组；  </li></ul><p>而整数可以是4位、1字节、3字节、int16_t、int32_t、int64_t。</p><p>每个压缩列表节点都有previous_entry_length、encoding、content三个部分组成。如图所示：</p><p><img src="../images/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/image-20210424000604329.png" alt="压缩列表节点的各个组成部分"></p><h3 id="previous-entry-length"><a href="#previous-entry-length" class="headerlink" title="previous_entry_length"></a>previous_entry_length</h3><p>节点的previous_entry_length属性以字节为单位，记录了压缩列表中前一个节点的长度。该属性可以说1字节或者5字节，如果前一个结点长度小于254，则用一个字节；如果大于等于254字节，则用5个字节，并且第一个字节置为0xFE（十进制的254）。后面四个字节用于保存长度信息。  </p><h3 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h3><p>节点的encoding属性记录了节点的content属性所保存的数据的类型以及长度：  </p><p>一字节、两字节或者五字节长，值得最高位为00、01或者10是字节数组编码：这种编码表示节点得content属性保存着字节数组，数组的长度由编码除去最高两位之后的其他位记录；  </p><p><img src="../images/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/image-20210424002245234.png" alt="字节数组编码"></p><p>一字节长，值的最高位以11开头的是整数编码：这种编码表示节点的content属性保存着整数值，整数值的类型和长度由编码出去最高两位之后的其他位记录；  </p><p><img src="../images/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/image-20210424002304775.png" alt="整数编码"></p><h3 id="content"><a href="#content" class="headerlink" title="content"></a>content</h3><p>节点的content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值得类型和长度由节点得encoding属性决定。</p><h2 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h2><p>连锁更新是指多个连续节点的长度是250-253，而在它们的前面插入了一个大于等于254字节节点，导致后面的节点需要将previous_entry_length从原来的1字节长扩展为5字节长，然后产生连锁反应，后续的节点都需要重新进行空间分配，这种特殊情况称为连锁更新，但是由于这种情况较少出现，我们可以方向地使用压缩列表，ziplistPush等命令的平均复杂度仅为O(N)。</p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><ol><li>压缩列表是一种为节约内存而开发的顺序型数据结构。  </li><li>压缩列表被用作列表键和哈希键的底层实现之一。</li><li>压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。  </li><li>添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引起连锁更新操作，但这种操作出现的机率并不高。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> 数据结构与对象 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大话设计模式</title>
      <link href="2021/04/22/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/04/22/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>大话设计模式学习笔记。<br>这篇文章是本人学习《大话设计模式》所做的读书笔记。<br> <span id="more"></span></p><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>样例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpoerationFactory</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> Operation* createOperate(string operate)</span><br><span class="line">    &#123;</span><br><span class="line">        Operation* oper = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span>(operate)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                oper = <span class="keyword">new</span> OperationAdd;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-:</span></span><br><span class="line"><span class="string">                oper = new OperationSub;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;</span>*<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">                oper = new OperationMul;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;</span>/<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">                oper = new OperationDiv;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        return oper;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure></p><p>这就是简单工厂模式，工厂负责实例化合适的对象，通过多态返回父类的方式实现了计算器的结果。  </p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式定义了算法家族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。看起来商场收银系统应该考虑用策略模式？<br>Context-&gt;Strategy&lt;-ConcreteStrategyA、ConcreteStrategyB、ConcreteStrategyC。<br>ConcreteStrategyA、ConcreteStrategyB、ConcreteStrategyC等都是Strategy的派生类，内部实现了一套算法逻辑，然后Context内部用有一个Startegy变量来引用这些策略的其中之一。<br>策略模式可以和简单工厂结合使用，根据参数来为返回一个Startegy的派生类。<br>策略模式是一种定义一系列算法的方法，从概念来看，所有这些算法完成的都是相同的工作，只是实习不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。</p><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>单一职责原则：就一个类而言，应该仅有一个引起他变化的原因。</p><h2 id="开放-封闭原则"><a href="#开放-封闭原则" class="headerlink" title="开放-封闭原则"></a>开放-封闭原则</h2><p>定义：对于扩展是开放的，对于更改是封闭的。<br>简单来说，就是设计的时候要考虑让这个类足够好，写好就不要去修改了，如果新需求来了，就去增加新的类就好了。无论模块是多么“封闭”，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须构造对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。<br>开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现频繁变化的那些部分做出抽象，然后，对于应用程序中的每个部分都刻意进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。  </p><h2 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h2><p>高层模块不应该依赖低层模块。两个模块都应该依赖抽象。抽象不应该依赖细节。细节应该依赖抽象。</p><h2 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h2><p>一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序行为没有变化。</p><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更加灵活。<br>代码示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">class ConcreteComponent : Component</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> override <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        console.WriteLine(<span class="string">&quot;具体对象的操作&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">abstract class Decorator : Component</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> Component component;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetComponent</span><span class="params">(Component component)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component = component</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> override <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (component != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            component.Operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ConcreteDecoratorA : Decorator</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> string addedState4;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> override <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        base.Operation();</span><br><span class="line">        addedState = <span class="string">&quot;New State&quot;</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;具体装饰对象A的操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ConcreteDecoratorB : Decorator</span><br><span class="line">&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> override <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        base.Operation();</span><br><span class="line">        AddedBehavior();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;具体装饰对象B的操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddedBehavior</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 本类独有的方法，以区别于ConcreteDecoratorA</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">(string[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ConcreteComponent c = <span class="keyword">new</span> ConcreteComponent();</span><br><span class="line">    ConcreteDecoratorA d1 = <span class="keyword">new</span> ConcreteDecoratorA();</span><br><span class="line">    ConcreteDecoratorB d2 = <span class="keyword">new</span> ConcreteDecoratorB();</span><br><span class="line"></span><br><span class="line">    d1.SetComponent(c);</span><br><span class="line">    d2.SetComponent(d1);</span><br><span class="line">    d2.Operation();</span><br><span class="line">    Console.Read();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// d2-&gt;d1-&gt;c</span></span><br></pre></td></tr></table></figure></p><p>装饰模式是为已有的功能动态地添加更多功能的一种方式。当系统需要新功能的时候，是向旧的类中添加新的代码。这些新加的代码通常装饰了原有类的核心职责或主要行为。但这种做法的问题在于，它们在主类中加入了新的字段，新的方法和新的逻辑，从而增加了主类的复杂度。而装饰模式提供了一个非常好的解决方案，它把每个装饰的功能放在单独的类中，并让这个类包装它所要装饰的对象，因此当需要执行特殊行为时，客户代码就可以在运行时根据需要有选择地、按顺序地使用装饰功能包装对象了。<br>优点：把类中的装饰功能从类中搬移去除，这样可以简化原有的类。有效地把类的核心职责和装饰功能分开了。而且可以去除相关的重复的装饰逻辑。  </p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式（Proxy），为其他对象提供一种代理以控制对这个独享的访问。<br>代码示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义了RealSubject和Proxy的公共接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">class RealSubject : Subject</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> override <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;真实的请求&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Proxy : Subject</span><br><span class="line">&#123;</span><br><span class="line">    RealSubject realSubject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> override <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (realSubject == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        &#125;</span><br><span class="line">        realSubject.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">(string[], args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Proxy proxy = <span class="keyword">new</span> Proxy();</span><br><span class="line">    proxy.Request();</span><br><span class="line">    Console.Read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代理模式一般来说在这样几种场合使用：  </p><ol><li>远程代理，也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。  </li><li>虚拟代理，是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。  </li><li>安全代理，用来控制真实对象访问时的权限。  </li><li>智能指引，是指当调用真实的对象的时候，代理处理另外一些事情。  </li></ol><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。<br>工厂模式中主要涉及到的接口为Creator、Product。前者是工厂的一个抽象类，派生出具体的工厂类ConcreteCreator，这些工厂类重写工厂的FactoryMethod方法，用来提供Product实例。Product是工厂方法定义的对象的接口，派生出来<br>代码示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">Operation <span class="title">CreateOperation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">class AddFactory : IFactory</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Operation <span class="title">CreateOperation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OperationAdd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class SubFactory : IFactory</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Operation <span class="title">CreateOperation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OperationSub();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MulFactory : IFactory</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Operation <span class="title">CreateOperation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OperationMul();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class DivFactory : IFactory</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Operation <span class="title">CreateOperation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OperationDiv();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line">Ifactory operFactory = <span class="keyword">new</span> AddFactory();</span><br><span class="line">Operation oper = operFactory.CreateOperation();</span><br><span class="line">oper.NumberA = <span class="number">1</span>;</span><br><span class="line">oper.NumberB = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">double</span> result=oper.GetResult();</span><br></pre></td></tr></table></figure></p><p>简单工厂模式的最大优点就在于工厂类中包含了必要的逻辑判断，根据客户端的选择动态实例化相关的类，对于客户端来说，去除与具体产品的依赖。但如果要添加新的功能，就必须去修改原有的代码，在工厂类中添加新的“case”分支条件，这可不是好办法。而工厂模式就只需要重写开发新的具体工厂类即可，不需要改动现有的代码，这符合开放-封闭原则。  </p><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>定义：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。<br>原型模式就是从一个对象再创建另外一个可以定制的对象，而不需要知道任何创建的细节。</p><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>模板方法模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。  </p><h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p>定义：在类的结构涉及上，每一个类都应该尽量降低成员的访问权限，也就是说，一个类包装好自己的private状态，不需要让别的类知道的字段或行文就不要公开。迪米特法则的根本思想是强调了类之间的松耦合。类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。  </p><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>定义：为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br>何时使用外观模式呢？<br>首先，在设计初期阶段，应该有意识将不同的两个层分离。比如经典的三层架构，就需要考虑在数据访问层和业务逻辑层、业务逻辑层和表示层的层与层之间建立外观的Facade，这样可以为复杂的子系统提供一个简单的接口，使得耦合度大大降低。其次，在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂。大多数的模式使用时也都会产生很多很小的类，这本是好事，但也给外部调用它们的用户程序带来了使用上的困难，增加外观Facade可以提供一个简单的接口，减少他们之间的依赖。第三，在维护一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展了。但因为它包含非常重要的功能，新的需求开发必须依赖于它。此时用外观模式Facade也是合适的。  </p><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>定义：将一个复杂对象的构建过程与它的表示分离，使得同样的构建过程可以创建不同的表示。<br>建造者是一个Builder抽象接口，然后派生出ConcreteBuilder的具体建造者类，其提供各种方法来构造和装配各个部件。然后最终会建造出一个Product实例，Product类就是我们需要构建的类。<br>建造者模式还有一个重要角色就是指挥者-Director，是构建一个使用Builder接口的对象。<br>所以说，建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分，以及它们的装配方式时适用的模式。  </p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式又 称发布-订阅模式。<br>定义：它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时会通知所有观察者对象，使它们能够自动更新自己。<br>观察者模式所做的工作其实就是接触耦合。让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>定义：提供一个创建一系列相关或依赖对象的接口，而无需指定它们具体的类。  </p><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>定义：当一个对象的内在状态改变时允许其该百年其行为，这个对象看起来像是改变了其类。<br>状态模式i主要解决的是控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。<br>Context-&gt;State&lt;-ConcreteStateA、ConcreteStateB、ConcreteStateC。具体状态，每个子类实现一个与Contgext的一个状态相关的行为。  </p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>定义：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br>系统的数据和行为都正确，但接口不符时，我们应该考虑用适配器，目前是使控制范围之外的一个原有对象与某个接口匹配。适配器模式主要应用于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况，比如需要对早期代码复用一些功能等应用上很有实际价值。  </p><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>备忘录：在不破坏分装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。  </p><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>定义：将对象组合成树形结构表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象使用具有一致性。   </p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上述代码通过私有化构造函数，能够保证只实例化一次。但是面对多线程程序，它不能满足要求，如果同时两个线程判断instance为空，则会获得两个实例。<br>我们可以通过双重检测来实现线程安全的单例模式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> readonly object syncRoot = <span class="keyword">new</span> object();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            lock(syncRoot)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果在自己被加载时就将自己实例化，所以被形象地称为饿汉式单例类，原先的单例模式处理方式是要在第一次被引用时，才会将自己实例化，所以就被称为懒汉式单例类。  </p><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>桥接模式（Bridge）：将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br>这里需要理解一下，什么叫做抽象与它的实现分离，这并不是说，让抽象与它的实现部分分离，使它们都可以独立地变化。  </p><h3 id="合成-聚合复用原则"><a href="#合成-聚合复用原则" class="headerlink" title="合成/聚合复用原则"></a>合成/聚合复用原则</h3><p>合成/聚合复用原则（CARP）：尽量使用合成/聚合，尽量不要使用类继承。<br>合成和聚合都是关联的特殊种类。聚合表示一种弱的“拥有”关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；合成则是一种强的“拥有”关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。  </p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>命令模式（Command）：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。<br>优点：  </p><ol><li>它能较容易设计一个命令队列；  </li><li>在需要的情况下，可以较容易地将命令记入日志；  </li><li>允许接收请求的一方决定是否要否决请求。  </li></ol><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>责任链模式（Chain of Responsibility）：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链条传递该请求，直到有一个对象处理它为止。  </p><p>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Handler successor;</span><br><span class="line">    <span class="comment">// 设置继任者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetSuccessor</span><span class="params">(Handler successor)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.successor = successor</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">HandleRequest</span><span class="params">(<span class="keyword">int</span> request)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当请求数在0到10之间则有权处理，否则转到下一位</span></span><br><span class="line">class ConcreteHandler1 : Handler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> override <span class="keyword">void</span> <span class="title">HandleRequest</span><span class="params">(<span class="keyword">int</span> request)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(request &gt;= <span class="number">0</span> &amp;&amp; request &lt; <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Writeln(<span class="string">&quot;&#123;0&#125; 处理请求 &#123;1&#125;&quot;</span>,</span><br><span class="line">                <span class="keyword">this</span>.GetType().Name, request);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(successor != nil)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 转移到下一位</span></span><br><span class="line">            successor.HandleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当请求数在10到20之间有权处理，否则转到下一位</span></span><br><span class="line">class ConcreteHandler2 : Handler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> override <span class="keyword">void</span> <span class="title">HandleRequest</span><span class="params">(<span class="keyword">int</span> request)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(request &gt;= <span class="number">10</span> &amp;&amp; request &lt; <span class="number">20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;&#123;0&#125; 处理请求 &#123;1&#125;&quot;</span>,</span><br><span class="line">                <span class="keyword">this</span>.GetType().Name, request);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sucessor != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            successor.HandleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好处：当客户提交一个请求的时，请求是沿链传递直至有一个ConcreteHandler对象负责处理它。这样就不用说明要哪个类来处理它，责任链对请求者也是不可见的。  </p><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>中介者模式（Dediator）：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。<br>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象中介类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">(string message, Colleague colleague)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象同事类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Mediator meidator;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Colleague</span><span class="params">(Mediator mediator)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体中介类</span></span><br><span class="line">class ConcreteMediator : Mediator</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> ConcreteColleague1 colleague1;</span><br><span class="line">    <span class="keyword">private</span> ConcreteColleague1 colleague2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ConcreteColleague1 Colleague1</span><br><span class="line">    &#123;</span><br><span class="line">        set &#123; colleague1 = value; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ConcreteColleague2 Colleague2</span><br><span class="line">    &#123;</span><br><span class="line">        set &#123; colleague2 = value; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> override <span class="keyword">void</span> <span class="title">Send</span><span class="params">(string message, Colleague colleague)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (colleague == colleague1)</span><br><span class="line">        &#123;</span><br><span class="line">            colleague2.Notify(message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            colleague1.Notify(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 各种同事对象......</span></span><br></pre></td></tr></table></figure></p><p>优点：Mediator的出现减少了各个Colleague的耦合，使得可以独立地改变和复用各个Colleague类和Mediator，比如任何国家的改变不会影响到其他国家，而只是与安理会发生变化。其次，由于把对象如何协作进行了抽象，将中介作为一个独立的概念并将其封装在一个对象中，这样关注的对象就从对象各自本身的行为转移到它们之间的交互上来，也就是站在一个更宏观的角度看待系统。<br>缺点：由于ConcreteMediator控制了集中化，于是就把交互的复杂性变成了中介者的复杂性，这就使得中介者会变得非常复杂。  </p><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元模式（Flyweight）：运用享元模式有效地支持大量细粒度的对象。<br>在享元对象内部并且不会随环境改变而改变的共享部分，可以称为是享元对象的内部状态，而随环境改变而改变的、不可以共享的状态就是外部状态了。事实上，享元模式可以避免大量非常相似类的开销。在程序设计中，有时需要生成大量细粒度的类实例来表示数据。如果能发现这些实例除了几个参数外基本都是相同的，有时就能够受大幅度地减少需要实例化的类的数量。如果能把那些参数迁移到类实例外面，在方法调用时将它们传递进来，就可以通过共享大幅度减少单个实例的数目。<br>什么时候应该使用享元模式：<br>如果一个应用程序使用了大量的对象，而大量的这些对象造成了很大的存储开销时就应该考虑使用；还有就是对象的大多数状态可以外部状态，如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象，此时可以考虑使用享元模式。  </p><h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><p>解释器模式（interpreter）：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。<br>解释器模式需要解决的是，如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。<br>解释器模式就是用“迷你语言”来表现程序要解决的问题，以迷你语言写成“迷你程序”来表现具体问题。通常当有一个语言需要解释执行，并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。  </p><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>访问者模式（Visitor）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变个元素的类的前提下定义作用于这些元素的新操作。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字典</title>
      <link href="2021/04/21/%E5%AD%97%E5%85%B8/"/>
      <url>2021/04/21/%E5%AD%97%E5%85%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h2 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h2><p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>字典中使用的哈希表节点和哈希表定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure></p><h3 id="字典-1"><a href="#字典-1" class="headerlink" title="字典"></a>字典</h3><p>Redis中的字典有dict.h/结构表示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="comment">// 目前正在运行的安全迭代器的数量</span></span><br><span class="line">    <span class="keyword">int</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure></p><p>type和privdata属性是针对不同类型的键值对，为创建多态字典而设置的：  </p><ol><li>type属性是指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。  </li><li>privdata属性则保存了需要传给那些特定函数的可选参数。  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="comment">// 计算哈希值的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line">    <span class="comment">// 复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 复制值的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="comment">// 对比键的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="comment">// 销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 销毁值的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure></li><li>属性是一个包含两个哈希表的数组，一般只是用第一个，第二个只会在对ht[0]rehash时使用。  <h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2></li></ol><p>Redis计算哈希值和索引的方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用字典设置的哈希函数，计算键key的hash值：</span><br><span class="line">hash &#x3D; dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"># 根据哈希表的sizemask计算出索引值：</span><br><span class="line">index &#x3D; hash &amp; dict-&gt;ht[x].sizemask;</span><br><span class="line"># 根据情况ht[x]可以是ht[0]或者ht[1]。</span><br></pre></td></tr></table></figure></p><p>Redis使用MurmurHash2算法来计算哈希值。  </p><h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><p>随着操作不断执行，哈希表保存的键值对会逐渐低增多或者减少，为了让哈希表的负载因子维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。<br>rehash的步骤：  </p><ol><li>为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量（ht[0].used的值）。  <ul><li>如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的$2^n$；  </li><li>如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的$2^n$；  </li></ul></li><li>将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是，重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。  </li><li>当ht[0]包含的所有键值对放置到ht[1]之后，释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次hash做准备。  </li></ol><h2 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h2><p>上一节说过，扩展或者收缩哈希表需要将ht[0]里面的所有键值对rehash到ht[1]里面。但是，这个rehash动作并不是一次性、集中式地完成的，而是分多次、渐进式地完成的。<br>以下是哈希表渐进式rehash的详细步骤：  </p><ol><li>为ht[1]分配空间，让字典同时持有有ht[0]和ht[1]两个哈希表。  </li><li>在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。  </li><li>在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值增一。  </li><li>随着字典操作的不断执行，最终在某个时间点上，将rehash键值对所需要的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量。  </li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> 数据结构与对象 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="2021/04/20/%E9%93%BE%E8%A1%A8/"/>
      <url>2021/04/20/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="链表和链表结点实现"><a href="#链表和链表结点实现" class="headerlink" title="链表和链表结点实现"></a>链表和链表结点实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line"></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><p>Redis的链表实现的特性可以总结如下：  </p><ol><li>双端：链表节点带有prev、next指针。  </li><li>无环：表头节点的prev指针和表尾节点的next指针都指向NULL。  </li><li>多态：链表节点使用void*指针来保存节点的值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> 数据结构与对象 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单动态字符串</title>
      <link href="2021/04/19/%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>2021/04/19/%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h1><h2 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h2><p>sdshr这个结构体定义在redis源码<code>src/sds.h</code>里面。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"><span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>len表示字符串长度，free表示已经分配的未使用空间，buf用来存储字符。  </p><h2 id="SDS与C字符串的区别"><a href="#SDS与C字符串的区别" class="headerlink" title="SDS与C字符串的区别"></a>SDS与C字符串的区别</h2><ol><li>常数级别获取字符串长度：由于提供了sdshdr字段。  </li><li>杜绝缓冲区溢出：C风格字符串使用strcat这类的函数有缓冲区溢出的风险，但是sdshdr可以检查free来判断是否有足够的空间。  </li><li>减少字符串修改时候带来的内存重写分配次数：空间预分配（每当SDS的API对一个SDS进行修改的时，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必要的空间，还会为SDS分配额外的未使用空间）、惰性空间释放（每当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存的重写分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用）。  </li><li>二进制安全：C字符串需要空字符来标识字符串末尾，这导致了C字符串不能用来存储包含会被误认为空字符的内容的数据类型，比如图片、音频，而SDS由于提供了len信息，其实并不需要空字符来做为结尾标识，以处理二进制数据的方式来处理数据，所以称为二进制安全。  </li><li>兼容部分wC字符串函数，虽然SDS是二进制安全的，但是它还是遵循了空字符串的惯例，将数据末尾保存为空字符，这使得它能够使用一部分的C字符串函数。  </li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> 数据结构与对象 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>初识Redis</title>
      <link href="2021/04/17/%E5%88%9D%E8%AF%86Redis/"/>
      <url>2021/04/17/%E5%88%9D%E8%AF%86Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="初认识Redis"><a href="#初认识Redis" class="headerlink" title="初认识Redis"></a>初认识Redis</h1><h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><h3 id="Redis与其他数据库和软件对比"><a href="#Redis与其他数据库和软件对比" class="headerlink" title="Redis与其他数据库和软件对比"></a>Redis与其他数据库和软件对比</h3><p>Redis属于人们常说的NoSQL数据库或者非关系型数据库。它常被拿来和memcached比较，这两者都可用于存储键值映射，彼此的性能相差无几，但是redis能够自动以不同的方式写入硬盘。并且Redis除了能存储普通字符串键之外，还可以存储其他4种数据结构。memcached只能存储普通的字符串键。<br>Redis存储的类型包括字符串、列表、集合、散列表、有序集合。<br>常见的非关系型数据库：Redis（存储在内存）、memcached（使用内存存储的键值缓存）、MongoDB（使用硬盘存储的非关系文档存储）。  </p><h3 id="附加特性"><a href="#附加特性" class="headerlink" title="附加特性"></a>附加特性</h3><p>Redis拥有两种不同形式的持久化方法，它们都可以用小而紧凑的格式将存储在内存中的数据写入硬盘：  </p><ol><li>时间点转储，转储操作即可以在“指定时间段内有指定数量的写执行操作”这一条件被满足时执行，又可以通过调用两条转储到硬盘命令中的任何一条来执行；  </li><li>将所有修改了数据库命令都写入一个只追加文件里面，用户可以根据数据的重要程度，将只追加写入设置为从不同步，每秒同步一次或者每写入一个命令就同步一次。  </li></ol><p>Redis提供故障转移支持，Redis实现了主从复制特效：只想复制的从服务器会连接上主服务器，接收主服务器发送来的整个数据库初始副本。之后主服务器执行的写命令，都会被发送给所有连接着的从服务器去执行，从而实时地更新从服务器的数据集。客户端可以向任意一个从服务器发送读请求，以此来避免对主服务器进行集中式的访问。  </p><h2 id="Redis数据结构简介"><a href="#Redis数据结构简介" class="headerlink" title="Redis数据结构简介"></a>Redis数据结构简介</h2><p>5种数据结构：  </p><ol><li>STRING：可以是字符串、整数或者浮点数。  </li><li>LIST：一个链表，链表上的每个节点都包含了一个字符串。  </li><li>SET：包含字符串的无序收集器，并且被包含的每个字符串都是独一无二、各不相同的。  </li><li>HASH：包含键值对的无序散列表。  </li><li>ZSET：字符串成员与浮点数分值之间的有序映射，元素的排列顺序由分支的大小决定。  </li></ol><h3 id="Redis中的字符串"><a href="#Redis中的字符串" class="headerlink" title="Redis中的字符串"></a>Redis中的字符串</h3><p>支持的命令：GET、SET、DEL</p><h3 id="Redis中的列表"><a href="#Redis中的列表" class="headerlink" title="Redis中的列表"></a>Redis中的列表</h3><p>命令：RPUSH、LRANGE（获取指定范围的所有值）、LINDEX（获取指定位置上的单个元素）、LPOP（从左端染出一个值，并返回这个值）。  </p><h3 id="Redis的集合"><a href="#Redis的集合" class="headerlink" title="Redis的集合"></a>Redis的集合</h3><p>命令：SADD（添加给定元素到集合）、SMEMBERS（返回集合所有元素）、SISMEMBER（检查给定元素是否存在于集合中）、SREM（从集合中移除给定元素）。  </p><h3 id="Redis的散列"><a href="#Redis的散列" class="headerlink" title="Redis的散列"></a>Redis的散列</h3><p>命令：HSET（关联起来给定的键值对）、HGET（获取指定散列键的值）、HGETALL（获取所有的键值对）、HDEL（删除指定的键）。  </p><h3 id="Redis的有序集合"><a href="#Redis的有序集合" class="headerlink" title="Redis的有序集合"></a>Redis的有序集合</h3><p>有序集合的键被称为成员，每个成员都是各不相同；而有序集合的值被称为分值，分值必须为浮点数。有序集合是Redis中唯一一个既可以根据成员访问元素又可以根据分值的排列顺序来访问元素的结构。  </p><p>命令：ZADD（将一个带有分值的成员添加到有序集合里面）、ZRANGE（根据元素在有序排列中所处的位置，从有序集合中获取多个元素）、ZRANGEBYSCORE（获取有序集合在给定分值范围内的所有元素）、ZREM（删除指定元素）。  </p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TinyWeb 服务器</title>
      <link href="2021/03/21/TINY%20Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>2021/03/21/TINY%20Web%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="TinyWeb-服务器"><a href="#TinyWeb-服务器" class="headerlink" title="TinyWeb 服务器"></a>TinyWeb 服务器</h1><p>我针对原来提供的代码，仔细阅读，附上注释版（每个函数的功能书中有阐释，就不细讲，可以结合着看）：</p><h2 id="main函数及其他函数定义"><a href="#main函数及其他函数定义" class="headerlink" title="main函数及其他函数定义"></a>main函数及其他函数定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个微型Web服务器，能够提供5种常见类型的静态内容：HTML文集爱你、无格式的&gt;文本文件、以及编码为GIF、PNG和JPG格式的图片</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数库csapp.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doit</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">// 这是函数负责处理HTTP事务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_requesthdrs</span><span class="params">(<span class="keyword">rio_t</span> *rp)</span></span>;</span><br><span class="line"><span class="comment">// 读取报头</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parse_uri</span><span class="params">(<span class="keyword">char</span>* uri,<span class="keyword">char</span> *filename,<span class="keyword">char</span> *cgiargs)</span></span>;</span><br><span class="line"><span class="comment">// 解析uri</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_static</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *filename,<span class="keyword">int</span> filesize)</span></span>;</span><br><span class="line"><span class="comment">// 静态内容服务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_filetype</span><span class="params">(<span class="keyword">char</span>* filename,<span class="keyword">char</span>* filetype)</span></span>;</span><br><span class="line"><span class="comment">// 获得文件类型，html、plain、jpg、png、gif</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_dynamic</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *filename, <span class="keyword">char</span> *cgiargs)</span></span>;</span><br><span class="line"><span class="comment">// 动态内容服务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clienterror</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *cause, <span class="keyword">char</span> *errnum, <span class="keyword">char</span> *shortmsg, <span class="keyword">char</span>* longmsg)</span></span>;</span><br><span class="line"><span class="comment">// 向客户端报错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd, port, clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">// argc==2表示输入为文件名 和 端口号</span></span><br><span class="line">        <span class="comment">// 调用方式为 &gt;./mytiny 1024</span></span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;usage: %s&lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    port = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);<span class="comment">//字符串转数字</span></span><br><span class="line">    listenfd = <span class="built_in">Open_listenfd</span>(port);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        clientlen = <span class="built_in"><span class="keyword">sizeof</span></span>(clientaddr); <span class="comment">//地址结构体的字节数</span></span><br><span class="line">        connfd = <span class="built_in">Accept</span>(listenfd,(SA*)&amp;clientaddr, &amp;clientlen); <span class="comment">//产生一个已连接</span></span><br><span class="line">套接字</span><br><span class="line">        <span class="built_in">doit</span>(connfd);<span class="comment">//执行http事务处理函数</span></span><br><span class="line">        <span class="built_in">Close</span>(connfd);<span class="comment">//关闭已连接套接字connfd-关闭连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="doit函数"><a href="#doit函数" class="headerlink" title="doit函数"></a>doit函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doit</span><span class="params">(<span class="keyword">int</span> fd)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 输入fd是一个已连接套接字描述符</span></span><br><span class="line">    <span class="keyword">int</span> is_static;</span><br><span class="line">    <span class="keyword">char</span> filename[MAXLINE],cgiargs[MAXLINE];</span><br><span class="line">    <span class="comment">// uri解析出来的路径和cgi参数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sbuf</span>;</span> <span class="comment">// stat结构体是用于存储文件信息的类型</span></span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];</span><br><span class="line">    <span class="comment">// buf-缓冲区，method-方法(比如GET)，uri-URI，version-http的版本</span></span><br><span class="line">    <span class="keyword">rio_t</span> rio;</span><br><span class="line">    <span class="built_in">Rio_readinitb</span>(&amp;rio, fd); <span class="comment">// 初始化创建一个空的读缓冲区并且和套接字描述符fd关</span></span><br><span class="line">联起来</span><br><span class="line">    <span class="built_in">Rio_readlineb</span>(&amp;rio, buf, MAXLINE); <span class="comment">//读取一行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Request headser\n:&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">    <span class="built_in">sscanf</span>(buf,<span class="string">&quot;%s %s %s&quot;</span>,method, uri,version);</span><br><span class="line">    <span class="comment">// 从缓冲区去读命令到变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcasecmp</span>(method,<span class="string">&quot;GET&quot;</span>))&#123;</span><br><span class="line">        <span class="comment">// 不想等返回非0值</span></span><br><span class="line">        <span class="comment">// 调用clienterror向客户端返回错误，不支持非GET方法</span></span><br><span class="line">        <span class="built_in">clienterror</span>(fd, method, <span class="string">&quot;501&quot;</span>, <span class="string">&quot;Not Implemented&quot;</span>, <span class="string">&quot;Tiny does not implement this method&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">read_requesthdrs</span>(&amp;rio); <span class="comment">//读取请求报文</span></span><br><span class="line"></span><br><span class="line">    is_static = <span class="built_in">parse_uri</span>(uri, filename, cgiargs);</span><br><span class="line">    <span class="comment">// 如果请求的是静态内容返回1，否则返回0</span></span><br><span class="line">    <span class="comment">// filename用来存储解析出来的路径</span></span><br><span class="line">    <span class="comment">//  cgiargs是一个可选的CGI参数字符串，如果是静态内容则清空</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">stat</span>(filename,&amp;sbuf)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 文件信息获取成功返回0，失败返回-1</span></span><br><span class="line">        <span class="built_in">clienterror</span>(fd, filename, <span class="string">&quot;404&quot;</span>, <span class="string">&quot;Not found&quot;</span>,<span class="string">&quot;Tiny couldn&#x27;t find this file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(is_static)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(<span class="built_in">S_ISREG</span>(sbuf.st_mode)) || !(S_IRUSR &amp; sbuf.st_mode))&#123;</span><br><span class="line">            <span class="comment">// st_mode：保护模式</span></span><br><span class="line">            <span class="comment">// S_ISREG(st_mode)用于判断是不是一个常规文件</span></span><br><span class="line">            <span class="comment">// S_IPUSR用户读权限</span></span><br><span class="line">            <span class="built_in">clienterror</span>(fd,filename, <span class="string">&quot;403&quot;</span>, <span class="string">&quot;Forbidden&quot;</span>, <span class="string">&quot;Tiny couldn&#x27;t read the file&quot;</span>);</span><br><span class="line">            <span class="comment">// 403：服务器无权访问所请求程序</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">serve_static</span>(fd, filename, sbuf.st_size);<span class="comment">//提供静态响应函数</span></span><br><span class="line">        <span class="comment">// st_size：文件大小</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(<span class="built_in">S_ISREG</span>(sbuf.st_mode)) || !(S_IXUSR &amp; sbuf.st_mode))&#123;</span><br><span class="line">            <span class="built_in">clienterror</span>(fd, filename, <span class="string">&quot;403&quot;</span>, <span class="string">&quot;Forbidden&quot;</span>, <span class="string">&quot;Tiny couldn&#x27;t read the file&quot;</span>);</span><br><span class="line">            <span class="comment">// 无权访问</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">serve_dynamic</span>(fd,filename,cgiargs); <span class="comment">//提供动态响应的函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="read-requesthdrs函数"><a href="#read-requesthdrs函数" class="headerlink" title="read_requesthdrs函数"></a>read_requesthdrs函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_requesthdrs</span><span class="params">(<span class="keyword">rio_t</span> *rp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">   <span class="built_in">Rio_readlineb</span>(rp,buf,MAXLINE);</span><br><span class="line">   <span class="keyword">while</span>(<span class="built_in">strcmp</span>(buf, <span class="string">&quot;\r\n&quot;</span>))&#123;</span><br><span class="line">        <span class="comment">//终止请求报头是\r\n组成的，相等返回0，否则返回非0</span></span><br><span class="line">        <span class="built_in">Rio_readlineb</span>(rp,buf,MAXLINE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="parse-uri函数"><a href="#parse-uri函数" class="headerlink" title="parse_uri函数"></a>parse_uri函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parse_uri</span><span class="params">(<span class="keyword">char</span> *uri,<span class="keyword">char</span> *filename, <span class="keyword">char</span> *cgiargs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strstr</span>(uri,<span class="string">&quot;cgi-bin&quot;</span>))&#123;</span><br><span class="line">        <span class="comment">// 没有匹配到则返回null</span></span><br><span class="line">        <span class="built_in">strcpy</span>(cgiargs, <span class="string">&quot;&quot;</span>); <span class="comment">//清空cgiargs</span></span><br><span class="line">        <span class="built_in">strcpy</span>(filename,<span class="string">&quot;.&quot;</span>); <span class="comment">// 变成相对路径</span></span><br><span class="line">        <span class="built_in">strcat</span>(filename,uri); <span class="comment">// 比如./intex.html</span></span><br><span class="line">        <span class="keyword">if</span>(uri[<span class="built_in">strlen</span>(uri)<span class="number">-1</span>]==<span class="string">&#x27;/&#x27;</span>)<span class="comment">//如果uri以/为结尾，则在路径末尾再添加home.html</span></span><br><span class="line">            <span class="built_in">strcat</span>(filename,<span class="string">&quot;home.html&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ptr = <span class="built_in">index</span>(uri,<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">        <span class="comment">// 索引到?，?之后是参数</span></span><br><span class="line">        <span class="keyword">if</span>(ptr)&#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(cgiargs,ptr+<span class="number">1</span>); <span class="comment">//将参数读入cgiargs</span></span><br><span class="line">            *ptr = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//避免把参数读入到filename</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(cgiargs,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcpy</span>(filename,<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(filename,uri);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="serve-static函数"><a href="#serve-static函数" class="headerlink" title="serve_static函数"></a>serve_static函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_static</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *filename, <span class="keyword">int</span> filesize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 提供5种常见类型的静态内容：HTML文件、无格式文本文件、编码为GIF、PNG、JPG&gt;格式的图片文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> srcfd;</span><br><span class="line">    <span class="keyword">char</span> *srcp, filetype[MAXLINE], buf[MAXBUF];</span><br><span class="line">    <span class="comment">// 发送响应到客户端</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">get_filetype</span>(filename, filetype); <span class="comment">//获得文件类型</span></span><br><span class="line">    <span class="comment">// 将HTTP报文写到buf缓存区</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>); <span class="comment">//初始状态行</span></span><br><span class="line">    <span class="comment">// 首部行</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%sServer: Tiny Web Server\r\n&quot;</span>,buf);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%sContent-length: %d\r\n&quot;</span>, buf, filesize); <span class="comment">//长度</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%sContent-type: %s\r\n\r\n&quot;</span>, buf, filetype); <span class="comment">//类型</span></span><br><span class="line">    <span class="built_in">Rio_writen</span>(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Response headers:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line"></span><br><span class="line">    srcfd = <span class="built_in">Open</span>(filename, O_RDONLY, <span class="number">0</span>);<span class="comment">//只读打开文件</span></span><br><span class="line">    srcp = <span class="built_in">Mmap</span>(<span class="number">0</span>, filesize, PROT_READ, MAP_PRIVATE, srcfd, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Mmap函数在csapp.h、csapp.c中定义、实现</span></span><br><span class="line">    <span class="comment">// 这只是mmap的一个包装函数</span></span><br><span class="line">    <span class="comment">// 功能是将分见映射到内存，用内存读写取代I/O读写</span></span><br><span class="line">    <span class="comment">// 第1个变量void* start，指向内存起始的位置，通常设为NULL(其实就是(void*)0)&gt;，代表让系统自动选定地址</span></span><br><span class="line">    <span class="comment">// 第2个变量size_t length，将文件多大部分映射到内存中</span></span><br><span class="line">    <span class="comment">// 第3个变量int prot，表示映射区域的保护方式，这里使用可读</span></span><br><span class="line">    <span class="comment">// 第4个变量int flags，表示影响映射区域的各种特性，MAX_PRIVATE是私人的写时复</span></span><br><span class="line">制</span><br><span class="line">    <span class="comment">// 第5个变量int fd，文件描述符</span></span><br><span class="line">    <span class="comment">// 第6个变量off_t offsize文件映射的偏移量，0表示从文件的最前方开始</span></span><br><span class="line">    <span class="comment">// 返回值为映射区的内存起始位置</span></span><br><span class="line">    <span class="built_in">Close</span>(srcfd); <span class="comment">//关闭打开文件</span></span><br><span class="line">    <span class="built_in">Rio_writen</span>(fd, srcp, filesize);</span><br><span class="line">    <span class="built_in">Munmap</span>(srcp, filesize);<span class="comment">//解除内存映射</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="get-filetype函数"><a href="#get-filetype函数" class="headerlink" title="get_filetype函数"></a>get_filetype函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_filetype</span><span class="params">(<span class="keyword">char</span> *filename, <span class="keyword">char</span> *filetype)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取文件类型</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strstr</span>(filename, <span class="string">&quot;.html&quot;</span>))<span class="built_in">strcpy</span>(filetype, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strstr</span>(filename, <span class="string">&quot;.gif&quot;</span>))<span class="built_in">strcpy</span>(filetype, <span class="string">&quot;image/gif&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strstr</span>(filename, <span class="string">&quot;.png&quot;</span>))<span class="built_in">strcpy</span>(filetype, <span class="string">&quot;image/png&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strstr</span>(filename, <span class="string">&quot;.jpg&quot;</span>))<span class="built_in">strcpy</span>(filetype, <span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">strcpy</span>(filetype, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="serve-dynamic函数"><a href="#serve-dynamic函数" class="headerlink" title="serve_dynamic函数"></a>serve_dynamic函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_dynamic</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *filename, <span class="keyword">char</span> *cgiargs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE], *emptylist[]=&#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="comment">// 响应报文</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">Rio_writen</span>(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Server: Tiny Wev Server\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">Rio_writen</span>(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Fork</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">setenv</span>(<span class="string">&quot;QUERY_STRING&quot;</span>, cgiargs, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//int setenv(const char *name,const char * value,int overwrite);</span></span><br><span class="line">        <span class="comment">//setenv()用来改变或增加环境变量的内容</span></span><br><span class="line">        <span class="comment">//参数name为环境变量名称字符串；value为变量内容，参数overwrite用来决定是否要改变已存在的环境变量。如果 overwrite不为0，而该环境变量原已有内容，则原内容&gt;会被改为参数value所指的变量内容。如果overwrite为0，且该环境变量已有内容，则参数value会被忽略。</span></span><br><span class="line">        <span class="comment">//执行成功返回0，否则-1</span></span><br><span class="line">        <span class="built_in">Dup2</span>(fd, STDOUT_FILENO);</span><br><span class="line">        <span class="comment">// Dup2是csapp对dup2的封装，原型dup2(int oldfd,int newfd)</span></span><br><span class="line">        <span class="comment">// 复制文件描述符oldfd，并且指定新的文件描述符数值为newfd</span></span><br><span class="line">        <span class="comment">// STDOUT_FILENO是linux提供的用于标准出入的文件描述符</span></span><br><span class="line">        <span class="built_in">Execve</span>(filename, emptylist, environ);</span><br><span class="line">        <span class="comment">// 对execve的包装，原型：execve(const char *filename, cahr *const argv[],char *const envp[]);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Wait</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="clienterror函数"><a href="#clienterror函数" class="headerlink" title="clienterror函数"></a>clienterror函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clienterror</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *cause, <span class="keyword">char</span> *errnum, <span class="keyword">char</span> *shortmsg, <span class="keyword">char</span> *longmsg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE], body[MAXBUF];</span><br><span class="line">    <span class="comment">// 直接复制了，懒得写</span></span><br><span class="line">    <span class="comment">/* Build the HTTP response body */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(body, <span class="string">&quot;&lt;html&gt;&lt;title&gt;Tiny Error&lt;/title&gt;&quot;</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(body, <span class="string">&quot;%s&lt;body bgcolor=&quot;</span><span class="string">&quot;ffffff&quot;</span><span class="string">&quot;&gt;\r\n&quot;</span>, body);</span><br><span class="line">    <span class="built_in">sprintf</span>(body, <span class="string">&quot;%s%s: %s\r\n&quot;</span>, body, errnum, shortmsg);</span><br><span class="line">    <span class="built_in">sprintf</span>(body, <span class="string">&quot;%s&lt;p&gt;%s: %s\r\n&quot;</span>, body, longmsg, cause);</span><br><span class="line">    <span class="built_in">sprintf</span>(body, <span class="string">&quot;%s&lt;hr&gt;&lt;em&gt;The Tiny Web server&lt;/em&gt;\r\n&quot;</span>, body);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Print the HTTP response */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 %s %s\r\n&quot;</span>, errnum, shortmsg);</span><br><span class="line">    <span class="built_in">Rio_writen</span>(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-type: text/html\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">Rio_writen</span>(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-length: %d\r\n\r\n&quot;</span>, (<span class="keyword">int</span>)<span class="built_in">strlen</span>(body));</span><br><span class="line">    <span class="built_in">Rio_writen</span>(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">Rio_writen</span>(fd, body, <span class="built_in">strlen</span>(body));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>首先创建一个目录：mytiny，然后在mytiny中创建一个文件mytiny.c，然后将csapp.h(在include中)、csappp.c(在src中)复制到此目录中。<br>首先<code>gcc -c csapp.c</code>获得csapp.o文件，然后<code>ar -rc csapp.a csapp.o</code>生成静态库文件。<br>生成可执行文件<code>gcc -o mytiny mytiny.c csapp.a</code>。<br>在mytiny中创建目录cgi-bin，将<code>netp/tiny/cgi-bin/adder.c</code>复制到此目录中，然后csapp.a、csapp.h也复制一份到其中。<br>然后运行命令<code>gcc -o adder adder.c csapp.a</code>生成可执行文件。<br>为了测试对图片的请求，我们添加文件test.jpg在mytiny中。<br>我们最终的目录结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mytiny&#x2F;</span><br><span class="line">    mytiny.c</span><br><span class="line">    csapp.h</span><br><span class="line">    csapp.c</span><br><span class="line">    csapp.o</span><br><span class="line">    csapp.a</span><br><span class="line">    mytiny.o</span><br><span class="line">    test.jpg</span><br><span class="line">    cgi-bin&#x2F;</span><br><span class="line">        adder.c</span><br><span class="line">        csapp.h</span><br><span class="line">        csapp.a</span><br><span class="line">        adder.o</span><br></pre></td></tr></table></figure><h3 id="telnet测试"><a href="#telnet测试" class="headerlink" title="telnet测试"></a>telnet测试</h3><p>首先：<code>linux&gt; ./mytiny 12000</code><br>首先使用TELNET测试，打开另一个shell，<code>linux&gt; telnet localhost 12000</code><br>然后输入HTTP请求行：<code>GET /cgi-bin/adder?100&amp;20 HTTP/1.0</code>。输完后需要先后回车两次。<br>然后我们可以看到HTTP响应。</p><h3 id="浏览器测试"><a href="#浏览器测试" class="headerlink" title="浏览器测试"></a>浏览器测试</h3><p>照样先运行服务器：<code>linux&gt; ./mytiny 12000</code>。<br>在浏览器中输入<code>http://localhost:12000/test.jpg</code>，然后我们可以看到图片。</p>]]></content>
      
      
      <categories>
          
          <category> 深入理解计算机系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ICMP</title>
      <link href="2021/03/19/ICMP/"/>
      <url>2021/03/19/ICMP/</url>
      
        <content type="html"><![CDATA[<h1 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h1><h2 id="ICMP定义和功能"><a href="#ICMP定义和功能" class="headerlink" title="ICMP定义和功能"></a>ICMP定义和功能</h2><p>ICMP是基于IP协议工作的，但是它并不是传输层的功能，因此仍然把它归结为网络层协议。它的功能是：  </p><ol><li>确认IP包是否成功到达目标地址；  </li><li>通知发送过程中IP包被丢弃的原因。  </li></ol><h2 id="ICMP报文格式"><a href="#ICMP报文格式" class="headerlink" title="ICMP报文格式"></a>ICMP报文格式</h2><p>0-7bytes：类型；<br>8-15bytes：代码；<br>15-31bytes：校验和。<br>剩下是内容。<br>不同类型的报文，内容不同。<br>有如下不同类型及含义：  </p><table>  <th>类型</th>  <th>内容</th>  <tr>  <td>0</td>  <td>回送应答</td>  <tr>  <td>3</td>  <td>目标不可达</td>  <tr>  <td>4</td>  <td>原点抑制</td>  <tr>  <td>5</td>  <td>重定向</td>  <tr>  <td>8</td>  <td>回送请求</td>  <tr>  <td>9</td>  <td>路由器公告</td>  <tr>  <td>10</td>  <td>路由器请求</td>  <tr>  <td>11</td>  <td>超时</td>  <tr>  <td>17</td>  <td>地址子网请求</td>  <tr>  <td>18</td>  <td>地址子网应答</td></table>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++11中的原子类</title>
      <link href="2021/03/18/C++11%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E7%B1%BB/"/>
      <url>2021/03/18/C++11%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>如果我们需要实现复杂的原子操作，通常需要利用互斥锁来构建临界区，保证操作的原子性。加锁和解锁有很大的开销。C++11中提供了内置的原子类，保证对这些类的操作都是原子的。我们以atomic_int64_t为例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">atomic_int64_t</span> atomic_total;</span><br><span class="line"><span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadFunc1</span><span class="params">(<span class="keyword">int64_t</span> endNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int64_t</span> i = <span class="number">1</span>; i &lt;= endNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        atomic_total += i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadFunc2</span><span class="params">(<span class="keyword">int64_t</span> endNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int64_t</span> i = <span class="number">1</span>; i &lt;= endNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        total += i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> endNum = <span class="number">100000</span>;</span><br><span class="line">    atomic_total = <span class="number">0</span>;</span><br><span class="line">    <span class="function">thread <span class="title">t11</span><span class="params">(threadFunc1, endNum)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t12</span><span class="params">(threadFunc1, endNum)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t21</span><span class="params">(threadFunc2, endNum)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t22</span><span class="params">(threadFunc2, endNum)</span></span>;</span><br><span class="line"></span><br><span class="line">    t11.<span class="built_in">join</span>();</span><br><span class="line">    t12.<span class="built_in">join</span>();</span><br><span class="line">    t21.<span class="built_in">join</span>();</span><br><span class="line">    t22.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;total=&quot;</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;atomic_total=&quot;</span> &lt;&lt; atomic_total &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果（total的值不稳定）：</span></span><br><span class="line">total=<span class="number">1193227575</span></span><br><span class="line">atomic_total=<span class="number">10000100000</span></span><br></pre></td></tr></table></figure><p>原子类型C++11中通过<code>atomic&lt;T&gt;</code>类模板来定义，比如<code>atomic_int64_t</code>是通过<code>typedef atomic&lt;int64_t&gt; atomic_int64_t</code>实现的，使用时需包含头文件<code>&lt;atomic&gt;</code>。除了提供<code>atomic_int64_t</code>，还提供了其它的原子类型。常见的原子类型有：<br>atomic_bool、atomic_char、atomic_uchar、atomic_short、atomic_ushort、atomic_int、atomic_uint、atomic_long、atomic_ulong、atomic_llong、atomic_ullong、atomic_ullong、atomic_char16_t、atomic_char32_t、char32_t、atomic_wchar_t。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>异常控制流</title>
      <link href="2021/03/18/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/"/>
      <url>2021/03/18/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="异常控制流"><a href="#异常控制流" class="headerlink" title="异常控制流"></a>异常控制流</h1><p>最近看中断、异常好像不同的地方的定义不太一样，这里总结一下，以免自己以后又忘记了。<br>首先我们根据CSAPP来定义，有4中不同的异常，分别是中断、陷阱、故障、终止。  </p><ol><li><strong>中断</strong><br>这里的中断我们可以称为硬中断，它是异步的，是来自处理器外部IO设备的信号导致的。硬件中断不是任何一条指令导致的，从这个意义上来说，它是异步的。中断一般由中断处理程序处理。<br>每当中断被激活时，都会跳转到中断向量表（由CPU定义），这中间保存了各种中断的中断处理函数的地址，然后找到对应的中断处理函数，进行处理。<br>注：这里的中断指的是硬中断，还有一种软中断，即由指令导致的中断，但是我们不将它归类为中断。  </li><li><strong>陷阱（系统调用）</strong><br>陷阱是有意的异常，提供了用户态到内核态之间的接口，叫做系统调用，通过syscall指令来实现。执行syscall会跳转到异常处理程序（陷阱处理程序），执行相关的系统调用，然后再将控制返回到调用处。<br>具体：根据系统调用号，从系统调用表中找到对应的系统调用函数，然后执行相应操作。  </li><li><strong>故障</strong><br>故障是由错误引起的，但是程序能够处理的一种异常。当发生故障时候，控制权通常交由故障处理程序，如果能够处理这个故障，执行完毕后控制权返回到触发故障的指令；如果不能修复这个故障，处理程序返回到内核的abort例程，abort例程会终止引起故障的程序。<br>缺页异常就是常见的故障。  </li><li><strong>终止</strong><br>终止是不可恢复的致命错误造成的结果，通常是一些硬件错误。  </li></ol><p>上述只有中断时异步的，其他都是同步的。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>零拷贝技术</title>
      <link href="2021/03/18/%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF/"/>
      <url>2021/03/18/%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p>服务端中通常需要传输文件，即将磁盘中的文件不做修改的通过socket发送出去。比如下面的代码：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((n=<span class="built_in">read</span>(disk_fd,buf,BUG_SIZE))&gt;<span class="number">0</span>)</span><br><span class="line"><span class="built_in">write</span>(sock_fd,buf,n);</span><br></pre></td></tr></table></figure><p>基本操作就是从磁盘循环读取字符到用户缓冲区buf，发送到Socket。但是由于Linux的I/O操作默认是缓冲I/O。这里面主要使用的也就是 Read 和 Write 两个系统调用，我们并不知道操作系统在其中做了什么。实际上在以上 I/O 操作中，发生了多次的数据拷贝。 当应用程序访问某块数据时，操作系统首先会检查，是不是最近访问过此文件，文件内容是否缓存在内核缓冲区。如果是，操作系统则直接根据 Read 系统调用提供的 buf 地址，将内核缓冲区的内容拷贝到 buf 所指定的用户空间缓冲区中去。 如果不是，操作系统则首先将磁盘上的数据拷贝的内核缓冲区，这一步目前主要依靠 DMA 来传输，然后再把内核缓冲区上的内容拷贝到用户缓冲区中。 接下来，Write 系统调用再把用户缓冲区的内容拷贝到网络堆栈相关的内核缓冲区中，最后 Socket 再把内核缓冲区的内容发送到网卡上。<br>这种数据拷贝方式总共需要拷贝4次，分别是:  </p><ol><li>磁盘拷贝进内核缓冲区（DMA copy）；  </li><li>内核缓冲区拷贝进用户缓冲区（read：CPU copy）；  </li><li>用户缓冲区拷贝进内核socket缓冲区（write：CPU copy）；  </li><li>socket内核缓冲区拷贝进网络（DMA copy）。  </li></ol><p>拷贝次数不但多，而且CPU负担重，故我们引入零拷贝技术来优化。零拷背用mmap+write的方式替代了read+write的方式。mmap的使用方式大致如下：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buf = <span class="built_in">mmap</span>(diskfd, len);</span><br><span class="line"><span class="built_in">write</span>(sockfd, buf, len);</span><br></pre></td></tr></table></figure><p>应用程序调用 mmap()，磁盘上的数据会通过 DMA 被拷贝的内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享，这样就不需要把内核缓冲区的内容往用户空间拷贝。 应用程序再调用 write()，操作系统直接将内核缓冲区的内容拷贝到 Socket 缓冲区中，这一切都发生在内核态，最后，Socket 缓冲区再把数据发到网卡去。<br>注：mmap想当于建立文件和虚拟内存的映射关系，使得能够像操作数组一样访问文件，但是调用mmap不会立刻将磁盘文件换入到物理内存而是设置了相应的访问标识，如果访问的话，会触发缺页异常，然后将文件换入到物理内存中。<br>零拷贝技术中总共发生了三次拷贝：<br>1.磁盘拷贝进内核缓冲区（DMA copy）；<br>2.内核缓冲区拷贝进socket缓冲区（CPU copy）；<br>3.socket缓冲区拷贝进网络（DMA copy）。  </p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>无锁同步</title>
      <link href="2021/03/17/%E6%97%A0%E9%94%81%E5%90%8C%E6%AD%A5/"/>
      <url>2021/03/17/%E6%97%A0%E9%94%81%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="无锁同步"><a href="#无锁同步" class="headerlink" title="无锁同步"></a>无锁同步</h1><h2 id="锁的代价"><a href="#锁的代价" class="headerlink" title="锁的代价"></a>锁的代价</h2><p>锁是用来实现并发最简单的方式，但是其代价也是最高的。内核态的锁的时候需要操作系统进行一次上下文切换，加锁、释放锁会导致比较多的上下文切换和调度延时，等待锁的线程会被挂起直至锁释放。在上下文切换的时候，cpu之前缓存的指令和数据都将失效，对性能有很大的损失。  </p><h2 id="CAS无锁算法"><a href="#CAS无锁算法" class="headerlink" title="CAS无锁算法"></a>CAS无锁算法</h2><p>要实现无锁的非阻塞算法有多种实现，其中CAS（比较与交换，Compare and swap）是一种有名的无锁算法。CAS, CPU指令，在大多数处理器架构，包括IA32、Space中采用的都是CAS指令，CAS的语义是“我认为V的值应该为A，如果是，那么将V的值更新为B，否则不修改并告诉V的值实际为多少”，CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。CAS无锁算法的C实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_and_swap</span> <span class="params">(<span class="keyword">int</span>* reg, <span class="keyword">int</span> oldval, <span class="keyword">int</span> newval)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">ATOMIC</span>();</span><br><span class="line">  <span class="keyword">int</span> old_reg_val = *reg;</span><br><span class="line">  <span class="keyword">if</span> (old_reg_val == oldval) </span><br><span class="line">     *reg = newval;</span><br><span class="line">  <span class="built_in">END_ATOMIC</span>();</span><br><span class="line">  <span class="keyword">return</span> old_reg_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是指当两者进行比较时，如果相等，则证明共享数据没有被修改，替换成新值，然后继续往下运行；如果不相等，说明共享数据已经被修改，放弃已经所做的操作，然后重新执行刚才的操作。容易看出 CAS 操作是基于共享数据不会被修改的假设，采用了类似于数据库的 commit-retry 的模式。当同步冲突出现的机会很少时，这种假设能带来较大的性能提升。<br>原子性加减通常是用CAS(Compare and Swap)完成的，与平台相关。CAS的基本形式是：CAS(addr,old,new),当addr中存放的值等于old时，用new对其替换。<br>C++中：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_exchange_weak</span> <span class="params">(T&amp; expected, T val,</span></span></span><br><span class="line"><span class="function"><span class="params">           memory_order sync = memory_order_seq_cst)</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_exchange_weak</span> <span class="params">(T&amp; expected, T val,</span></span></span><br><span class="line"><span class="function"><span class="params">           memory_order sync = memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_exchange_weak</span> <span class="params">(T&amp; expected, T val,</span></span></span><br><span class="line"><span class="function"><span class="params">           memory_order success, memory_order failure)</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_exchange_weak</span> <span class="params">(T&amp; expected, T val,</span></span></span><br><span class="line"><span class="function"><span class="params">           memory_order success, memory_order failure)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>当前值与期望值相等时，修改当前值为设定值，返回true，当前值与期望值不等时，将期望值修改为当前值，返回false。  我们可以用CAS算法来实现一个无锁链表。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>       <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span>         <span class="comment">// std::atomic</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span>         <span class="comment">// std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span>         <span class="comment">// std::vector</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a simple global linked list:</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span> <span class="keyword">int</span> value; Node* next; &#125;;</span><br><span class="line"><span class="function">std::atomic&lt;Node*&gt; <span class="title">list_head</span> <span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">append</span> <span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;     <span class="comment">// append an element to the list</span></span><br><span class="line">  Node* oldHead = list_head;</span><br><span class="line">  Node* newNode = <span class="keyword">new</span> Node &#123;val,oldHead&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果list_head还是oldHead，就更新位newNode，否则就返回false</span></span><br><span class="line">  <span class="keyword">while</span> (!list_head.<span class="built_in">compare_exchange_weak</span>(oldHead,newNode)) &#123;</span><br><span class="line">    newNode-&gt;next = oldHead;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CAS的开销"><a href="#CAS的开销" class="headerlink" title="CAS的开销"></a>CAS的开销</h3><p>CAS的开销相对锁来说小很多，但是具体细节涉及到很多计算机组成原理的知识，笔者还没学过计算机组成原理，等学一下再补上。可以参考<br><a href="https://www.cnblogs.com/Mainz/p/3546347.html">https://www.cnblogs.com/Mainz/p/3546347.html</a>  </p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ARP协议</title>
      <link href="2021/03/16/ARP%E5%8D%8F%E8%AE%AE/"/>
      <url>2021/03/16/ARP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h1><h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><p>并不是所有的主机或者路由器都有链路层地址，而是他们的适配器（网络接口）具有链路层地址，这个地址一般称为MAC地址。这个地址具有唯一性，通过IEEE分配其前24位保证。格式为：<br><code>8bit:8bit:8bit:8bit:8bit:8bit</code>共计48位。<br>链路层转发帧通过MAC地址来实现。  </p><h2 id="地址解析协议"><a href="#地址解析协议" class="headerlink" title="地址解析协议"></a>地址解析协议</h2><p>因为存在网络层地址（如IP）和链路层地址（MAC），所以需要在它们之间进行转换。对于因特网而言，这就是地址解析协议（ARP）。<br>和DNS协议不同，ARP协议只会在当前子网内解析MAC地址，如果试图解析其他子网的主机名，ARP协议会返回一个错误。<br>每台主机或者路由器在其内存中有一张ARP表，假设主机要发送一个数据报，发送主机需要获得目的主机IP地址对应的MAC地址，如果发送方的ARP表具有该目的主机的结点的表项，这个任务很容易完成。如果没有发送方会构造一个称为ARP分组的特殊分组，用广播地址作为目的地址，相当于去询问IP地址对应的MAC，每个适配器收到该帧会向上传递到ARP模块，如果自己有这个IP地址对应的MAC地址，就发送给源主机，然后源主机更新它的ARP表，并发送它的数据报。  </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Keep-Alive模式</title>
      <link href="2021/03/16/Keep-Alive%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/03/16/Keep-Alive%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Keep-Alive模式"><a href="#Keep-Alive模式" class="headerlink" title="Keep-Alive模式"></a>Keep-Alive模式</h1><p>非KeepAlive模式时，每个请求/应答客户和服务器都要新建一个连接，完成 之后立即断开连接（HTTP协议为无连接的协议）；当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服 务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>http 1.0中默认是关闭的，如果客户端浏览器支持Keep-Alive，那么就在HTTP请求头中添加一个字段 Connection: Keep-Alive，当服务器收到附带有Connection: Keep-Alive的请求时，它也会在响应头中添加一个同样的字段来使用Keep-Alive。这样一来，客户端和服务器之间的HTTP连接就会被保持，不会断开（超过Keep-Alive规定的时间，意外断电等情况除外），当客户端发送另外一个请求时，就使用这条已经建立的连接。  </p><p>http 1.1中默认启用Keep-Alive， 默认情况下所在HTTP1.1中所有连接都被保持，除非在请求头或响应头中指明要关闭：Connection: Close ，这也就是为什么Connection: Keep-Alive字段再没有意义的原因。另外，还添加了一个新的字段Keep-Alive:，因为这个字段并没有详细描述用来做什么，可忽略它。  </p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP通信的异常情况</title>
      <link href="2021/03/16/TCP%E9%80%9A%E4%BF%A1%E7%9A%84%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5/"/>
      <url>2021/03/16/TCP%E9%80%9A%E4%BF%A1%E7%9A%84%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP通信的异常情况"><a href="#TCP通信的异常情况" class="headerlink" title="TCP通信的异常情况"></a>TCP通信的异常情况</h1><h2 id="试图与一个不存在的端口建立连接"><a href="#试图与一个不存在的端口建立连接" class="headerlink" title="试图与一个不存在的端口建立连接"></a>试图与一个不存在的端口建立连接</h2><p>服务器端口还没有监听，我们的客户端就调用connect，视图与其建立连接。这时会发生什么呢？这符合触发RST分节的条件，目的为某端口的SYN分节到达，而端口没有监听，那么内核会立即响应一个RST，表示出错。客户端TCP收到这个RST之后则放弃这次连接的建立，并且返回给应用程序一个错误。正如上面所说，建立连接的过程对应用程序来说是不可见的，这是操作系统帮我们来完成的，所以即使进程没有启动，也可以响应客户端。  </p><h2 id="试图与一个不存在的主机上面的某个端口建立连接"><a href="#试图与一个不存在的主机上面的某个端口建立连接" class="headerlink" title="试图与一个不存在的主机上面的某个端口建立连接"></a>试图与一个不存在的主机上面的某个端口建立连接</h2><p>这也是一种比较常见的情况，当某台服务器主机宕机了，而客户端并不知道，仍然尝试去与其建立连接。这个时候由于宕机，操作系统帮不上忙，服务器处于一种完全没有响应的状态。那么此时客户端的TCP会怎么办呢？客户端不会收到任何响应，那么等待6s之后再发一个SYN，若无响应则等待24s之后再发一个，若总共等待了75s后仍未收到响应就会返回ETIMEDOUT错误。这是TCP建立连接自己的一个保护机制，但是我们要等待75s才能知道这个连接无法建立，对于我们所有服务来说都太长了。更好的做法是在代码中给connect设置一个超时时间。  </p><h2 id="Server进程被阻塞"><a href="#Server进程被阻塞" class="headerlink" title="Server进程被阻塞"></a>Server进程被阻塞</h2><p>由于某些情况，服务器端进程无法响应任何请求，比如所在主机的硬盘满了，导致进程处于完全阻塞，通常我们测试时会用gdb模拟这种情况。上面提到过，建立连接的过程对应用程序是不可见的，那么，这时连接可以正常建立。当然，客户端进程也可以通过这个连接给服务器端发送请求，服务器端TCP会应答ACK表示已经收到这个分节（这里的收到指的是数据已经在内核的缓冲区里准备好，由于进程被阻塞，无法将数据从内核的缓冲区复制到应用程序的缓冲区），但永远不会返回结果。  </p><h2 id="我们杀死了server"><a href="#我们杀死了server" class="headerlink" title="我们杀死了server"></a>我们杀死了server</h2><p>这是线上最常见的操作，当一个模块上线时，OP同学总是会先把旧的进程杀死，然后再启动新的进程。那么在这个过程中TCP连接发生了什么呢。在进程正常退出时会自动调用close函数来关闭它所打开的文件描述符，这相当于服务器端来主动关闭连接——会发送一个FIN分节给客户端TCP；客户端要做的就是配合对端关闭连接，TCP会自动响应一个ACK，然后再由客户端应用程序调用close函数，也就是我们上面所描述的关闭连接的4次挥手过程。接下来，客户端还需要定时去重连，以便当服务器端进程重新启动好时客户端能够继续与之通信。</p><h2 id="Server进程所在的主机宕机"><a href="#Server进程所在的主机宕机" class="headerlink" title="Server进程所在的主机宕机"></a>Server进程所在的主机宕机</h2><p>客户端向服务器端发送分节，由于服务器端宕机，不会有任何响应，客户端持续重传，然而服务器始终不能应答，重传数次之后，大约4~10分钟才停止，之后返回一个ETIMEDOUT错误。  </p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>lab2</title>
      <link href="2021/03/15/lab2/"/>
      <url>2021/03/15/lab2/</url>
      
        <content type="html"><![CDATA[<h1 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h1><h2 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h2><ol><li>本程序的编译使用哪个编译器？<br>本程序使用的编译器是<code>gcc</code>。  </li><li>采用哪个命令，可以将所有程序全部编译？<br>使用<code>make</code>或<code>make all</code>命令可以全部编译。  </li><li>采用哪个命令，可以将所有上次编译的结果全部删除？<br>使用<code>make clean</code>可以讲编译结果全部删除。  </li><li>文件中第几行生成 btest 的目标文件？<br>在文件的地10-11行：  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">btest: btest.c bits.c decl.c tests.c btest.h bits.h</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(LIBS)</span> -o btest bits.c btest.c decl.c tests.c</span><br></pre></td></tr></table></figure></li><li>文件中第几行生成 fshow 的目标文件？<br>在文件的第13-14行：  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">fshow: fshow.c</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o fshow fshow.c</span><br></pre></td></tr></table></figure></li><li>如果在 Makefile 文件中用要引用变量“FOO“， 怎么表示？<br>只需要<code>$(FOO)</code>即可。  </li></ol><h2 id="位级运算、数的编码"><a href="#位级运算、数的编码" class="headerlink" title="位级运算、数的编码"></a>位级运算、数的编码</h2><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wujiahao@ubuntu:~&#x2F;Desktop&#x2F;os&#x2F;lab2&#x2F;datalab$ .&#x2F;btest</span><br><span class="line">ScoreRatingErrorsFunction</span><br><span class="line"> 220allOddBits</span><br><span class="line"> 440isLessOrEqual</span><br><span class="line"> 440logicalNeg</span><br><span class="line"> 550floatScale2</span><br><span class="line"> 550floatFloat2Int</span><br><span class="line">Total points: 20&#x2F;20</span><br></pre></td></tr></table></figure><p>5个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allOddBits</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> num = <span class="number">0xAAAAAAAA</span>;</span><br><span class="line">   <span class="keyword">return</span> !((num &amp; x) ^ num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line">   <span class="keyword">int</span> b = y &gt;&gt; <span class="number">31</span>;</span><br><span class="line">   <span class="keyword">return</span> (!((!a) &amp; b)) &amp; ((a &amp; !b) | !((y + (~x + <span class="number">1</span>)) &amp; (<span class="number">1</span> &lt;&lt; <span class="number">31</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> ((~(~x + <span class="number">1</span>) &amp; ~x) &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatScale2</span><span class="params">(<span class="keyword">unsigned</span> uf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">unsigned</span> frac = uf &amp; <span class="number">0x007fffff</span>;</span><br><span class="line">   <span class="keyword">unsigned</span> exp = (uf &gt;&gt; <span class="number">23</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">   <span class="keyword">unsigned</span> s = uf &gt;&gt; <span class="number">31</span>;</span><br><span class="line">   <span class="keyword">if</span> (!exp)</span><br><span class="line">   &#123;</span><br><span class="line">      frac &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (frac &gt;&gt; <span class="number">23</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         frac = frac &amp; <span class="number">0x007fffff</span>;</span><br><span class="line">         exp++;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (exp != <span class="number">0xff</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      exp++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> (s &lt;&lt; <span class="number">31</span>) | (exp &lt;&lt; <span class="number">23</span>) | frac;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">floatFloat2Int</span><span class="params">(<span class="keyword">unsigned</span> uf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//unsigned frac = uf &amp; 0x007fffff;</span></span><br><span class="line">   <span class="keyword">int</span> frac = (uf &amp; <span class="number">0x007fffff</span>) | <span class="number">0x00800000</span>;</span><br><span class="line">   <span class="keyword">int</span> exp = ((uf &gt;&gt; <span class="number">23</span>) &amp; <span class="number">0xff</span>) - <span class="number">127</span>;</span><br><span class="line">   <span class="keyword">int</span> s = uf &gt;&gt; <span class="number">31</span>;</span><br><span class="line">   <span class="keyword">int</span> tar = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span> (s)</span><br><span class="line">      s = <span class="number">-1</span>;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      s = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (exp &gt; <span class="number">31</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0x80000000</span>;</span><br><span class="line">   <span class="keyword">if</span> (exp &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span> (exp &gt; <span class="number">23</span>)</span><br><span class="line">      tar = s * (frac &lt;&lt; (exp - <span class="number">23</span>));</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (exp &lt; <span class="number">23</span>)</span><br><span class="line">      tar = s * (frac &gt;&gt; (<span class="number">23</span> - exp));</span><br><span class="line">   <span class="keyword">return</span> tar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> 操作系统课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关系型数据库设计</title>
      <link href="2021/03/14/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
      <url>2021/03/14/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h1><h2 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h2><p>1NF的定义为：符合1NF的关系中的每个属性都不可再分。表1所示的情况，就不符合1NF的要求。<br>1NF是所有关系型数据库的最基本要求，你在关系型数据库管理系统（RDBMS），例如SQL Server，Oracle，MySQL中创建数据表的时候，如果数据表的设计不符合这个最基本的要求，那么操作一定是不能成功的。也就是说，只要在RDBMS中已经存在的数据表，一定是符合1NF的。  </p><h2 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h2><p>第二范式（2NF）在1NF的基础之上，消除了非主属性对于码的部分函数依赖。其定义是不存在非主属性对码存在部分函数依赖关系。  </p><h2 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h2><p>第三范式（3NF）在3NF的基础上，消除了非主属性对码的传递函数依赖。其定义是不存在非主属性对码存在传递函数依赖关系。  </p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库设计和E-R模型</title>
      <link href="2021/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%92%8CE-R%E6%A8%A1%E5%9E%8B/"/>
      <url>2021/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%92%8CE-R%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><h2 id="映射基数"><a href="#映射基数" class="headerlink" title="映射基数"></a>映射基数</h2><p>对于实体集A和B之间的二元关系集R来说，映射基数必然是以下情况之一：  </p><ol><li>一对一（one-to-one）。A中的一个实体至多与B中的一个实体相关联，并且B中的一个实体也至多与A中的一个实体相关联。  </li><li>一对多（one-to-many）。A中的一个实体可以与B中的任意数目实体相关联，而B中的一个实体至多与A中的一个实体相关联。  </li><li>多对一（many-to-one）。A中的一个实体至多与B中的一个实体相关联，而B中的一个实体可以与A中任意数目实体相关联。  </li><li>多对多（many-to-many）。A中的一个实体可以与B中的任意数目实体相关联，而且B中的一个实体也可以与A中的任意数目实体相关联。  </li></ol><h2 id="参与约束"><a href="#参与约束" class="headerlink" title="参与约束"></a>参与约束</h2><p>如果实体集E中的每个实体都参与到联系集R中的至少一个联系中，实体集在联系集R中的参与称为全部（total）的。如果E中只有部分实体参与到R的联系中，实体集到联系集R的参与称为部分的。  </p><h2 id="码"><a href="#码" class="headerlink" title="码"></a>码</h2><p>实体的码是一个足以区分每个实体的属性集合。  </p><p><strong>超码</strong>：一个或多个属性的集合，这些属性的组合可以使我们在一个关系中唯一地标识一个元组。<br><strong>候选码</strong>：超码可能会有冗余属性，我们称满足任意任意真子集不能称为超码的超码为候选码。  </p><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>POD数据类型</title>
      <link href="2021/03/13/MOD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>2021/03/13/MOD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="POS数据类型"><a href="#POS数据类型" class="headerlink" title="POS数据类型"></a>POS数据类型</h1><p>阅读《STL源码剖析》的时候出现了POD数据类型一词，看到的时候非常迷惑，查询了不少资料后大致理解了，这里总结一下。  </p><p>POD全称Plain Old Data。字面意思，普通的，旧的数据类型。通俗的讲，一个类或结构体通过二进制拷贝后还能保持其数据不变，那么它就是一个POD类型。</p><h2 id="trival（平凡的）"><a href="#trival（平凡的）" class="headerlink" title="trival（平凡的）"></a>trival（平凡的）</h2><p>trivial类型支持静态初始化。如果一个类型是拷贝不变的（trivially copyable），使用memcpy这种方式把它的数据从一个地方拷贝出来会得到相同的结果。<br>C++标准把trivial（平凡的）类型定义如下：  </p><ol><li>平凡的复制构造函数  </li><li>平凡的转移构造函数  </li><li>平凡的赋值操作符  </li><li>平凡的转移赋值操作符  </li><li>平凡的析构函数  </li><li>没有虚函数和虚基类。  </li></ol><p>如何判断一个类是不是trival的呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::is_trivial&lt;T&gt;::value</span><br><span class="line"><span class="comment">// 上述值为true则表示类型T是trival的</span></span><br></pre></td></tr></table></figure><h2 id="standard-layout-标准布局"><a href="#standard-layout-标准布局" class="headerlink" title="standard-layout(标准布局)"></a>standard-layout(标准布局)</h2><p>C++标准中的是这样定义的：</p><ol><li>所有的非静态数据成员都符合标准布局或是引用的  </li><li>没有虚函数和虚基类  </li><li>非静态数据成员的访问控制必须是相同的  </li><li>基类都符合标准布局  </li><li>在派生类中没有非静态数据成员，且在基类中最多有一个基类拥有非静态数据成员，也就是说在整个的继承关系中，最多有1个基类有非静态数据成员（含0个）并且子类不能有非静态数据成员  </li><li>相同基类类型的非静态数据成员不能作为第一个成员，也就是说在子类中的第一个非静态数据成员不能是父类。  </li></ol><p>判断方式如下：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::is_standard_layout&lt;B_1&gt;::value</span><br><span class="line"><span class="comment">// 类似</span></span><br></pre></td></tr></table></figure><h2 id="POD"><a href="#POD" class="headerlink" title="POD"></a>POD</h2><p>当一个数据类型满足了trival(平凡)和 standard_layout(标准布局)，我们则认为它是一个POD数据。可以通过std::is_pod来判断一个类型是否为POD类型：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::is_pod&lt;T&gt;:value</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL标准库与泛型编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>空间配置器</title>
      <link href="2021/03/12/%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/"/>
      <url>2021/03/12/%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="空间配置器"><a href="#空间配置器" class="headerlink" title="空间配置器"></a>空间配置器</h1><h2 id="设计一个简单的空间配置器"><a href="#设计一个简单的空间配置器" class="headerlink" title="设计一个简单的空间配置器"></a>设计一个简单的空间配置器</h2><p>函数<code>set_new_handler()</code>可以设置内存分配失败的回调函数，方式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new_handler example</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span>      <span class="comment">// std::exit</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span>          <span class="comment">// std::set_new_handler</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">no_memory</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Failed to allocate memory!\n&quot;</span>;</span><br><span class="line">  std::<span class="built_in">exit</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  std::<span class="built_in">set_new_handler</span>(no_memory);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Attempting to allocate 1 GiB...&quot;</span>;</span><br><span class="line">  <span class="keyword">char</span>* p = <span class="keyword">new</span> <span class="keyword">char</span> [<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Ok\n&quot;</span>;</span><br><span class="line">  <span class="keyword">delete</span>[] p;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意如果不设置或者这样<code>set_new_handler(0)</code>则将调用默认的处理函数，该函数在内存分配失败时抛出bad_alloc异常。  </p><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>C++中new操作符通常完成两个工作，分配内存及其调用相应的构造函数初始化，那么如何让new操作符不分配内存，只调用构造函数呢？<br>可以如下使用：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">some_type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> memory[<span class="built_in"><span class="keyword">sizeof</span></span>(some_type)];</span><br><span class="line">   <span class="keyword">void</span>* place = memory;</span><br><span class="line">   some_type* place = memory;</span><br><span class="line">   some_type *ptr = <span class="built_in"><span class="keyword">new</span></span>(place) <span class="built_in">some_type</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个称为<code>placement new</code>，作用就是创建对象但是不分配内存，而是在以有的内存块上面创建对象。</p><h2 id="一级配置器和二级配置器"><a href="#一级配置器和二级配置器" class="headerlink" title="一级配置器和二级配置器"></a>一级配置器和二级配置器</h2><h2 id="一级配置器"><a href="#一级配置器" class="headerlink" title="一级配置器"></a>一级配置器</h2><h2 id="二级配置器"><a href="#二级配置器" class="headerlink" title="二级配置器"></a>二级配置器</h2><p>二级配置器多了一些机制来避免太多小额区块造成的内存碎片。小额区块带来的其实不仅仅是内存碎片，配置时的额外负担也是一个大问题。额外的复旦永远无法避免，毕竟系统要靠这多出来的空间来管理内存。<br>SGI第二级配置器的做法是，如果区块够大，超过128bytes时，就移交第一级配置器处理。当区块小于128bytes时，则以内存池管理，此法又称为次层配置：每次配置一大块内存，并维护对应的自由链表（free-list）。下次若再有相同大小的内存需求，直接从free-list中拔出。如果客端释还小额区块，就由配置器回收到free-list中。为了方便管理，SGI会主动将内存需求量上调至8的倍数，大小分别为8，16，24，32，40，48，56，64，72，80，88，96，104，112，120，128bytes。<br><strong>free-list</strong>的结点结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">obj</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">obj</span> * <span class="title">free_list_link</span>;</span></span><br><span class="line"><span class="keyword">char</span> client_data[<span class="number">1</span>]; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述写法主要是为了节省空间，由于union之故，从第一字段观之，obj可被视为一个指针，指向相同形式的另一个obj，第二个字段obj可被视为一个指针，指向实际区块。<br>有几个关键函数要注意：  </p><ol><li><code>allocate()</code>：用于从free-list中取走区块；  </li><li><code>deallocate()</code>：释放区块回到free-list；  </li><li><code>refill()</code>：重新填充区块，前面的allocate()如果没有可用区块时会调用此函数，从内存池中获取内存，不但返回区块而且分配区块给free-list；  </li><li><code>chunk_alloc</code>：从内存池中获取内存。  </li></ol><h2 id="内存基本处理工具"><a href="#内存基本处理工具" class="headerlink" title="内存基本处理工具"></a>内存基本处理工具</h2><p>uninita<br>除了用于构造的<code>construct()</code>和用于析构的<code>destroy()</code>外，还有<code>uninitialized_copy</code>、<code>uninitialized_fill()</code>、<code>uninitialized_fill_n()</code>。<br>主要功能是序列化配置已经分配但是尚未初始化的内存。</p><h3 id="uninitialized-copy"><a href="#uninitialized-copy" class="headerlink" title="uninitialized_copy"></a>uninitialized_copy</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line">ForwardIterator</span><br><span class="line"><span class="built_in">uninitialized_copy</span>(InputIterator first, InputIterator last, ForwardIterator result);</span><br></pre></td></tr></table></figure><p>该函数用于使我们能够将内存的配置与对象的构造行为分离开来。如果作为输出目的地的[result,result+(last-first))范围内的每一个迭代器都指向未初始化区域，则uninitialized_copy()会使用copy constructor，给身为输入来源之[first,last)范围内的每一个对象产生一个迭代器i，该函数会调用construct(&amp;*(result+(i-first)),*i)，产生*i的复制品，放置于输出范围的相对位置上。  </p><h3 id="uninitialized-fill"><a href="#uninitialized-fill" class="headerlink" title="uninitialized_fill"></a>uninitialized_fill</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uninitialized_fill</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="keyword">const</span> T&amp; x)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数能够使我们将内存配置与对象的构造行为分离开来。如果[first, last)范围内的每个迭代器都指向未初始化的内存，那么<code>uninitialized_fill()</code>会在该范围内产生x的复制品。  </p><h3 id="uninitialized-fill-n"><a href="#uninitialized-fill-n" class="headerlink" title="uninitialized_fill_n"></a>uninitialized_fill_n</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">ForwardIterator</span><br><span class="line"><span class="built_in">uninitialized_fill_n</span>(ForwardIterator first, Size n, <span class="keyword">const</span> T&amp; x);</span><br></pre></td></tr></table></figure><p>如果[first,first+n)范围内的每一个迭代器都指向未初始化的内存，那么uninitialized_fill_n()会调用copy constructor，在该范围内产生x（上式第三参数）的复制品。  </p><h3 id="“commit-or-rollback”"><a href="#“commit-or-rollback”" class="headerlink" title="“commit or rollback”"></a>“commit or rollback”</h3><p>上述三个函数都具有“commit or rollback”的语义。要么产生所有必要的元素，要么不产生任何元素。如果任何一个copy construct丢出异常，必须析构已经产生的所有元素。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL标准库与泛型编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>迭代器概念与traits编程技法</title>
      <link href="2021/03/12/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A6%82%E5%BF%B5%E4%B8%8Etraits%E7%BC%96%E7%A8%8B%E6%8A%80%E6%B3%95/"/>
      <url>2021/03/12/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A6%82%E5%BF%B5%E4%B8%8Etraits%E7%BC%96%E7%A8%8B%E6%8A%80%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="迭代器（iterators）概念与traits编程技法"><a href="#迭代器（iterators）概念与traits编程技法" class="headerlink" title="迭代器（iterators）概念与traits编程技法"></a>迭代器（iterators）概念与traits编程技法</h1><h2 id="迭代器设计思维-STL关键所在"><a href="#迭代器设计思维-STL关键所在" class="headerlink" title="迭代器设计思维-STL关键所在"></a>迭代器设计思维-STL关键所在</h2><p>STL的中心思想是讲数据容器（containers）和算法（algorithms）分开，最后再以一贴胶着剂将它们撮合在一起。前两者可以通过C++的class templates和function templates来实现，后者如何实现呢。</p><h2 id="迭代器（iterators）是一种smart-pointer"><a href="#迭代器（iterators）是一种smart-pointer" class="headerlink" title="迭代器（iterators）是一种smart pointer"></a>迭代器（iterators）是一种smart pointer</h2><h2 id="迭代器相应型别"><a href="#迭代器相应型别" class="headerlink" title="迭代器相应型别"></a>迭代器相应型别</h2><p>可以利用function template来做类型推导：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_impl</span><span class="params">(I iter, T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T tmp;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(I iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">func_impl</span>(iter, *iter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="built_in">func</span>(&amp;i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Traits编程技法-STL源码门钥"><a href="#Traits编程技法-STL源码门钥" class="headerlink" title="Traits编程技法-STL源码门钥"></a>Traits编程技法-STL源码门钥</h2><p>返回值类型如何推导呢？可以使用内嵌类型：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyIter</span>&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line">   T* ptr;</span><br><span class="line">   <span class="built_in">MyIter</span>(T* p=<span class="number">0</span>):<span class="built_in">ptr</span>(p)&#123;&#125;</span><br><span class="line">   T&amp; <span class="keyword">operator</span>*()<span class="keyword">const</span>&#123;<span class="keyword">return</span> *ptr;&#125;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> I::value_type</span><br><span class="line"><span class="built_in">func</span>(I ite)</span><br><span class="line">&#123;<span class="keyword">return</span> *ite;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function">MyIter&lt;<span class="keyword">int</span>&gt; <span class="title">ite</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">8</span>))</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">func</span>(ite);<span class="comment">//输出：8</span></span><br></pre></td></tr></table></figure><p><code>typename</code>可以告诉编译器返回值是一个类型。但是这里有个问题，并不是所有的迭代器都是class type，原生指针就不是。  </p><p>下面这个<code>class template</code>专门用于“萃取”迭代器的特性，而value_type正是迭代器的特性之一：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们就可以通过如下方式萃取出I中的value_type了:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;I&gt;::value</span><br><span class="line"><span class="built_in">func</span>(I ite)</span><br><span class="line">&#123;<span class="keyword">return</span> *ite;;&#125;</span><br></pre></td></tr></table></figure><p>还可以萃取原生指针中的value_type：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;</span>T*&gt;&#123;</span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据经验，最常用到的迭代器相应类型有五种：<code>value type</code>,<code>difference type</code>,<code>pointer</code>,<code>reference</code>,<code>iterator catagoly</code>。  为了与STL能够水乳交融，一定要定义如下萃取机：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tempalte&lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category    iterator_category;</span><br><span class="line">   <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type    value_type;</span><br><span class="line">   <span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type   difference_type;</span><br><span class="line">   <span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer   pointer;</span><br><span class="line">   <span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference     reference</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL标准库与泛型编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多进程和多线程</title>
      <link href="2021/03/11/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>2021/03/11/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="多进程和多线程分析"><a href="#多进程和多线程分析" class="headerlink" title="多进程和多线程分析"></a>多进程和多线程分析</h1><p>最近面试的时候常常被问一个问题，多进程好还是多线程好？具体的使用场景是什么？笔者在这方面的知识储备不多也不够系统，所以在这里总结一下：  </p><h2 id="多进程和多线程特性"><a href="#多进程和多线程特性" class="headerlink" title="多进程和多线程特性"></a>多进程和多线程特性</h2><table>  <tr>  <th>属性</th>  <th>多进程</th>  <th>多线程</th>  <th>总结</th>  <tr>  <td>数据同步</td>  <td>数据共享复杂，需要使用IPC；数据是分开的，同步简单</td>  <td>因为共享进程的内存，数据共享简单，但是同步复杂</td>  <td>各有优势</td>  <tr>  <td>内存、CPU</td>  <td>占用内存多，切换复杂，CPU利用率低</td>  <td>占用内存少，切换简单，CPU利用率高</td>  <td>线程占优</td>  <tr>  <td>创建销毁、切换</td>  <td>创建、销毁、切换复杂，速度慢</td>  <td>创建销毁、切换简单，速度很快</td>  <td>线程占优</td>  <tr>  <td>编程、调试</td>  <td>编程简单、调试简单</td>  <td>编程复杂、调试复杂</td>  <td>进程占优</td>  <tr>  <td>可靠性</td>  <td>进程之间不会相互影响</td>  <td>一个线程挂掉将导致整个进程挂掉</td>  <td>进程占优</td>  <tr>  <td>分布式</td>  <td>适应于多核、多机分布式系统，扩展机器比较简单</td>  <td>适应于多核分布式</td>  <td>进程占优</td></table><h2 id="不同场景下的选择"><a href="#不同场景下的选择" class="headerlink" title="不同场景下的选择"></a>不同场景下的选择</h2><ol><li>需要频繁创建销毁的优先用线程：<br>这种情况最常见的就是Web服务器了，来了一个连接建立一个线程，断了就销毁线程，要是用进程，创建和销毁的代价是很难承受的。  </li><li>需要进行大量计算的优先使用线程：<br>大量计算即CPU开销比较大，切换频繁了，这种情况下线程最合适。  </li><li>强相关的处理用线程，弱相关的处理用进程：<br>首先什么叫强相关，什么叫弱相关？举个例子，一般的server需要完成如下任务：消息收发、消息处理。这就叫弱相关的任务。而“消息处理”里面可能又分为“消息解码”、“业务处理”，这两个任务相对来说相关性就要强多了。因此“消息收发”和“消息处理”可以分进程设计，“消息解码”、“业务处理”可以分线程设计。  </li><li>可能要扩展到多机分布的用进程，多核分布的用线程  </li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB体系结构</title>
      <link href="2021/03/07/InnoDB%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>2021/03/07/InnoDB%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="InnoDB体系结构"><a href="#InnoDB体系结构" class="headerlink" title="InnoDB体系结构"></a>InnoDB体系结构</h1><ol><li>后台线程；  </li><li>InnoDB存储引擎内存池（所有进程、线程需要访问的多个内部数据结构；缓存磁盘上的数据，方便快速读取；重做日志缓冲）。  </li></ol><p>后台线程的主要作用是刷新内存池种的数据，保证缓存池中的内存缓存的时最近的数据。此外将已修复的数据文件刷新到磁盘文件，同时保证在数据库发生异常的情况下InnoDB能恢复到正常运行状态。  </p><h2 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h2><ol><li>Master Thread<br>这是一个非常核心的后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新，合并插入缓冲等。  </li><li>IO Thread<br>在InnoDB存储引擎中大量使用了AIO（Async IO）来处理写IO请求，这样可以极大提高数据库性能。而IO Thread的工作主要是负责这些IO请求的回调处理。  </li><li>Purge Thread<br>事务被提交后，其所使用的undolog可能不再需要，因此需要PurgeThread来回收已经使用并分配的undo页。  </li><li>Page Cleaner Thread<br>将之前版本中脏页的刷新操作都放入到单独的线程中来完成。  </li></ol><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><ol><li>缓冲池<br>缓冲池使用来减少磁盘IO的消耗而存在的，对于数据库中的页的修改操作，则首先修改在缓冲池中页，然后再以一定的频率刷新到磁盘。<br>具体来看缓存池中缓存了数据页、索引页、插入缓存、undo页、自适应哈希索引、InnoDB存储的锁消息、数据字典信息等。  </li><li>LRU List、Free List和Flush List<br>缓存池是通过LRU算法管理的。LRU列表中的页被修改后，称该页为脏页（dirty page）。而Flush列表中的页即为脏页列表。  </li><li>重做日志缓冲<br>InnoDB存储引擎首先将重做日志信息放入到这个混缓冲区，然后按一定频率将其刷新到重做日志文件。重做日志缓冲一般不需要设置得很大，因为一般情况下每一秒会将重做日志缓冲刷新到日志文件，因此用户只要保证每秒产生得事务量在这个缓冲大小之内即可。  </li><li>额外的内存池  </li></ol><h1 id="Master-Thread工作方式"><a href="#Master-Thread工作方式" class="headerlink" title="Master Thread工作方式"></a>Master Thread工作方式</h1><p>Master Thread具有最高界别的线程优先级。其内部由多个循环组成：主循环（loop）、后台循环（background loop）、刷新循环（flush loop）、暂停循环。Master Thread会根据数据库运行状态在多个循环中切换。  </p><h1 id="InnoDB关键特性"><a href="#InnoDB关键特性" class="headerlink" title="InnoDB关键特性"></a>InnoDB关键特性</h1><p>InnoDB存储引擎的关键特性包括：  </p><ol><li>插入缓存；  </li><li>两次写；  </li><li>自适应哈希索引；  </li><li>异步IO；  </li><li>刷新邻接页。  </li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL体系结构和存储引擎</title>
      <link href="2021/03/07/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
      <url>2021/03/07/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h1><p>首先我们需要理解一点，MySQL既是数据库也是数据库实例，前者强调数据库是很多文件的集合，后者指的是一个程序，是位于用户和操作系统之间的一层数据库管理软件，用户对数据库的任何操作，包括数据库定义、数据查询、数据维护、数据库运行控制等都是在数据库实例下进行。  </p><p>MySQL由以下部分组成：  </p><ol><li>连接池组件；  </li><li>管理服务和工具组件；  </li><li>SQL接口组件；  </li><li>查询和分析器组件；  </li><li>优化器组件；  </li><li>缓冲（Cache）组件；  </li><li>插件式存储引擎；  </li><li>物理文件。  </li></ol><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h2><p>InnoDB存储引擎支持事务，其设计目标主要是面向在线事务处理的应用，其特点是行锁设计、支持外键。<br>InnoDB存储引擎讲数据放在一个逻辑的表空间种，这个表空间就像黑盒一样由InnoDB自身进行管理。<br>InnoDB通过使用MVCC（多版本并发控制）来获得高并发性。并实现了SQL标准的4种隔离级别，默认为可重复读（REPEATABLE）级别。<br>对于表中数据的存储，InnoDB采用了聚集（clustered）的方式，按照主键的顺序存放。</p><h2 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h2><p>MyISAM存储引擎不支持事务、表锁设计，支持全文索引。MyISAM一个与众不同的地方是它的缓冲池只缓存（cache）索引文件，而不缓冲数据文件。<br>MyISAM存储引擎表由MYD和MYI组成，MYD用来存放数据文件，MYI用来存放索引文件。</p><h2 id="Memory存储引擎"><a href="#Memory存储引擎" class="headerlink" title="Memory存储引擎"></a>Memory存储引擎</h2><p>Memory存储引擎将表中的数据存放在内存种，如果数据库重启或发生崩溃，表中的数据都将消失。它非常适合用于存储临时数据的临时表。Memory存储引擎默认使用哈希索引，而不是我们熟知的B+树。<br>由于数据全部存放在内存种，所以Memory速度非常快，但是在使用上还是有一定的限制。比如，只支持表锁，并发性能较差，并且不支持TEXT和BLOB列类型。最重要的是，存储变长字段（varchar）是按照定常字段的方式进行的，会浪费内存。<br>MySQL使用Memory存储引擎作为临时表存放查询的中间结果集。但是如果这个规模超过了Memory的最大容量，泽会把其转换为MyISAM存储引擎表而存放在磁盘中，这会损失查询性能。  </p><h1 id="连接MySQL"><a href="#连接MySQL" class="headerlink" title="连接MySQL"></a>连接MySQL</h1><p>连接MySQL操作时一个连接进程和MySQL数据库实例进行通信。从程序设计的角度看，本质上时进程通信。所以通信方式也有TCP/IP、命名管道、共享内存、UNIX域套接字的办法。  </p>]]></content>
      
      
      <categories>
          
          <category> MySQL学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>lab1</title>
      <link href="2021/03/06/lab1/"/>
      <url>2021/03/06/lab1/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab1实验报告"><a href="#Lab1实验报告" class="headerlink" title="Lab1实验报告"></a>Lab1实验报告</h1><h2 id="练习1-gcc"><a href="#练习1-gcc" class="headerlink" title="练习1 gcc"></a>练习1 gcc</h2><ol><li>编译<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o glory glory.c</span><br><span class="line">&#x2F;&#x2F; gcc表示使用C编译器（c++是g++），-o参数表示生成可执行文件为glory，glory.c是原文件</span><br></pre></td></tr></table></figure></li><li>运行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;glory</span><br><span class="line">&#x2F;&#x2F; 运行可执行文件file就是：.&#x2F;file</span><br></pre></td></tr></table></figure></li><li>修改glory.c宏定义如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> V0 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> V1 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> V2 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> V3 1</span></span><br></pre></td></tr></table></figure>重新编译并允许结果如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  SJTU labstarter:</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Happy Happy Happy </span><br><span class="line">FPX</span><br><span class="line"></span><br><span class="line">Guo Li!</span><br></pre></td></tr></table></figure></li></ol><h2 id="练习2-GDB"><a href="#练习2-GDB" class="headerlink" title="练习2 GDB"></a>练习2 GDB</h2><ol><li>How do you pass command line arguments to a program when using gdb?<br>修改hello.c的主函数如下：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">if</span>(argc&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,argv[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> *str =<span class="string">&quot;hello, world!&quot;</span>, ch;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); i++)</span><br><span class="line">                ch = str[i];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>编译并调试如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -g -o hello hello.c</span><br><span class="line">$ gdb hello</span><br><span class="line">...</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: &#x2F;home&#x2F;wujiahao&#x2F;Desktop&#x2F;os&#x2F;lab1&#x2F;hello </span><br><span class="line">hello, world!</span><br><span class="line">[Inferior 1 (process 6122) exited normally]</span><br><span class="line">(gdb) run arg_test</span><br><span class="line">Starting program: &#x2F;home&#x2F;wujiahao&#x2F;Desktop&#x2F;os&#x2F;lab1&#x2F;hello arg_test</span><br><span class="line">arg_test</span><br><span class="line">hello, world!</span><br><span class="line">[Inferior 1 (process 6128) exited normally]</span><br></pre></td></tr></table></figure><code>run</code>直接允许程序，由于没有命令行参数所以直接输出了<code>hello,wolrd!</code>。在run后面添加参数可以直接输出结果，比如<code>run arg_test</code>结果多输出了一行<code>arg_test</code>。  </li><li>How do you set a breakpoint which only occurs when a set of conditions is true (e.g. when certain variables are a certain value)?<br>想设置一个条件断点，可以利用break if命令，如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break line-or-function if expr</span><br></pre></td></tr></table></figure>例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break 46 if testsize&#x3D;&#x3D;100</span><br></pre></td></tr></table></figure>我面这样修改hello.c文件：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">char</span> test_num=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(argc&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            test_num=argv[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> *str =<span class="string">&quot;hello, world!&quot;</span>, ch;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); i++)</span><br><span class="line">                ch = str[i];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break 18 if test_num!&#x3D;&#39;\0&#39;</span><br><span class="line">Breakpoint 1 at 0x4005cc: file hello.c, line 18.</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: &#x2F;home&#x2F;wujiahao&#x2F;Desktop&#x2F;os&#x2F;lab1&#x2F;hello </span><br><span class="line">hello, world!</span><br><span class="line">[Inferior 1 (process 6217) exited normally]</span><br><span class="line">(gdb) run 1</span><br><span class="line">Starting program: &#x2F;home&#x2F;wujiahao&#x2F;Desktop&#x2F;os&#x2F;lab1&#x2F;hello 1</span><br><span class="line">Breakpoint 1, main (argc&#x3D;2, argv&#x3D;0x7fffffffde08) at hello.c:18</span><br><span class="line">18printf(&quot;%s\n&quot;,str);</span><br></pre></td></tr></table></figure></li></ol><p>我们在18行设置一个条件断点，中断条件为字符变量test_num非’\0’空字符，我们可以通过命令行参数修改这个字符来触发中断。可以发现当时有命令行参数1的情况下，这个程序会中断在18行（就是<code>printf</code>这行），不会输出<code>hello,world!</code>。<br>3. How do you execute the next line of C code in the program after stopping at a breakpoint?<br>使用命令<code>continue</code>可以接着执行程序直到终止或者再次遇到断点，命令<code>step</code>可以运行下一行代码。<br>4. If the next line of code is a function call, you’ll execute the whole function call at once if you use your answer to #3. How do you tell GDB that you want to debug the code inside the function instead?<br><code>step</code>可以只执行下一行代码，不会调用整个函数，也可以通过<code>break [file:]function</code>在函数中设置断点。<br>5. How do you resume the program after stopping at a breakpoint?<br>运行<code>continue</code>即可恢复程序执行。<br>6. How can you see the value of a variable (or even an expression like 1+2) in gdb?<br><code>print</code>可以查看变量，比如对程序hello调用<code>print str</code>：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break 18</span><br><span class="line">Breakpoint 1 at 0x4005cc: file hello.c, line 18.</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: &#x2F;home&#x2F;wujiahao&#x2F;Desktop&#x2F;os&#x2F;lab1&#x2F;hello </span><br><span class="line"></span><br><span class="line">Breakpoint 1, main (argc&#x3D;1, argv&#x3D;0x7fffffffde08) at hello.c:18</span><br><span class="line">18printf(&quot;%s\n&quot;,str);</span><br><span class="line">(gdb) print str</span><br><span class="line">$1 &#x3D; 0x400674 &quot;hello, world!&quot;</span><br><span class="line">(gdb) print 1+2</span><br><span class="line">$2 &#x3D; 3</span><br></pre></td></tr></table></figure><p>输出了字符指针str的值，以及指向字符串的值。<br>7. How do you configure gdb so it prints the value of a variable after every step?<br>通过<code>display</code>命令可以在程序中断时候自动显示变量的值，比如<code>display ch</code>可以自动显示字符变量ch的值。<br>8. How do you print a list of all variables and their values in the current function?<br><code>bt</code>可以显示程序堆栈信息，然后<code>bt full</code>可以查看当前函数的所有变量。<br>9.  How do you exit out of gdb?<br><code>quit</code>可以退出gdb调试。  </p><h2 id="练习3-调试"><a href="#练习3-调试" class="headerlink" title="练习3 调试"></a>练习3 调试</h2><p>编译并执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -g -o ll_equal ll_equal.c</span><br><span class="line">$ .&#x2F;ll_equal</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">equal test 1 result &#x3D; 1</span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure><p>然后我们开始调试</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="keyword">break</span> <span class="number">10</span></span><br><span class="line">Breakpoint <span class="number">2</span> at <span class="number">0x4005a2</span>: file ll_equal.c, line <span class="number">10.</span></span><br><span class="line">(gdb) <span class="keyword">continue</span></span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">2</span>, <span class="built_in">ll_equal</span> (a=<span class="number">0x7fffffffdc70</span>, b=<span class="number">0x7fffffffdc70</span>) at ll_equal.c:<span class="number">10</span></span><br><span class="line"><span class="number">10</span><span class="keyword">while</span> (a != <span class="literal">NULL</span>) &#123;</span><br><span class="line">(gdb) <span class="keyword">continue</span></span><br><span class="line">Continuing.</span><br><span class="line">equal test <span class="number">1</span> result = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">2</span>, <span class="built_in">ll_equal</span> (a=<span class="number">0x7fffffffdc70</span>, b=<span class="number">0x7fffffffdc90</span>) at ll_equal.c:<span class="number">10</span></span><br><span class="line"><span class="number">10</span><span class="keyword">while</span> (a != <span class="literal">NULL</span>) &#123;</span><br><span class="line">(gdb) <span class="keyword">continue</span></span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line"><span class="number">0x00000000004005ae</span> in <span class="built_in">ll_equal</span> (a=<span class="number">0x7fffffffdc90</span>, b=<span class="number">0x0</span>) at ll_equal.c:<span class="number">11</span></span><br><span class="line"><span class="number">11</span><span class="keyword">if</span> (a-&gt;val != b-&gt;val)</span><br></pre></td></tr></table></figure><p>最后发现在11行出现错误，b的值为<code>0x0</code>，不能对空指针取调用<code>-&gt;</code>运算符。修改ll_equal.c如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; node;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* <span class="doctag">FIXME:</span> this function is buggy. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ll_equal</span><span class="params">(<span class="keyword">const</span> node* a, <span class="keyword">const</span> node* b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (a != <span class="literal">NULL</span>&amp;&amp;b != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a-&gt;val != b-&gt;val)</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                a = a-&gt;next;</span><br><span class="line">                b = b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* lists are equal if a and b are both null */</span></span><br><span class="line">        <span class="keyword">return</span> a == b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        node nodes[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">                nodes[i].val = <span class="number">0</span>;</span><br><span class="line">                nodes[i].next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nodes[<span class="number">0</span>].next = &amp;nodes[<span class="number">1</span>];</span><br><span class="line">        nodes[<span class="number">1</span>].next = &amp;nodes[<span class="number">2</span>];</span><br><span class="line">        nodes[<span class="number">2</span>].next = &amp;nodes[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;equal test 1 result = %d\n&quot;</span>, <span class="built_in">ll_equal</span>(&amp;nodes[<span class="number">0</span>], &amp;nodes[<span class="number">0</span>]));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;equal test 2 result = %d\n&quot;</span>, <span class="built_in">ll_equal</span>(&amp;nodes[<span class="number">0</span>], &amp;nodes[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新编译运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">equal test 1 result &#x3D; 1</span><br><span class="line">equal test 2 result &#x3D; 0</span><br></pre></td></tr></table></figure><h2 id="练习4-Make初步"><a href="#练习4-Make初步" class="headerlink" title="练习4 Make初步"></a>练习4 Make初步</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wujiahao@ubuntu:~&#x2F;Desktop&#x2F;os&#x2F;lab1$ make wc</span><br><span class="line">cc     wc.c   -o wc</span><br><span class="line">wujiahao@ubuntu:~&#x2F;Desktop&#x2F;os&#x2F;lab1$ .&#x2F;wc wc.c</span><br><span class="line">wujiahao@ubuntu:~&#x2F;Desktop&#x2F;os&#x2F;lab1$ wc wc.c</span><br><span class="line">  9  23 145 wc.c</span><br><span class="line">wujiahao@ubuntu:~&#x2F;Desktop&#x2F;os&#x2F;lab1$ which wc</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;wc</span><br></pre></td></tr></table></figure><p>前一次是调用我们生成的可执行文件wc，源文件wc.c的文件名作为参数。后者是调用系统的命令wc，参数是wc.c，这个wc是系统自己的可执行文件，位于/usr/bin/wc。</p><p>修改代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wc</span><span class="params">(FILE *ofile, FILE *infile)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch, pre_ch=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> lines=<span class="number">0</span>,words=<span class="number">0</span>,chars=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">fgetc</span>(infile))!=EOF)&#123;</span><br><span class="line">        ++chars;</span><br><span class="line">        <span class="keyword">if</span>(ch!=<span class="string">&#x27; &#x27;</span>&amp;&amp;ch!=<span class="string">&#x27;\n&#x27;</span>&amp;&amp;ch!=<span class="string">&#x27;\t&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre_ch==<span class="string">&#x27; &#x27;</span>||pre_ch==<span class="string">&#x27;\0&#x27;</span>||pre_ch==<span class="string">&#x27;\t&#x27;</span>||pre_ch==<span class="string">&#x27;\n&#x27;</span>)++words;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">&#x27;\n&#x27;</span>)++lines;</span><br><span class="line">        pre_ch=ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(ofile,<span class="string">&quot;\t%d\t%d\t%d\n&quot;</span>,lines,words,chars);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* filename;</span><br><span class="line">    FILE *infile=stdin;</span><br><span class="line">    <span class="keyword">if</span>(argc&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        filename=argv[<span class="number">1</span>];</span><br><span class="line">        infile=<span class="built_in">fopen</span>(filename,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">wc</span>(stdout,infile);</span><br><span class="line">    <span class="built_in">fclose</span>(infile);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">wujiahao@ubuntu:~&#x2F;Desktop&#x2F;os&#x2F;lab1$ .&#x2F;wc wc.c</span><br><span class="line">2949616</span><br><span class="line">wujiahao@ubuntu:~&#x2F;Desktop&#x2F;os&#x2F;lab1$ wc wc.c</span><br><span class="line"> 29  49 616 wc.c</span><br><span class="line">wujiahao@ubuntu:~&#x2F;Desktop&#x2F;os&#x2F;lab1$ wc</span><br><span class="line">123123 123123</span><br><span class="line">1231</span><br><span class="line">123</span><br><span class="line">123123 123123 123123</span><br><span class="line">123 1231 </span><br><span class="line">      5       9      53</span><br><span class="line">wujiahao@ubuntu:~&#x2F;Desktop&#x2F;os&#x2F;lab1$ .&#x2F;wc</span><br><span class="line">123123 123123</span><br><span class="line">1231</span><br><span class="line">123</span><br><span class="line">123123 123123 123123</span><br><span class="line">123 1231</span><br><span class="line">5953</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> 操作系统课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络中的安全</title>
      <link href="2021/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8/"/>
      <url>2021/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是网络安全"><a href="#什么是网络安全" class="headerlink" title="什么是网络安全"></a>什么是网络安全</h1><p>安全通信的特性：  </p><ol><li>机密性；  </li><li>报文完整性；  </li><li>端点鉴别；  </li><li>运行安全性。  </li></ol><h1 id="密码学的原则"><a href="#密码学的原则" class="headerlink" title="密码学的原则"></a>密码学的原则</h1><h2 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h2><p>用字母表后的第k个字母替代当前字母。但是如果知道是凯撒密码之后，很容易破解，因为可能性只有25种。另一种方法是单码代替密码，用字母表中的一个字母题代另一个，保证一一对应，这有26!种可能。但是这些方法都可以通过统计词频来判断。  </p><h2 id="多玛代替密码"><a href="#多玛代替密码" class="headerlink" title="多玛代替密码"></a>多玛代替密码</h2><p>可以用多玛代替密码的方式来解决上述问题，即每个字母对应关系都是k偏移的，但是我们使用多个不同的k值进些加密，比如C1代表k=3，C2代表k=5，用这两种方法加密，然后以C1、C2的某种排列对每个字母加密，然后只要保留这个排列即可知道加密、解密方式。  </p><h2 id="块密码"><a href="#块密码" class="headerlink" title="块密码"></a>块密码</h2><p>上述都是古代的加密方式，我们回到现代社会，考察对称加密技术有两种宽泛的类型，流密码和块密码。块密码用在多种因特网协议的加密种，包括PCG（用于安全电子邮件）、SSL（用于使TCP连接更安全）、IPsec（用于使网络层传输更安全）。<br>在块密码中，要加密的的报文被处理为k比特的块，每个块采取一一映射，将k比特的明文映射为k比特的密文。但是如果这个k比较小，则能够蛮力破解所有可能。但是如果k比较大，需要维护的这张密码表非非常庞大。<br>取而代之的是，块密码通常使用函数模拟随机排列表。</p><h2 id="密码块链接"><a href="#密码块链接" class="headerlink" title="密码块链接"></a>密码块链接</h2><p>由于同样的明文必然对应的相同的密文，而有些内容是重复出现的，比如”HTTP/1.1”这些，攻击者看到重复的密码块，参考报文的结构，它可能猜出其明文。所以我们需要在其中添加某些随机性。我们将具有密钥S的块密码加密算法称为KS。我们每次为第i个明文块Mi随机生成一个r(i)，并且计算第i个密码块Ci=KS(Mi^r(i))。这样子接收方可以先通过密钥还原出随机化后的明文块和随机数，然后再利用随机块还原明文。  </p><h2 id="公开密钥加密"><a href="#公开密钥加密" class="headerlink" title="公开密钥加密"></a>公开密钥加密</h2><p>加密通信需要通信双方共享一个秘密。</p><h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><p>RSA加密过程：  </p><ol><li>找到两个大素数p和q；  </li><li>计算n=pq，z=(p-1)(q-1)；  </li><li>选择小于n的一个数e使得e、z互素；  </li><li>求一个数d，使得ed-1可以被z整除。  </li><li>Bob使外界可用的公钥KB+是一对数（n,e），其私钥KB-是一对数（n,d）。</li><li>对一个由整数m表示的比特组合（待加密字符串），且满足m&lt;n，计算加密值c=(m^e)%n；  </li><li>收到对应密文报文c解密，m=(c^d)%n。</li></ol><h2 id="会话密钥"><a href="#会话密钥" class="headerlink" title="会话密钥"></a>会话密钥</h2><p>由于RSA中的指数运算相当耗时，所以实际应用中，我们常常会把RSA和对称密钥结合起来使用。首先选择一方选择一个会话密钥，然后使用对方的RSA公钥要加密该会话密钥，然后将会话密钥的密文发送过去，对方接收到以后就能够使用会话密钥来通信了。</p><h1 id="报文完整性和数字签名"><a href="#报文完整性和数字签名" class="headerlink" title="报文完整性和数字签名"></a>报文完整性和数字签名</h1><p>假定Bob接收到一个报文，并且他认为这个报文时由Alice发送的。为了鉴别这个报文，Bob需要证实：<br>1）该报文的确源自Alice。<br>2）该报文在到Bob的途中没有被篡改。  </p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++中不同类型的char</title>
      <link href="2021/03/01/C++%E4%B8%AD%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84char/"/>
      <url>2021/03/01/C++%E4%B8%AD%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84char/</url>
      
        <content type="html"><![CDATA[<p>C++中提供了四种不同的char类型，分别是char、wchar_t、char16_t、char32_t。我们主要来看下他们的不同。</p><h1 id="占用空间不同"><a href="#占用空间不同" class="headerlink" title="占用空间不同"></a>占用空间不同</h1><p>运行如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of char is &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of wchar_t is &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">wchar_t</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of char16_t is &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char16_t</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of char32_t is &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char32_t</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果如下：</span></span><br><span class="line">size of <span class="keyword">char</span> is <span class="number">1</span></span><br><span class="line">size of <span class="keyword">wchar_t</span> is <span class="number">2</span></span><br><span class="line">size of <span class="keyword">char16_t</span> is <span class="number">2</span></span><br><span class="line">size of <span class="keyword">char32_t</span> is <span class="number">4</span></span><br></pre></td></tr></table></figure><p>我们可以知道char、wchar_t、char16_t、char32_t分别是1、2、2、4个字节。  </p><h1 id="char和wchar-t"><a href="#char和wchar-t" class="headerlink" title="char和wchar_t"></a>char和wchar_t</h1><p>char是C和C++中的原始字符类型。<br>wchar_t是定义和实现的宽字符类型。<br>Char16_t和char32_t类型分别表示16位和32位宽字符；</p><p>char和wchar_t分别是ANSI和Unicode编码方式，即ANSI中的字符采用8bit，而UNICODE中的字符采用16bit。（对于字符来说ANSI以单字节存放英文字符，以双字节存放中文等字符,而Unicode下，英文和中文的字符都以双字节存放）Unicode码也是一种国际标准编码，采用二个字节编码，与ANSI码不兼容。目前，在网络、Windows系统和很多大型软件中得到应用。8bit的ANSI编码只能表示256种字符，表示26个英文字母是绰绰有余的，但是表示汉字，韩国语等有着成千上万个字符的非西方字符肯定就不够了，正是如此才引入了UNICODE标准。  </p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>容器之分类</title>
      <link href="2021/02/28/%E5%AE%B9%E5%99%A8%E4%B9%8B%E5%88%86%E7%B1%BB%E4%B8%8E%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95/"/>
      <url>2021/02/28/%E5%AE%B9%E5%99%A8%E4%B9%8B%E5%88%86%E7%B1%BB%E4%B8%8E%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>容器分类介绍：</p><h1 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h1><h2 id="数组：array"><a href="#数组：array" class="headerlink" title="数组：array"></a>数组：<code>array</code></h2><h2 id="向量：vector"><a href="#向量：vector" class="headerlink" title="向量：vector"></a>向量：<code>vector</code></h2><h2 id="双向队列：Deque"><a href="#双向队列：Deque" class="headerlink" title="双向队列：Deque"></a>双向队列：<code>Deque</code></h2><h2 id="链表：list"><a href="#链表：list" class="headerlink" title="链表：list"></a>链表：<code>list</code></h2><p>双向环状链表。</p><h2 id="Forward-List"><a href="#Forward-List" class="headerlink" title="Forward-List"></a>Forward-List</h2><p>这是C++11新增的，是单向链表。</p><h1 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h1><h2 id="集合：set-multiset"><a href="#集合：set-multiset" class="headerlink" title="集合：set/multiset"></a>集合：<code>set/multiset</code></h2><p>红黑树实现。<code>set/multiset</code>只保存key。mutiset和set的区别就是前者可以重复，后者不能重复。  </p><h2 id="查找表：map-multimap"><a href="#查找表：map-multimap" class="headerlink" title="查找表：map/multimap"></a>查找表：<code>map/multimap</code></h2><p>红黑树实现。<code>map/multimap</code>保存<code>&lt;key,value&gt;</code>，通过key进行检索，multiset和set的区别在于key是否可以重复。  </p><h1 id="无序容器-Unordered-Containers"><a href="#无序容器-Unordered-Containers" class="headerlink" title="无序容器,Unordered Containers"></a>无序容器,Unordered Containers</h1><h2 id="哈希表：HashTable"><a href="#哈希表：HashTable" class="headerlink" title="哈希表：HashTable"></a>哈希表：HashTable</h2><p>哈希表就是通过hash函数来计算一个哈希值来确定数据放入的位置和查找的位置。理论上我们希望可以通过计算hash值直接找到每个元素的位置，但实际上会有hash冲突，即不同的key有相同的hash值，所以hash表的关键就是如何解决hash冲突，常见的方法有线性探测、二次探测、开链。一般用开链法。  </p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL标准库与泛型编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>STL六大部件</title>
      <link href="2021/02/28/STL%E5%85%AD%E5%A4%A7%E9%83%A8%E4%BB%B6/"/>
      <url>2021/02/28/STL%E5%85%AD%E5%A4%A7%E9%83%A8%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>STL有六大部件（Components）：  </p><ul><li>容器（Containers）  </li><li>分配器（Allocators）  </li><li>算法（Algorithms）  </li><li>迭代器（Iterators）  </li><li>适配器（Adapters）  </li><li>仿函数（Functors）</li></ul><p><strong>前闭后开区间</strong>：<br>标准库规定所有容器都提供<code>begin()</code>、<code>end()</code>两个迭代器，前一个指向第一个元素，后一个指向最后一个元素的下一个位置。  </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++STL标准库与泛型编程</title>
      <link href="2021/02/28/C++STL%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
      <url>2021/02/28/C++STL%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>使用一个东西却不明白它的道理，不高明！<br>本章是学习侯捷《C++标准库与泛型编程》的第一课笔记。学习目标分为4各层次：  </p><ul><li>level 0：使用C++标准库  </li><li>level 1：认识C++标准库（胸中自有丘壑）  </li><li>level 2：<strong>良好</strong>使用C++标准库  </li><li>level 3：扩充C++标准库  </li></ul><h1 id="标准库和标准模板库"><a href="#标准库和标准模板库" class="headerlink" title="标准库和标准模板库"></a>标准库和标准模板库</h1><p>C++标准库（C++ Standard Library）和标准模板库（Standard Template Library，STL）。<br>前者是后者的超集，STL占C++标准库80-90%的内容。  </p><p>标准库以<strong>header files</strong>形式呈现：<br>C++标准库的header files不带副名称(.h)，例如<code>#include&lt;vector&gt;</code>。  </p><h1 id="有用的网站和网站"><a href="#有用的网站和网站" class="headerlink" title="有用的网站和网站"></a>有用的网站和网站</h1><p><a href="cplusplus.com">cplusplus.com</a><br><a href="cppreference.com">cppreference.com</a><br><a href="gcc.gnu.org">gcc.gnu.org</a>  </p><p>《THE C++ STANDARD LIBRARY》和《STL源码剖析》。  </p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL标准库与泛型编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL引擎</title>
      <link href="2021/02/26/MySQL%E5%BC%95%E6%93%8E/"/>
      <url>2021/02/26/MySQL%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<p>MySQL存储引擎有InnoDB、MyISAM、MEMORY。</p><h1 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h1><p>InnoDB是事务型数据库的首选引擎，支持事务安全（ACID），支持行锁定和外键，InnoDB是MySQL默认的引擎。<br>主要特性：</p><ol><li>InnoDB提供了具有提交、回滚和崩溃恢复的事务安全存储引擎。  </li><li>InnoDB存储引擎在主内存中缓存数据和索引而维持它的缓冲池。它表和索引放在一个逻辑表空间中，而MyISAM表中每个表被存放在分离的文件中。  </li><li>InnoDB支持外键完整性约束。  </li></ol><h1 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h1><p>MyISAM基于ISAM，是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM拥有较高的插入、查询，但不支持事务。<br>主要特性：  </p><ol><li>查询、插入效率高；  </li><li>可以把数据文件和索引文件放在不同的目录中；  </li><li>对事务的支持不好。  </li></ol><h1 id="MEMORY"><a href="#MEMORY" class="headerlink" title="MEMORY"></a>MEMORY</h1><p>MEMORY存储引擎将表中的数据存储到内存中，为查询和引用其他表数据提供快速访问。  </p>]]></content>
      
      
      <categories>
          
          <category> MySQL学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>右值引用和移动语义</title>
      <link href="2021/02/25/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/"/>
      <url>2021/02/25/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h1 id="右值是啥"><a href="#右值是啥" class="headerlink" title="右值是啥"></a>右值是啥</h1><p>右值是区别与左值的存在，一般来说，表达式右边就是右值，左边就是左值，当然这是开玩笑的。最好的区分方式就是，左值可以取地址，而右值不可以。比方说：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">1</span>;</span><br><span class="line"><span class="comment">// x是左值，1是右值</span></span><br><span class="line">y=x;</span><br><span class="line"><span class="comment">// y、x都是左值</span></span><br><span class="line">z=x+y;</span><br><span class="line"><span class="comment">// z是左值，x+y是右值</span></span><br></pre></td></tr></table></figure><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>原来C++有左值引用，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iny y=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;x=y;</span><br></pre></td></tr></table></figure><p>也就是说，引用只能引用左值，但是C++11提供了右值引用，使用&amp;&amp;来表示，右值引用可以关联到右值，但是不能对其应用地址运算符。右值包括字面常量，诸如x+y等表达式以及函数的返回值（前提是返回不能是引用）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> y=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;z=x;<span class="comment">//非法</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;&amp;z=x;<span class="comment">//非法</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;r1=<span class="number">13</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;r2=x+y;</span><br><span class="line"><span class="keyword">double</span> &amp;&amp;r3=std::<span class="built_in">sqrt</span>(<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value:&quot;</span> &lt;&lt; r1 &lt;&lt; <span class="string">&quot; address:&quot;</span> &lt;&lt; &amp;r1 &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h1 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h1><p>在某些场景下，使用一个对象初始化另一个对象，可以通过复制构造函数进行深拷贝完成，但是有时候用于的旧对象不再使用，可以通过移动构造函数提高效率。移动构造函数只调整记录，是将所有权转移到新对象的过程，这个过程中可能修改其实参，这意味着右值引用参数不应是const。通俗的将就类似于在计算机中移动文件的情形：实际文件还留在原来的地方，而只是修改了记录，这就是移动语义。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Useless</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">   <span class="keyword">char</span> *p;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span> ct;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">showobject</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Useless</span>();</span><br><span class="line">   <span class="function"><span class="keyword">explicit</span> <span class="title">Useless</span><span class="params">(<span class="keyword">int</span> k)</span></span>;</span><br><span class="line">   <span class="built_in">Useless</span>(<span class="keyword">int</span> k,<span class="keyword">char</span> c);</span><br><span class="line">   <span class="built_in">Useless</span>(<span class="keyword">const</span> Useless&amp;ul);</span><br><span class="line">   <span class="built_in">Useless</span>(Useless&amp;&amp;ul);</span><br><span class="line">   Useless&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Useless&amp;ul);</span><br><span class="line">   Useless&amp; <span class="keyword">operator</span>=(Useless&amp;&amp;nl);</span><br><span class="line">   Useless <span class="keyword">operator</span>+(<span class="keyword">const</span> Useless&amp;ul);</span><br><span class="line">   ~Useless <span class="keyword">operator</span>+(<span class="keyword">const</span> Useless&amp;ul);</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">ShowData</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左值引用</span></span><br><span class="line">Useless::<span class="built_in">Useless</span>(<span class="keyword">const</span> Useless &amp; ul)</span><br><span class="line">&#123;</span><br><span class="line">++ct;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;copy const called;numbers ofobject:&quot;</span> &lt;&lt; ct &lt;&lt; std::endl;</span><br><span class="line">n = ul.n;</span><br><span class="line">p = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">p[i] = ul.p[i];</span><br><span class="line"><span class="built_in">showobject</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 右值引用</span></span><br><span class="line">Useless::<span class="built_in">Useless</span>(Useless &amp;&amp; ul)</span><br><span class="line">&#123;</span><br><span class="line">++ct;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;move constructor called;numbers ofobject:&quot;</span> &lt;&lt; ct &lt;&lt; std::endl;</span><br><span class="line">n = ul.n;</span><br><span class="line">p = ul.p;</span><br><span class="line">ul.n = <span class="number">0</span>;</span><br><span class="line">ul.p = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">showobject</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库索引</title>
      <link href="2021/02/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/"/>
      <url>2021/02/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h1 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h1><ol><li>加速数据库的检索速度；  </li><li>降低了插入、删除、修改等维护任务的速度；  </li><li>唯一索引可以确保每一行数据的唯一性；  </li><li>通过索引，可以在查询过程中优化隐藏器，提高系统性能；  </li><li>索引要占据物理和数据空间。  </li></ol><h1 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h1><h2 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h2><p>表的数据要按照索引的顺序来存储。对于聚集索引，叶子结点即存储了真实的数据行，不再有另外的单独数据页。  </p><h2 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h2><p>表数据存储顺序与索引顺序无关。对于非聚集索引，叶节点包含了索引字段值及指向数据页数据的行的逻辑指针，该层紧邻数据页，其行数量与数据表行数据量一致。  </p><h1 id="建立索引要关注哪些因素"><a href="#建立索引要关注哪些因素" class="headerlink" title="建立索引要关注哪些因素"></a>建立索引要关注哪些因素</h1><ul><li>访问类型；  </li><li>访问时间；  </li><li>插入时间；  </li><li>删除时间；  </li><li>空间开销。  </li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL事务隔离级别和锁</title>
      <link href="2021/02/25/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%92%8C%E9%94%81/"/>
      <url>2021/02/25/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%92%8C%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><ol><li>可串行化；  </li><li>可重复读，只允许读取已提交数据，而且在一个事务两次读取同一数据之间，其他事务不能更新该数据；    </li><li>已提交读，只允许读取已经提交的数据；  </li><li>未提交读，允许读取未提交的数据。  </li></ol><p>以上隔离性级别都不允许脏写，即如果一个数据项已经被另一个尚未提交或终止的事务写入，则不允许对该数据项执行写操作。  </p><table><tr>    <th>隔离级别</th>    <th>脏读</th>    <th>不可重复读</th>    <th>幻读</th></tr><tr>    <td>未提交读</td>    <td>可能</td>    <td>可能</td>    <td>可能</td></tr><tr>    <td>已提交读</td>    <td>不可能</td>    <td>可能</td>    <td>可能</td></tr><tr>    <td>可重复读</td>    <td>不可能</td>    <td>不可能</td>    <td>可能</td></tr><tr>    <td>可串行化</td>    <td>不可能</td>    <td>不可能</td>    <td>不可能</td></tr></table><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>DBMS中的并发控制的任务是确保在多个事务同时存取数据库中统一数据时不破坏事务的隔离性和一致性。常见的控制手段是乐观并发控制（乐观锁）和悲观并发控制（悲观锁）。  </p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。<br>使用方法：  </p><ol><li>对任意数据进行修改时，先尝试为该记录加上排他锁。  </li><li>如果加锁失败就说明该记录正在被修改，等待锁被释放。  </li><li>成功加锁后就可以对记录做修改，事务完成后就会解锁。  </li></ol><p>悲观锁适用于数据竞争激烈的环境，以及发生并发冲突时使用锁保护数据的成本低于回滚事务的成本的环境中。</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>假定不会发生并发冲突，只在提交操作时检查是否违反了数据完整性。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。<br>使用方法：  </p><ol><li>在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。  </li><li>数据版本,为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。</li><li>当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。</li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++构造函数</title>
      <link href="2021/02/24/C++%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
      <url>2021/02/24/C++%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>C++的构造函数有四种，默认构造函数、参数构造函数、拷贝构造函数、转换构造函数</p><h2 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h2><p>没有参数，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="built_in">Student</span>()&#123;</span><br><span class="line">    num=<span class="number">100</span>;</span><br><span class="line">    age=<span class="number">18</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="参数构造函数"><a href="#参数构造函数" class="headerlink" title="参数构造函数"></a>参数构造函数</h2><p>传入了一些参数，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="built_in">Student</span>(<span class="keyword">int</span> Age,<span class="keyword">int</span> Num)&#123;</span><br><span class="line">   num=Num;</span><br><span class="line">      age=Age;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>形式参数是本类对象的引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="built_in">Student</span>(Student&amp; s)&#123;</span><br><span class="line">   age=s.age;</span><br><span class="line">      num=s.num;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="转换构造函数"><a href="#转换构造函数" class="headerlink" title="转换构造函数"></a>转换构造函数</h2><p>转换构造函数能够将其他类型的变量转换为本类型，参数只有一个：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="built_in">Student</span>(<span class="keyword">int</span> r)&#123;</span><br><span class="line">   num=r; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果Student类重载了+号，则下面的加法会调用student(18);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Student <span class="title">s1</span><span class="params">(<span class="number">10</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Student <span class="title">s2</span><span class="params">(s1+<span class="number">18</span>)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL引擎和索引</title>
      <link href="2021/02/24/MySQL%E5%BC%95%E6%93%8E%E5%92%8C%E7%B4%A2%E5%BC%95/"/>
      <url>2021/02/24/MySQL%E5%BC%95%E6%93%8E%E5%92%8C%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL引擎"><a href="#MySQL引擎" class="headerlink" title="MySQL引擎"></a>MySQL引擎</h1><p>MySQL存储引擎有InnoDB、MyISAM、MEMORY。</p><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>InnoDB是事务型数据库的首选引擎，支持事务安全（ACID），支持行锁定和外键，InnoDB是MySQL默认的引擎。<br>主要特性：</p><ol><li>InnoDB提供了具有提交、回滚和崩溃恢复的事务安全存储引擎。  </li><li>InnoDB存储引擎在主内存中缓存数据和索引而维持它的缓冲池。它表和索引放在一个逻辑表空间中，而MyISAM表中每个表被存放在分离的文件中。  </li><li>InnoDB支持外键完整性约束。  </li></ol><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>MyISAM基于ISAM，是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM拥有较高的插入、查询，但不支持事务。<br>主要特性：  </p><ol><li>查询、插入效率高；  </li><li>可以把数据文件和索引文件放在不同的目录中；  </li><li>对事务的支持不好。  </li></ol><h2 id="MEMORY"><a href="#MEMORY" class="headerlink" title="MEMORY"></a>MEMORY</h2><p>MEMORY存储引擎将表中的数据存储到内存中，为查询和引用其他表数据提供快速访问。  </p><p>DBMS中的并发控制的任务是确保在多个事务同时存取数据库中统一数据时不破坏事务的隔离性和一致性。常见的控制手段是乐观并发控制（乐观锁）和悲观并发控制（悲观锁）。  </p><h1 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h1><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。<br>使用方法：  </p><ol><li>对任意数据进行修改时，先尝试为该记录加上排他锁。  </li><li>如果加锁失败就说明该记录正在被修改，等待锁被释放。  </li><li>成功加锁后就可以对记录做修改，事务完成后就会解锁。  </li></ol><p>悲观锁适用于数据竞争激烈的环境，以及发生并发冲突时使用锁保护数据的成本低于回滚事务的成本的环境中。</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>假定不会发生并发冲突，只在提交操作时检查是否违反了数据完整性。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。<br>使用方法：  </p><ol><li>在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。  </li><li>数据版本,为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。</li><li>当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。</li></ol><h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><ol><li>可串行化；  </li><li>可重复读，只允许读取已提交数据，而且在一个事务两次读取同一数据之间，其他事务不能更新该数据；    </li><li>已提交读，只允许读取已经提交的数据；  </li><li>未提交读，允许读取未提交的数据。  </li></ol><p>以上隔离性级别都不允许脏写，即如果一个数据项已经被另一个尚未提交或终止的事务写入，则不允许对该数据项执行写操作。  </p><table><tr>    <th>隔离级别</th>    <th>脏读</th>    <th>不可重复读</th>    <th>幻读</th></tr><tr>    <td>未提交读</td>    <td>可能</td>    <td>可能</td>    <td>可能</td></tr><tr>    <td>已提交读</td>    <td>不可能</td>    <td>可能</td>    <td>可能</td></tr><tr>    <td>可重复读</td>    <td>不可能</td>    <td>不可能</td>    <td>可能</td></tr><tr>    <td>可串行化</td>    <td>不可能</td>    <td>不可能</td>    <td>不可能</td></tr></table>]]></content>
      
      
      <categories>
          
          <category> MySQL学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从URL的输入道页面展现</title>
      <link href="2021/02/19/URL%E7%9A%84%E8%BE%93%E5%85%A5%E9%81%93%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0/"/>
      <url>2021/02/19/URL%E7%9A%84%E8%BE%93%E5%85%A5%E9%81%93%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>上网已经成为我们每个人生活中一项重要的内容了，当我们打开浏览器，在地址栏中输入相应的网址并按下了回车键，既会在页面中呈现所需的相关信息。那么，在这背后都进行了哪些技术步骤，才会将丰富的信息内容加载出来，展现在我们眼前呢。  </p><ol><li>键盘或触屏输入URL并回车确认；  </li><li>URL解析和DNS解析查找域名IP地址;  </li><li>网络连接发起HTTP请求;  </li><li>HTTP报文传输过程;  </li><li>服务器接收数据;    </li><li>服务器处理请求并返回数据;    </li><li>浏览器加载/渲染页面。    </li></ol><h1 id="URL解析"><a href="#URL解析" class="headerlink" title="URL解析"></a>URL解析</h1><h2 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h2><p>首先提取出URL中的域名部分，然后电脑会发送一个DNS请求，获得这个域名的IP地址。</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>将主机名和域名转换为IP地址。DNS协议使用UDP/TCP协议进行传输。早期主要是用UDP协议，但是随着DNS需要传输的数据变多，UDP协议能够传输的报文字节数较TCP少很多，所以DNS开始更多使用TCP协议了。  </p><p>查找是递归查找，顺序是：本地DNS服务器-&gt;权威DNS服务器-&gt;顶级域DNS服务器-&gt;根DNS服务器。DNS存在多级缓存，比如浏览器缓存、系统缓存、路由器缓存、IPS服务器缓存、根域名服务器缓存、顶级域名服务器缓存、主域名服务器缓存。  </p><h1 id="服务器处理请求"><a href="#服务器处理请求" class="headerlink" title="服务器处理请求"></a>服务器处理请求</h1><p>浏览器通过IP地址找到对应的服务器，要求建立TCP连接，连接建立后开始处理用户请求。服务器处理请求中使用一种称为MVC的设计模式。<br>MVC：<br>服务器接收到请求后触发Controller（控制器），控制器从Model（模型）和View（视图）中获取各种信息进行处理，最后视图（View）将数据渲染为HTML使得页面更加完整的呈献给用户。  </p><ul><li>Model：应用程序中处理数据逻辑的部分；  </li><li>View：应用程序中处理数据显示的部分；  </li><li>Controller：应用程序中处理用户交互的部分。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>用户态和内核态</title>
      <link href="2021/02/19/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/"/>
      <url>2021/02/19/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p>操作系统维护着相当多的资源，而我们不能给每个进程以相同的权限，所以我们分出了内核态和用户态。用以区分进程能够访问的资源权限。  </p><h1 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h1><p>CPU有不同的指令执行级别，再高执行级别下，代码可以执行特权指令，访问任意的物理地址，这种CPU级别就对应着内核态。而在相应的低级别执行状态下，代码的掌握范围会受到限制。只能在对应级别允许的范围内活动。Intel X86CPU有四种不同的执行级别，Linux只是用了其中0和3级分别表示内核态和用户态</p><p>内核态和用户态之间的桥梁是系统调用，或者说系统调用将整个系统分为用户态和内核态。内核就是控制计算机的硬件资源，例如协调CPU资源，分配内存资源，并且提供稳定的环境供应用程序运行。 </p><p>用户态中和系统调用最近的就是库函数和shell。</p><p>库函数是为了封装系统调用的而存在的，将很多复杂操作封装起来，方便用户使用系统资源。比如可以通过open()来轻松打开文件，malloc()来分配内存，实际上，malloc()还是用了mmap()等系统调用。<br>shell顾名思义，就是外壳的意思。就好像把内核包裹起来的外壳。它是一种特殊的应用程序，俗称命令行。为了方便用户和系统交互，一般一个shell对应一个终端，呈现给用户交互窗口。当然shell也是编程的，它有标准的shell语法，符合其语法的文本叫shell脚本。很多人都会用shell脚本实现一些常用的功能，可以提高工作效率。  </p><p>用户态和内核态切换的方法：  </p><ol><li>系统调用；  </li><li>异常：发生异常后CPU会调用异常处理程序，触发切换，比如缺页异常；  </li><li>外设中断：当外设完成用户的请求时，会向CPU发送中断信号。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深拷贝和浅拷贝</title>
      <link href="2021/02/19/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>2021/02/19/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<p>深拷贝和浅拷贝其实关键在于指针。<br>浅拷贝就是遇到指针只拷贝指针的值。深拷贝遇到指针，会去创建新的内存，然后拷贝指针指向的对象的值。  </p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++的三大特性</title>
      <link href="2021/02/19/C++%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"/>
      <url>2021/02/19/C++%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="封装性"><a href="#封装性" class="headerlink" title="封装性"></a>封装性</h1><p>C++语言支持封装的特性，类是C++实现封装的工具。封装使得能够把复杂功能集成在一个类中，并提供有限的接口（公有成员）供用户使用。这本质上是一种抽象。让用户不用了解类的实现只需要知道每个接口的作用就可以使用类。</p><h1 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h1><p>C++支持单继承和多继承，这是面向对象语言的基本特性。继承是一种类和类之间的关系，更具需要开发者能够在基类的基础上派生出派生类。派生类继承了基类的成员，这种特性提高了现有程序资源的利用率，原来面向过程程序中，如果想要开发一个功能更加复杂的结构体（C），往往需要重新开发，而C++中可以通过继承利用原有程序资源。</p><h1 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h1><p>多态是一种基于继承的特性，通过虚函数来实现，指的是对不同类型的对象发出同样的消息能够有不同的结果。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP三次握手与四次挥手</title>
      <link href="2021/02/18/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
      <url>2021/02/18/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP头部分析"><a href="#TCP头部分析" class="headerlink" title="TCP头部分析"></a>TCP头部分析</h1><p>TCP头部中有几个字段需要重点介绍下：</p><ol><li>序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记；  </li><li>确认序号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1；  </li><li>标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：</li></ol><ul><li>URG：紧急指针（urgent pointer）有效；  </li><li>ACK：确认序号有效；  </li><li>PSH：接收方应该尽快将这个报文交给应用层；  </li><li>RST：重置连接；  </li><li>SYN：发起一个新连接；  </li><li>FIN：释放一个连接。  </li></ul><p>需要注意的是：<br>（A）不要将确认序号Ack与标志位中的ACK搞混了;<br>（B）确认方Ack=发起方Req+1，两端配对。</p><h1 id="TCP握手协议"><a href="#TCP握手协议" class="headerlink" title="TCP握手协议"></a>TCP握手协议</h1><p>TCP协议通过三次握手来创建一个连接：  </p><ol><li>客户端发送一个SYN包（syn=1，seq=i）到服务器，并进入syn_send状态等待；<br>这个SYN包不包含应用层数据，首部的标志位SYN被置为1，所以称为SYN包，客户随机选择一个序号seq=client_i；  </li><li>服务器在收到SYN包后，会为该连接分配TCP缓存和变量，并发送允许连接的报文段。这个允许连接的报文段也不包含应用层数据，包含以下信息：<code>SYN=1</code>，<code>seq=server_i</code>，<code>ack=client_i+1</code>。<code>server_i</code>是服务器随机选取的报文段序号，<code>ack=client_i+1</code>表示确认<code>client_i+1</code>以前的报文段都已经收到，这个报文段我们称为SYNACK报文段；  </li><li>客户端收到SYNACK报文段后，客户也要给该连接分配缓存和变量。客户的主机则向服务器发送另一个报文段；这最后一个报文段对服务器的允许连接的报文段进行了确认（<code>SYN=0</code>、<code>seq=client_i+1</code>、<code>ack=server_i+1</code>），<code>SYN</code>被置为0是因为连接已经建立了。第三个阶段的报文段已经可以携带客户到服务器的数据了。</li></ol><h1 id="TCP挥手协议"><a href="#TCP挥手协议" class="headerlink" title="TCP挥手协议"></a>TCP挥手协议</h1><p>TCP通过四次挥手来释放一个连接：  </p><ol><li>客户端向服务器发送一个特殊的TCP报文段，其中FIN置为0；  </li><li>服务器收到上述报文段后，回发一个确认报文段ACK；  </li><li>然后服务器发送它自己的终止报文段，其FIN比特被置为1，这个时候在TCP眼中连接已经关闭了；  </li><li>最后，该客户对这个服务器的终止报文段进行确认（ACK），发送之后定时等待关闭连接。  </li></ol><h1 id="为什么要三次握手四次挥手"><a href="#为什么要三次握手四次挥手" class="headerlink" title="为什么要三次握手四次挥手"></a>为什么要三次握手四次挥手</h1><p>用一个易于理解的视角来看为什么要3次握手：<br>客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。<br>第一次握手，客户端发送网络包，服务端收到了，服务端得到结论：客户端发送能力正常，服务端接受能力正常；<br>第二次握手，服务端发送网络包，客户端收到，客户端得到结论：服务端接收、发送能力正常，客户端发送、接受能力正常；<br>第三次握手，客户端发送网络包，服务端收到，服务端得到结论：客户端接受能力正常，服务端发送能力正常。<br>经过3次握手，客户端、服务端相互之间确认了对方和自己的接收、发收能力正常。  </p><p>用半关闭来解释为什么需要4次挥手：<br><strong>半关闭</strong>：在TCP通信中客户端向服务端发送一条FIN包，当服务端收到FIN信息时就知道接下来客户端就不会再发送数据了，这在TCP协议中被称为半关闭。但是此时，服务端还能向客户端发送网络包，客户端也依然能接收。<br>一个FIN包意味着一方关闭连接，但是另一方可能数据还没有传完，需要传完才会关闭连接。所以需要在中间维持半关闭状态，等到需要关闭连接时，再发送一次FIN包。相当于客户端、服务端各自需要关闭属于自己的一半连接，每次都需要FIN-ACK两次挥手，总共就有4次挥手。  </p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进程通信方式</title>
      <link href="2021/02/17/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
      <url>2021/02/17/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<ol><li>管道/匿名管道(pipe) 管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。 …</li><li>有名管道(FIFO) …</li><li>信号(Signal) …</li><li>消息(Message)队列 …</li><li>共享内存(share memory) …</li><li>信号量(semaphore) …</li><li>套接字(socket)</li></ol><h1 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h1><ul><li>管道是半双工的，只能单向通信，一端读入，一端写，如果需要双向通信需要建立两个管道。  </li><li>只能用于父子进程或者兄弟进程之间。  </li><li>实质上是一个内核缓冲区，每次写入在缓冲区的末尾，从缓冲区头部读入。  </li></ul><h1 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h1><p>有名管道可以用于在任意进程之间通信。它以文件的形式存在，只要可以访问该路径就可以访问该管道，内容存放在内存中。有名管道遵循先入先出的规定，不支持文件定位操作。  </p><h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><p>信号是Linux系统中用于进程互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。如果该进程当时未处于执行的状态，则该信号就由内核保存起来，知道该进程回复执行并传递给它未知。<br>信号是软件层次上对中断机制的一种模拟，是一种异步通信方式。常见的信号比如<code>Ctrl+C</code>就是给进程发送中断信号。  </p><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符标识。  </p><h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><p>多个进程可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。  </p><h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><p>信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程同步。  </p><h1 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h1><p>这是一种不同主机的进程之间通信的方式。  </p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>守护进程</title>
      <link href="2021/02/17/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/"/>
      <url>2021/02/17/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是守护进程"><a href="#什么是守护进程" class="headerlink" title="什么是守护进程"></a>什么是守护进程</h1><p>守护进程是在后台运行不受终端控制的进程（如输入、输出等），一般的网络服务都是以守护进程的方式运行。<br>守护进程脱离终端的主要原因有两点：  </p><ol><li>用来启动守护进程的终端在启动守护进程之后，需要执行其他任务。  </li><li>（如其他用户登录该终端后，以前的守护进程的错误信息不应出现）由终端上的一些键所产生的信号（如中断信号），不应对以前从该终端上启动的任何守护进程造成影响。要注意守护进程与后台运行程序（即加＆启动的程序）的区别。  </li></ol><h1 id="如何使用守护进程"><a href="#如何使用守护进程" class="headerlink" title="如何使用守护进程"></a>如何使用守护进程</h1><p>还没用过，下次再写。。。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++多线程编程相关操作</title>
      <link href="2021/02/17/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
      <url>2021/02/17/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>前段时间写了个轻量级的多线程Web服务器，今天顺便梳理一下相关的操作。  </p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *tid,<span class="keyword">const</span> <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,<span class="keyword">void</span> *(*func)(<span class="keyword">void</span>*),<span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="comment">// 上述函数可以创建一个线程，如果创建成功，线程ID存入tid</span></span><br><span class="line"><span class="comment">// attr用于设置线程属性，优先级、栈大小等等</span></span><br><span class="line"><span class="comment">// func、arg是线程执行的函数及参数</span></span><br><span class="line"><span class="comment">// 创建成功返回0，否则非0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(pthread *tid,<span class="keyword">void</span> **status)</span></span>;</span><br><span class="line"><span class="comment">// 等待一个线程结束，tid指针存储这个线程的id</span></span><br><span class="line"><span class="comment">// 如果status非空，用于存储这个线程的返回值</span></span><br><span class="line"><span class="function"><span class="keyword">ptherad_t</span> <span class="title">pthread_self</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// 返回自身线程的id</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;</span><br><span class="line"><span class="comment">// 将一个线程转变为脱离状态，即终止时就释放所有资源</span></span><br><span class="line"><span class="comment">// 另一个状态时joinable，这个状态下终止后将会等待其他线程对本线程调用pthread_join</span></span><br><span class="line"><span class="comment">// 此前将会保存ID和退出状态</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *status)</span></span>;</span><br><span class="line"><span class="comment">// 终止线程</span></span><br></pre></td></tr></table></figure><h1 id="线程之间的同步技术"><a href="#线程之间的同步技术" class="headerlink" title="线程之间的同步技术"></a>线程之间的同步技术</h1><h2 id="信号量sem"><a href="#信号量sem" class="headerlink" title="信号量sem"></a>信号量sem</h2><p>信号量类型是<code>sem_t</code>：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span>* sem,<span class="keyword">int</span> pshared,<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="comment">// 初始化一个信号量</span></span><br><span class="line"><span class="comment">// pshared表示是否在进程间共享，0表示只在线程间共享，否则进程间共享</span></span><br><span class="line"><span class="comment">// value为设置的初始值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span>* sem)</span></span>;</span><br><span class="line"><span class="comment">// 销毁一个线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span>* sem)</span></span>;</span><br><span class="line"><span class="comment">// P操作，对信号量-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span>* sem)</span></span>;</span><br><span class="line"><span class="comment">// V操作，信号量+1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_getvalue</span><span class="params">(<span class="keyword">sem_t</span>* sem, <span class="keyword">int</span>* valp)</span></span>;</span><br><span class="line"><span class="comment">// 返回信号量的值到valp</span></span><br></pre></td></tr></table></figure><h2 id="互斥锁mux"><a href="#互斥锁mux" class="headerlink" title="互斥锁mux"></a>互斥锁mux</h2><p>互斥锁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span>* mutex, <span class="keyword">const</span> <span class="keyword">thread_mutexattr_t</span>* mutexattr)</span></span>;</span><br><span class="line"><span class="comment">// 初始化一个互斥锁，mutexattr是相关设置参数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span>* mutex)</span></span>;</span><br><span class="line"><span class="comment">// 对互斥锁加锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span>* mutex)</span></span>;</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span>* mutex;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">// 非阻塞加锁，如果已经上锁，不会阻塞，避免死锁</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> pthread_mutex_destroy(<span class="keyword">pthread_mutex_t</span>* mutex);</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">// 用来撤销互斥锁的资源。</span></span></span></span><br></pre></td></tr></table></figure><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>读写锁是用来处理读者-写者问题：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="keyword">pthread_rwlock_t</span>* rwlock, <span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span>* attr)</span></span>;</span><br><span class="line"><span class="comment">// 初始化读写锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_destroy</span><span class="params">(<span class="keyword">pthread_rwlock_t</span>* rwlock)</span></span>;</span><br><span class="line"><span class="comment">// 销毁读写锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span>* rwlock)</span></span>;</span><br><span class="line"><span class="comment">// 加读锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span>* rwlock)</span></span>;</span><br><span class="line"><span class="comment">// 加写锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span>* rwlock)</span></span>;</span><br><span class="line"><span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋锁和互斥锁差不多，区别是自旋锁阻塞方式和互斥锁不同，互斥锁是让线程睡眠来实现阻塞，而自旋锁是通过不断循环让线程忙等待，适用于占用自旋锁时间比较短的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_init</span><span class="params">(<span class="keyword">__pthread_spinlock_t</span>* __lock, int__pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_destroy</span><span class="params">(<span class="keyword">__pthread_spinlock_t</span>* __lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_trylock</span><span class="params">(<span class="keyword">__pthread_spinlock_t</span>* __lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_unlock</span><span class="params">(<span class="keyword">__pthread_spinlock_t</span>* __lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_lock</span><span class="params">(<span class="keyword">__pthread_spinlock_t</span>* __lock)</span></span>;</span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++强制类型转换</title>
      <link href="2021/02/16/C++%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>2021/02/16/C++%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>C++提供四种强制类型转换方式：static_cast, dynamic_cast, const_cast, reinterpret_cast。  </p><h1 id="static-cast的使用"><a href="#static-cast的使用" class="headerlink" title="static_cast的使用"></a><code>static_cast</code>的使用</h1><p><code>static_cast</code>可以用于：  </p><ol><li>基本类型之间的类型转换；  </li><li>void*指针转化为其他类型指针；  </li><li>添加const属性（<code>static_cast&lt;const type&amp;&gt;(obj)</code>），强制转换的目标类型必须是指针或引用；  </li><li>用于有继承关系对象之间的转换和类指针之间的转换：</li></ol><ul><li>进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；  </li><li>进行下行转换（把基类的指针或引用转换为派生类表示），由于没有动态类型检查，所以是不安全的；</li></ul><h1 id="const-cast的使用"><a href="#const-cast的使用" class="headerlink" title="const_cast的使用"></a><code>const_cast</code>的使用</h1><p>用于去除变量的只读属性；<br>强制转换的目标类型必须是指针或引用；  </p><h1 id="dynamic-cast的使用"><a href="#dynamic-cast的使用" class="headerlink" title="dynamic_cast的使用"></a><code>dynamic_cast</code>的使用</h1><ol><li>用于有继承关系的类指针间的转换；</li><li>用于有交叉关系的类指针间的转换；</li><li>具有类型检查的功能；</li><li>需要虚函数的支持。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++常见关键字</title>
      <link href="2021/02/16/C++%E5%B8%B8%E8%A7%81%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>2021/02/16/C++%E5%B8%B8%E8%A7%81%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="全局静态变量："><a href="#全局静态变量：" class="headerlink" title="全局静态变量："></a>全局静态变量：</h2><p>内存中的位置：静态存储区，在整个程序运行期间一直存在。<br>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；<br>作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。</p><h2 id="局部静态变量："><a href="#局部静态变量：" class="headerlink" title="局部静态变量："></a>局部静态变量：</h2><p>在局部变量之前加上关键字static，局部变量就成为一个局部静态变量，它的生命周期变成了整个源文件。<br>内存中的位置：静态存储区。<br>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；<br>作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；  </p><h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> val=<span class="number">0</span>;</span><br><span class="line">　　<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在cpp中必须对类静态成员变量进行初始化，初始化时使用作用域运算符来标明他所属类，其属于该类的所有成员共有，只有一个拷贝。  </p><p>类静态成员函数实现的时候不需要static的修饰，因为static是声明性关键字；类的静态函数是该类的范畴内的全局函数，不能访问类的私有成员，只能访问类的静态成员，不需要类的实例即可调用；实际上，他就是增加了类的访问权限的全局函数。类的静态成员函数可以继承或者覆盖，但是不能是虚函数。  </p><h2 id="只在cpp内有效的全局变量："><a href="#只在cpp内有效的全局变量：" class="headerlink" title="只在cpp内有效的全局变量："></a>只在cpp内有效的全局变量：</h2><p>在cpp文件的全局范围内声明：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> val = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这个变量的含义是该cpp内有效，但是其他的cpp文件不能访问这个变量；如果有两个cpp文件声明了同名的全局静态变量，那么他们实际上是独立的两个变量；</p><h2 id="只在cpp内有效的全局函数："><a href="#只在cpp内有效的全局函数：" class="headerlink" title="只在cpp内有效的全局函数："></a>只在cpp内有效的全局函数：</h2><p>函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；<br>warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰。  </p><h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><p>const名叫常量限定符，用来限定特定变量，以通知编译器该变量是不可修改的。习惯性的使用const，可以避免在函数中对某些不应修改的变量造成可能的改动。  </p><h2 id="关于数组"><a href="#关于数组" class="headerlink" title="关于数组"></a>关于数组</h2><p>C++中数组的值实际上就是一个地址而且这个值不能修改，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a[]&#x3D;&#123;1,2,3&#125;;</span><br></pre></td></tr></table></figure><p>数组变量一旦定义，就不可以在修改其地址，const可以在int之前修饰也可以在之后，都表示限定了数组内的元素值。  </p><h2 id="关于指针"><a href="#关于指针" class="headerlink" title="关于指针"></a>关于指针</h2><p>const关于指针有两种用法，指针常量和常量指针：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a&#x3D;1;</span><br><span class="line">const int *p1&#x3D;&amp;a;</span><br><span class="line">int const *p2&#x3D;&amp;a;</span><br></pre></td></tr></table></figure><p>第一个const修饰了int，这是一个常量指针，不能修改指针指向的对象；<br>第二个cosnt修饰了*，表示这个是一个指针常量，指针值不能修改。  </p><h2 id="用于函数"><a href="#用于函数" class="headerlink" title="用于函数"></a>用于函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">numerator</span>() * rhs.<span class="built_in">numerator</span>(),</span><br><span class="line">lhs.<span class="built_in">denominator</span>() * rhs.<span class="built_in">denominator</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回值用const修饰可以防止允许这样的操作发生:</span></span><br><span class="line">Rational a,b;</span><br><span class="line">Radional c;</span><br><span class="line">(a*b) = c;</span><br></pre></td></tr></table></figure><p>避免返回结果作为左值的情况。</p><h1 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h1><p>它的作用是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块活其他模块中使用，记住它是一个声明不是定义!也就是说B模块(编译单元)要是引用模块(编译单元)A中定义的全局变量或函数时，它只要包含A模块的头文件即可,在编译阶段，模块B虽然找不到该函数或变量，但它不会报错，它会在连接时从模块A生成的目标代码中找到此函数。  </p><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>C/C++中volatile关键字和const对应，用来修饰变量，通常用于建立语言级别的memory barrier。用它申明的类型变量表示可以被某些编译器未知的因素更改，比如操作系统、硬件、其他线程等。遇到这个关键字申明的变量，编译器对访问该变量的时候不再优化，从而可以获得稳定的地址访问。<br>我们以下面的代码为例子：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> i=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a = i;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 其他代码，并未明确告诉编译器，对 i 进行过操作</span></span><br><span class="line"><span class="keyword">int</span> b = i;</span><br></pre></td></tr></table></figure><p>volatile指出i是随时可能发生变化的，每次使用它的时候必须从i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放再b中。而优化的做法是，由于编译器发现两次从i读数据的代码之间的代码没有对i进行过操作，它会自动把读的数据放在b中，而不是重新从i里面读取。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RAII技术和智能指针</title>
      <link href="2021/02/16/RAII%E6%8A%80%E6%9C%AF%E5%92%8C%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
      <url>2021/02/16/RAII%E6%8A%80%E6%9C%AF%E5%92%8C%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="RAII技术"><a href="#RAII技术" class="headerlink" title="RAII技术"></a>RAII技术</h1><p>RAII是C++的发明者Bjarne Stroustrup提出的概念，RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”，也就是说在构造函数中申请分配资源，在析构函数中释放资源。因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。<br>智能指针（std::shared_ptr和std::unique_ptr）即RAII最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记delete造成的内存泄漏。毫不夸张的来讲，有了智能指针，代码中几乎不需要再出现delete了。</p><h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><p>智能指针在C++11版本之后提供，包含在头文件<code>&lt;memory&gt;</code>中，<code>shared_ptr</code>、<code>unique_ptr</code>、<code>weak_ptr</code>。  </p><h2 id="shared-ptr的使用"><a href="#shared-ptr的使用" class="headerlink" title="shared_ptr的使用"></a><code>shared_ptr</code>的使用</h2><p>shared_ptr多个指针指向相同的对象。shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。  </p><p><strong>初始化</strong>：智能指针是个模板类，可以指定类型，传入指针通过构造函数初始化。也可以使用make_shared函数初始化。不能将指针直接赋值给一个智能指针，一个是类，一个是指针。例如std::shared_ptr<int> p4 = new int(1);的写法是错误的。<br><strong>拷贝和赋值</strong>：拷贝使得对象的引用计数增加1，赋值使得原对象引用计数减1，当计数为0时，自动释放内存。后来指向的对象引用计数加1，指向后来的对象。<br>**get()**：获取原始指针，注意不要用一个原始指针初始化多个shared_ptr，否则会造成二次释放同一内存。<br><strong>陷阱</strong>：shared_ptr的一个最大的陷阱是循环引用，循环，循环引用会导致堆内存无法正确释放，导致内存泄漏。循环引用在weak_ptr中介绍。</p><h2 id="unique-ptr的使用"><a href="#unique-ptr的使用" class="headerlink" title="unique_ptr的使用"></a><code>unique_ptr</code>的使用</h2><p><code>unique_ptr</code>“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。相比与原始指针unique_ptr用于其RAII的特性，使得在出现异常的情况下，动态资源能得到释放。<br>unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。  unique_ptr指针与其所指对象的关系：在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过移动语义转移所有权。</p><h2 id="weak-ptr的使用"><a href="#weak-ptr的使用" class="headerlink" title="weak_ptr的使用"></a><code>weak_ptr</code>的使用</h2><p>weak_ptr是为了配合shared_ptr而引入的一种智能指针，因为它不具有普通指针的行为，没有重载operator*和-&gt;,它的最大作用在于协助shared_ptr工作，像旁观者那样观测资源的使用情况。weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。<br>但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。使用weak_ptr的成员函数use_count()可以观测资源的引用计数，另一个成员函数expired()的功能等价于use_count()==0,但更快，表示被观测的资源(也就是shared_ptr的管理的资源)已经不复存在。weak_ptr可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象， 从而操作资源。但当expired()==true的时候，lock()函数将返回一个存储空指针的shared_ptr。</p><h2 id="野指针与预防"><a href="#野指针与预防" class="headerlink" title="野指针与预防"></a>野指针与预防</h2><p>野指针，又称迷途指针，即指向“垃圾”内存的指针。此时指针指向的内存已被操作系统回收，程序已无法再访问。野指针，不是NULL指针，而是看上去指向合法内存，却在实际上该内存已经释放。  </p><ol><li><p>声明指针时候积得初始化：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p=<span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></li><li><p>当指针没有利用价值的时候，为该指针赋值为NULL：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> != P)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果用指针作为参数进行传递时候，最好做下检查，比如<code>assert(p!=NULL)</code>。  </p></li><li><p>尽量用引用代替指针。  </p></li><li><p>用智能指针代替野指针。  </p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C和C++内存管理</title>
      <link href="2021/02/16/C%E5%92%8CC++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>2021/02/16/C%E5%92%8CC++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>C语言中我们一般用<code>malloc()</code>函数和<code>free()</code>函数来分配和释放内存。C++中我们一般用关键字<code>new</code>、<code>delete</code>来分配和释放内存。那他们有哪些区别呢？</p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Test* p_c = (Test*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Test));</span><br><span class="line">  Test* p_cpp = <span class="keyword">new</span> Test;</span><br><span class="line">  <span class="built_in">free</span>(p_c);</span><br><span class="line">  <span class="keyword">delete</span> p_cpp;</span><br></pre></td></tr></table></figure><h1 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h1><p><code>malloc()</code>以字节为单位分配内存，不会调用构造函数，而<code>new</code>以具体类型为单位分配内存，调用了构造函数。<br><code>free()</code>仅归还内存，析构函数未被调用。<code>delete</code>销毁对象，归还内存，析构函数被调用。  </p><p><code>malloc()</code>和<code>new</code>区别：  </p><ul><li>new 在所有 C++ 编译器中都被支持  </li><li>malloc 在某些系统开发中不能调用  </li><li>new 能够触发构造函数的调用  </li><li>malloc 仅分配需要的内存空间  </li><li>对象的创建只能使用 new  </li><li>malloc 不适合面向对象开发  </li></ul><p><code>free()</code>和<code>delete</code>区别：  </p><ul><li>delete 在所有 C++ 编译器中都被支持  </li><li>free 在某些系统开发中不能调用  </li><li>delete 能够触发析构函数的调用  </li><li>free 仅归还之前分配的内存空间  </li><li>对象的销毁只能使用 delete  </li><li>free 不适合面向对象开发</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>虚函数</title>
      <link href="2021/02/16/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
      <url>2021/02/16/%E8%99%9A%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。</p><h1 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h1><p>对C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。</p><h1 id="一般继承（无函数覆盖）"><a href="#一般继承（无函数覆盖）" class="headerlink" title="一般继承（无函数覆盖）"></a>一般继承（无函数覆盖）</h1><p>这种情况下虚函数表会存储基类和派生类的虚函数，且基类在前。</p><h1 id="一般继承（有函数覆盖）"><a href="#一般继承（有函数覆盖）" class="headerlink" title="一般继承（有函数覆盖）"></a>一般继承（有函数覆盖）</h1><p>派生类重载了基类的虚函数，这时候在虚函数表中派生类的中的函数<code>f()</code>被放到了虚表中原来父类虚函数<code>f()</code>的位置，没有被覆盖的函数依旧。</p><h1 id="多重继承（无函数覆盖）"><a href="#多重继承（无函数覆盖）" class="headerlink" title="多重继承（无函数覆盖）"></a>多重继承（无函数覆盖）</h1><p>会有多个虚函数表，每个基类都有自己的虚函数表，派生类的虚函数放在第一个虚函数表的末尾。</p><h1 id="多重继承（有函数覆盖）"><a href="#多重继承（有函数覆盖）" class="headerlink" title="多重继承（有函数覆盖）"></a>多重继承（有函数覆盖）</h1><p>如果这个函数覆盖了多个基类的函数，则在每个对应的虚函数表中都会覆盖基类的函数。</p><h1 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h1><p>这里再说一下纯虚函数吧，定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funtion1</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++继承</title>
      <link href="2021/02/16/C++%E7%BB%A7%E6%89%BF/"/>
      <url>2021/02/16/C++%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p>考虑继承关系时，我们涉及三种成员，分别是私有成员、公有成员、保护成员，关键字依次是<code>private</code>、<code>public</code>、<code>protected</code>。</p><p>保护成员在类的用户眼中，等价于私有成员，但是保护成员可以被类成员函数调用。  </p><h1 id="公有继承"><a href="#公有继承" class="headerlink" title="公有继承"></a>公有继承</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span>:</span><span class="keyword">public</span> Base</span><br><span class="line"><span class="comment">//public表示公有继承</span></span><br></pre></td></tr></table></figure><p>基类的私有成员–&gt;派生类不可见；<br>基类的公有成员–&gt;派生类的公有成员；<br>基类的保护成员–&gt;派生类的保护成员。  </p><h1 id="私有继承"><a href="#私有继承" class="headerlink" title="私有继承"></a>私有继承</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span>:</span><span class="keyword">private</span> Base</span><br><span class="line"><span class="comment">//private表示私有继承</span></span><br><span class="line"><span class="comment">//私有继承也是默认的继承方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span>:</span>Base</span><br></pre></td></tr></table></figure><p>基类的私有成员–&gt;派生类不可见；<br>基类的公有成员–&gt;派生类的私有成员；<br>基类的保护成员–&gt;派生类的私有成员。 </p><h1 id="保护继承"><a href="#保护继承" class="headerlink" title="保护继承"></a>保护继承</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span>:</span><span class="keyword">protected</span> Base</span><br><span class="line"><span class="comment">//protected表示保护继承</span></span><br></pre></td></tr></table></figure><p>基类的私有成员–&gt;派生类不可见；<br>基类的公有成员–&gt;派生类的保护成员；<br>基类的保护成员–&gt;派生类的保护成员。 </p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进程启动和加载</title>
      <link href="2021/02/16/%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E5%92%8C%E5%8A%A0%E8%BD%BD/"/>
      <url>2021/02/16/%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E5%92%8C%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="启动进程"><a href="#启动进程" class="headerlink" title="启动进程"></a>启动进程</h1><p>在Linux系统中，每个进程都有唯一的进程号（PID），方便系统识别和调度进程。通过简单地输出运行程序的程序名，就可以运行该程序，其实也就是启动了一个进程。总地来说，启动一个进程主要有2种途径，手动启动和通过调度启动。  </p><h2 id="手动启动"><a href="#手动启动" class="headerlink" title="手动启动"></a>手动启动</h2><p>指用户通过输入命令启动一个进程，又可以分为前台启动和后台启动。  </p><h3 id="前台启动进程"><a href="#前台启动进程" class="headerlink" title="前台启动进程"></a>前台启动进程</h3><p>这是手动启动进程最常见的方式，在前台输入一个命令并运行，就能够启动一个前台进程。  </p><h3 id="后台启动进程"><a href="#后台启动进程" class="headerlink" title="后台启动进程"></a>后台启动进程</h3><p>进程直接从后台启动用的比较少，大多是进程比较耗时，并且我们不急于看到运行结果，为了不使整个shell处于“被占用”状态，从后台启动这个进程是比较明智的选择。从后台启动进程，其实只要在命令结尾处添加一个“&amp;”符号即可。</p><h2 id="Linux调度启动进程"><a href="#Linux调度启动进程" class="headerlink" title="Linux调度启动进程"></a>Linux调度启动进程</h2><p>在Linux系统种，任务可以被配置在指定的时间、日期或者系统平均负载量低于指定值时自动启动。实现调度启动的方法很多，例如通过crontab、at等命令。</p><h1 id="进程加载"><a href="#进程加载" class="headerlink" title="进程加载"></a>进程加载</h1><p>进程加载需要如下过程：  </p><ol><li>创建一个独立的虚拟地址空间。主要是分配一个页目录。  </li><li>读取可执行文件的头，并且建立虚拟空间和可执行文件的映射关系。主要是把可执行文件映射到虚拟地址空间，即做虚拟页和物理页的映射，以便“缺页”时载入。  </li><li>讲CPU的指令寄存器设置成可执行文件的入口地址，启动运行。  </li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令学习</title>
      <link href="2021/02/15/Linux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/02/15/Linux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h1><h2 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h2><p><code>tcpdump</code>是一个抓包命令。有如下参数：  </p><p>-<strong>i</strong>:指定需要抓包的网卡。如果未指定的话，tcpdump会默认选择搜索到的系统中状态为up的最小数字的网卡，一般情况下是eth0。-i lo抓取回环的数据包。<br>-<strong>nnn</strong>：禁用tcpdump展示时把IP、端口等转换为域名、端口知名服务名称。这样看起来会更清晰<br>-<strong>s</strong>：指定抓包的包大小。使用-s 0指定数据包大小为262144。可以使抓到的数据包不被截断，完整反映数据包的内容。默认68字节。<br>-<strong>c</strong>：指定抓包的数量。<br>-<strong>w</strong>：指定抓包结果保存的文件，以便后续用wireshark等工具进行分析。<br>-<strong>P</strong>：in/out/inout，指定要抓取的包是流入还是流出的包。默认inout<br>-<strong>F</strong>：使用文件作为过滤条件表达式的输入, 此时命令行上的输入将被忽略.<br>-<strong>p</strong>： 一般情况下, 把网络接口设置为非’混杂’模式。  </p><h1 id="进程、线程相关"><a href="#进程、线程相关" class="headerlink" title="进程、线程相关"></a>进程、线程相关</h1><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p><code>ps</code>可以用来查看当前有哪些进程，涉及很多参数，不一一列举，要用再查。<br>加上<code>-T</code>选项可以开启线程查看，比如下面命令可以查看进程<code>&lt;pid&gt;</code>创建的所有线程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux&gt; ps -T -p &lt;pid&gt;</span><br></pre></td></tr></table></figure><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p><code>top</code>可以实时查看各个线程的情况，以下命令可以查看Linux所有线程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux&gt; top -H</span><br></pre></td></tr></table></figure><p>而以下命令可以只查看进程<code>&lt;pid&gt;</code>的所有线程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux&gt; top -H -p &lt;pid&gt;</span><br></pre></td></tr></table></figure><h2 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h2><p><code>strace</code>是用来跟踪进程的系统调用的，可以用如下命令跟踪进程<code>&lt;pid&gt;</code>的所有系统调用并将结果输出到output.txt文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux&gt; sudo strace -o output.txt -p &lt;pid&gt;</span><br></pre></td></tr></table></figure><p><code>strace</code>还有很多其他参数，比如<code>-e expr</code>，expr是一个表达式，比方说<code>-e trace=open</code>就是跟踪系统调用open。参数很多，这里不一一列举了。  </p><h2 id="pstack"><a href="#pstack" class="headerlink" title="pstack"></a>pstack</h2><p><code>pstack</code>使用来跟踪进程的栈的命令。如下命令可以查看进程<code>&lt;pid&gt;</code>的栈。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux&gt; pstack &lt;pid&gt;</span><br></pre></td></tr></table></figure><h2 id="memstat"><a href="#memstat" class="headerlink" title="memstat"></a>memstat</h2><p><code>memstat</code>可以用来查询共享库的信息，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Linux&gt; memstat -w | sort -rn</span><br><span class="line">&#x2F;&#x2F; -w标识全部打印（没有会截断长度超过80的字符串），然后按照字节数来排序</span><br></pre></td></tr></table></figure><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p><code>free</code>可以显示内存情况，可用参数有：  </p><ul><li>b，以字节为单位显示；  </li><li>k，以kb为单位显示；  </li><li>m，以mb为单位显示；<br>….<br>不一一列举，需要再查。</li></ul><h1 id="网络状态和防火墙"><a href="#网络状态和防火墙" class="headerlink" title="网络状态和防火墙"></a>网络状态和防火墙</h1><h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><p><code>netstat</code>命令用于显示Linux系统网络链接状态。netstat命令用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。如果我们要显示当前的TCP连接，可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux&gt; netstat --tcp</span><br></pre></td></tr></table></figure><h2 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h2><p>这个命令就是用来显示或设置网络设备：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Linux&gt; ifconfig</span><br><span class="line">Linux&gt; ifconfig eth0 down</span><br><span class="line">Linux&gt; ifconfig eth0 up</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>哈希表扩容</title>
      <link href="2021/02/15/%E5%93%88%E5%B8%8C%E8%A1%A8%E6%89%A9%E5%AE%B9/"/>
      <url>2021/02/15/%E5%93%88%E5%B8%8C%E8%A1%A8%E6%89%A9%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<p>HashMap的实例具有两个影响其性能的参数：初始容量和负载因子。容量是哈希表中存储桶的数量，初始容量只是哈希表创建时的容量。负载因子是在自动增加其散列表容量之前允许散列表获得的满度的度量。当哈希表中的条目数超过负载因子和当前容量的乘积时，哈希表将被重新哈希（即，内部数据结构将被重建），因此哈希表的存储桶数约为两倍。  </p><p>通常，默认负载因子（.75）在时间和空间成本之间提供了一个很好的权衡。较高的值会减少空间开销，但会增加查找成本（在HashMap类的大多数操作中都得到体现，包括get和put）。设置其初始容量时，应考虑映射中的预期条目数及其负载因子，以最大程度地减少重新哈希操作的次数。如果初始容量大于最大条目数除以负载系数，则将不会发生任何重新哈希操作。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>堆和栈</title>
      <link href="2021/02/15/%E5%A0%86%E5%92%8C%E6%A0%88/"/>
      <url>2021/02/15/%E5%A0%86%E5%92%8C%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h1><p>栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致栈中与其相邻的变量的值被改变。</p><p>栈溢出的原因有：  </p><ol><li>局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出。局部变量是存储在栈中的，因此这个很好理解。解决这类问题的办法有两个，一是增大栈空间,二是改用动态分配，使用堆（heap）而不是栈（stack）；  </li><li>递归调用层次太多。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出；  </li><li>指针或数组越界。这种情况最常见，例如进行字符串拷贝，或处理用户输入等等。  </li></ol><h1 id="堆和栈的区别："><a href="#堆和栈的区别：" class="headerlink" title="堆和栈的区别："></a>堆和栈的区别：</h1><p>堆是由低地址向高地址扩展；栈是由高地址向低地址扩展；<br>堆中的内存需要手动申请和手动释放；栈中内存是由OS自动申请和自动释放，存放着参数、局部变量等内存；<br>堆中频繁调用malloc和free,会产生内存碎片，降低程序效率；而栈由于其先进后出的特性，不会产生内存碎片；<br>堆的分配效率较低，而栈的分配效率较高。  </p><p>栈的效率高的原因：<br>栈是操作系统提供的数据结构，计算机底层对栈提供了一系列支持：分配专门的寄存器存储栈的地址，压栈和入栈有专门的指令执行；而堆是由C/C++函数库提供的，机制复杂，需要一些列分配内存、合并内存和释放内存的算法，因此效率较低。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>B树与B+树</title>
      <link href="2021/02/15/B%E6%A0%91%E4%B8%8EB+%E6%A0%91/"/>
      <url>2021/02/15/B%E6%A0%91%E4%B8%8EB+%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><p>B树也称B-树,它是一颗多路平衡查找树。性质如下：  </p><ol><li>每个节点最多有m-1个关键字（可以存有的键值对）；  </li><li>根节点最少可以只有1个关键字；  </li><li>非根节点至少有m/2个关键字；  </li><li>每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它；  </li><li>所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同；  </li><li>每个节点都存有索引和数据，也就是对应的key和value；<br>所以，根节点的关键字数量范围：1 &lt;= k &lt;= m-1，非根节点的关键字数量范围：m/2 &lt;= k &lt;= m-1。  </li></ol><h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><p>B+树其实和B树是非常相似的，我们首先看看相同点：  </p><ol><li>根节点至少一个元素；  </li><li>非根节点元素范围：m/2 &lt;= k &lt;= m-1。  </li></ol><p>不同点：  </p><ol><li>B+树有两种类型的节点：内部结点（也称索引结点）和叶子结点。内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存储在叶子节点；  </li><li>内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。</li><li>每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。</li><li>父节点存有右孩子的第一个元素的索引。</li></ol><h1 id="B-树和B树相比的优点"><a href="#B-树和B树相比的优点" class="headerlink" title="B+树和B树相比的优点"></a>B+树和B树相比的优点</h1><p><strong>效率高</strong>：B+树非叶子结点不存储数据，所以能够有更多的子结点，降低了树的高度，减少磁盘IO次数，效率更高。此外由于叶结点保存的数据多，对访问的局部性原理利用更好，缓存命中率高。<br><strong>更适合于范围查找</strong>：在B树中进行范围查找时，需要先找到下限制，在进行中序遍历，直到找到上限；而B+树只要找到下限后，通过链表向前遍历即可。<br><strong>更稳定的查询效率</strong>：B+树的每个叶子结点到根结点的距离是一样的，所以磁盘IO次数是稳定的，而B树查询每次磁盘IO次数是不确定的。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>红黑树与AVL树</title>
      <link href="2021/02/15/%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8EAVL%E6%A0%91/"/>
      <url>2021/02/15/%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8EAVL%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h1><p>AVL树也称平衡二叉树，是一种特殊的二叉查找树。它满足性质，左右子树都是AVL树，左右子树高度之差不超过1。<br>AVL树的定义非常简单，通过限制左右子树的高度之差能够保证AVL树的平衡性，避免一头太大。  </p><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树，相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树。  </p><p>性质：  </p><ol><li>每个节点非红即黑；  </li><li>根节点是黑的；  </li><li>每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的；  </li><li>如果一个节点是红色的，则它的子节点必须是黑色的；  </li><li>对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点。  </li></ol><h2 id="为什么map底层要用红黑树"><a href="#为什么map底层要用红黑树" class="headerlink" title="为什么map底层要用红黑树"></a>为什么map底层要用红黑树</h2><p>AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。所以红黑树在查找，插入删除的性能都是O(logn)，且性能稳定，所以STL里面很多结构包括map底层实现都是使用的红黑树。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GET和POST的区别</title>
      <link href="2021/02/14/GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>2021/02/14/GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>GET是“读取”一个资源，比如GET到一个HTML文件，反复读取不应该对访问的数据有副作用。就像是读取内存一样。因为GET是读取，就可以对GET请求的数据做缓存。这个缓存可以在浏览器上也可以在代理服务器上。  </p><p>POST是提交一个表单。这个操作是不能缓存的，返回的页面可以理解为一次性消耗品。  </p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><ol><li>一般来说，GET报文中URL包含参数，而POST报文中参数会在body里面；  </li><li>由于URL对浏览器是可见的，GET报文不如POST报文安全，不要用GET报文来发送账号-密码这类数据；  </li><li>重复发送GET报文是无害的，重复发送POST报文可能是有害的；  </li><li>GET报文的结果可以缓存，而POST不行。  </li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库事务</title>
      <link href="2021/02/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
      <url>2021/02/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h1><p>数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。  </p><p>事务具有4个基本特征：原子性（Automicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Duration），简称ACID。  </p><ol><li>原子性：事务被视为不可分割的最小单元，事物的所有操作要不成功，要不失败回滚，而回滚可以通过日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作。  </li><li>一致性：数据库在事务执行前后都保持一致性状态，在一致性状态下，所有事务对一个数据的读取结果都是相同的。  </li><li>隔离性：一个事务所做的修改在最终提交以前，对其他事务是可不见的。  </li><li>持久性：一旦事务提交，则其所做的修改将会永远保存到数据库中。  </li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>服务器事务处理模式</title>
      <link href="2021/02/13/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/02/13/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>服务器通常要处理3种类型的事件：IO事件、信号、定时事件。而有两种高效处理时间的方式，分别是Reactor模式与Proactor模式。  </p><h1 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h1><p>Reactor模式要求主线程只负责事件监听描述符上是否事件发生，有事件发生后通知工作线程，除此以外，主线程不做任何工作，读写数据、接收新的连接、处理客户请求都在工作线程上完成。<br>使用同步IO（<code>epoll_wait()</code>为例子）实现的Reactor模式的工作流程如下：  </p><ol><li>主线程往epoll内核事件表注册socket上的读就绪时间；  </li><li>主线程调用<code>epoll_wait()</code>等待socket上有数据可读；  </li><li>当socket上数据可读时，<code>epolll_wait()</code>通知主线程。主线程将socket可读事件放入请求队列；  </li><li>睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写事件。  </li><li>主线程调用<code>epoll_wait()</code>等待socket可写；  </li><li>当socket可写时，epoll_wait()通知主线程。主线程将socket可写事件放入请求队列；  </li><li>睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。  </li></ol><h1 id="Proactor"><a href="#Proactor" class="headerlink" title="Proactor"></a>Proactor</h1><p>与Reactor模式不通，Proactor模式将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。  </p><p>使用异步IO（<code>aio_read()</code>和<code>aio_write()</code>为例）实现的Proactor模式工作流程如下：  </p><ol><li>主线程调用<code>aio_read()</code>函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时候如何通知应用程序（信号机制）；  </li><li>主线程继续处理其他逻辑；  </li><li>应用程序预先定义好信号处理函数并选择一个工作线程来处理客户请求；工作线程处理完客户请求之后，调用<code>aio_write()</code>想内核注册socket上的写完成事件，并告诉内核缓冲区的位置，以及写操作完成时应如何通知应用程序（信号）；  </li><li>主线程继续处理其他逻辑；  </li><li>当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知程序数据以及传送完毕；  </li><li>应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如是否决定关闭socket。  </li></ol><p>使用同步IO也可以实现的Proactor模式。原理是这样的：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一“完成事件”，那么工作线程直接获得了读写结果，接下来要做的只是对读写结果的处理。工作流程如下：  </p><ol><li>主线程调用<code>epoll_ctl()</code>向epoll内核事件表中注册描述符；  </li><li>主线程调用<code>epoll_wait()</code>等待socket上有数据可读；  </li><li>当socket上有数据可读时，epoll_wait()通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将多有数据封装成一个请求对象并插入请求队列中；  </li><li>睡眠在请求队列中的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket上的写就绪事件；  </li><li>主线程调用<code>epoll_wait()</code>等待socket可写；  </li><li>当sockt可写时，<code>epoll_wait()</code>通知主线程。主线程往socket上写入服务器处理客户请求的结果。  </li></ol><p>这里同步模拟和异步模拟Proactor的区别在于，同步模拟是主线程自己进行I/O操作，需要等待读完数据，而异步I/O是通过aio_read()异步读取，主线程不需要等待I/O完成。</p><p>其实通过上述描述我们还可以发现同步IO和异步IO的一个区别。同步IO注册的是就绪事件（<code>epoll_wait()</code>），而异步IO是注册完成事件（<code>aio_read()</code>、<code>aio_write()</code>）。  </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP协议</title>
      <link href="2021/02/13/TCP%E5%8D%8F%E8%AE%AE/"/>
      <url>2021/02/13/TCP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>TCP是可靠传输协议，提供了可靠传输、拥塞控制等服务，接下来我们介绍TCP如何实现这些服务。  </p><h1 id="序列号、确认应答、超时重传"><a href="#序列号、确认应答、超时重传" class="headerlink" title="序列号、确认应答、超时重传"></a>序列号、确认应答、超时重传</h1><p>数据到达接收方后，接收方需要发出一个确认应答，表示已经收到数据号，并且序号指出了下一个需要传入的数据段。如果接收方迟迟没有收到应答，可能是发送的数据丢失，也可能是应答丢失。这时发送方会等待一段时间，然后会进行重传。  </p><h1 id="窗口控制和高速重发控制-快速重传（重复确认应答）"><a href="#窗口控制和高速重发控制-快速重传（重复确认应答）" class="headerlink" title="窗口控制和高速重发控制/快速重传（重复确认应答）"></a>窗口控制和高速重发控制/快速重传（重复确认应答）</h1><p>TCP会利用窗口控制来提高传输速度，意思是在一个窗口大小内，不用一定要等到应答才能发送下一段数据，窗口大小就是无需等待确认而可以继续发送数据的最大值。如果不使用窗口控制，每一个没收到确认应答的数据都要重发。<br>使用窗口控制，如果数据段1001-2000丢失，后面数据每次传输，确认应答都会不停地发送序号为1001的应答，表示我要接收1001开始的数据，发送端如果收到3次相同应答，就会立刻进行重发；但还有种情况有可能是数据都收到了，但是有的应答丢失了，这种情况不会进行重发，因为发送端知道，如果是数据段丢失，接收端不会放过它的，会疯狂向它提醒。  </p><h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><p>如果把窗口定的很大，发送端连续发送大量的数据，可能会造成网络的拥堵（大家都在用网，你在这狂发，吞吐量就那么大，当然会堵），甚至造成网络的瘫痪。所以TCP在为了防止这种情况而进行了拥塞控制。  </p><h2 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h2><p>定义拥塞窗口，一开始将该窗口大小设为1，之后每次收到确认应答（经过一个rtt），将拥塞窗口大小*2。</p><h2 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h2><p>设置慢启动阈值，一般开始都设为65536。拥塞避免是指当拥塞窗口大小达到这个阈值，拥塞窗口的值不再指数上升，而是加法增加（每次确认应答/每个rtt，拥塞窗口大小+1），以此来避免拥塞。</p><p>将报文段的超时重传看做拥塞，则一旦发生超时重传，我们需要先将阈值设为当前窗口大小的一半，并且将窗口大小设为初值1，然后重新进入慢启动过程。</p><h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h2><p>在遇到3次重复确认应答（高速重发控制）时，代表收到了3个报文段，但是这之前的1个段丢失了，便对它进行立即重传。</p><p>然后，先将阈值设为当前窗口大小的一半，然后将拥塞窗口大小设为慢启动阈值+3的大小。</p><p>这样可以达到：在TCP通信时，网络吞吐量呈现逐渐的上升，并且随着拥堵来降低吞吐量，再进入慢慢上升的过程，网络不会轻易的发生瘫痪。  </p><h2 id="TCP协议和UDP协议比较"><a href="#TCP协议和UDP协议比较" class="headerlink" title="TCP协议和UDP协议比较"></a>TCP协议和UDP协议比较</h2><ol><li>TCP是面向连接的协议，UDP是面向报文的协议，不进行连接；  </li><li>TCP是一对一的，UDP支持单播，多播，广播；  </li><li>TCP比UDP可靠，TCP提供了超时重传、拥塞控制等服务，UDP只提供发送报文的功能，并且不保证发送到；  </li><li>UDP的开销比TCP小，UDP头部需要存储的信息较少；  </li><li>UDP由于美誉拥塞控制，所以UDP流量在网络中比TCP流量更危险，举个例子：UDP流量较大，导致网络阻塞，而TCP拥塞控制算法减小了TCP流量，UDP流量占比进一步提高，最后可能整个网络都是TCP流量；</li><li>对于文件等流量更适合TCP协议，而视频、音频等实时性要求高，准确性要求相对低的流量可能适合UDP协议。  </li><li>TCP是全双工的，UDP是单向的。</li></ol><h3 id="TCP协议和UDP协议应用场景"><a href="#TCP协议和UDP协议应用场景" class="headerlink" title="TCP协议和UDP协议应用场景"></a>TCP协议和UDP协议应用场景</h3><table>  <tr>    <th></th>    <th>TCP</th>    <th>UDP</th>  </tr>  <tr>    <td>可靠性</td>    <td>可靠</td>    <td>不可靠</td>  </tr>  <tr>    <td>思想</td>    <td>面向字节流</td>    <td>面向报文</td>  </tr>  <tr>    <td>拥塞控制</td>    <td>慢启动、快速恢复、拥塞避免</td>    <td>不提供拥塞控制</td>  </tr>  <tr>    <td>双工性</td>    <td>全双工</td>    <td>一对一、多对一、一对多、多对多</td>  </tr>  <tr>    <td>效率</td>    <td>传输效率低</td>    <td>传输效率高</td>  </tr>  <tr>    <td>应用场景</td>    <td>准确率要求高，效率要求低</td>    <td>效率要求高，准确率要求低</td>  </tr>    </table>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>轻量级高性能Web服务器开发</title>
      <link href="2021/02/12/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%AB%98%E6%80%A7%E8%83%BDWeb%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"/>
      <url>2021/02/12/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%AB%98%E6%80%A7%E8%83%BDWeb%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>笔者这学期先后学习了《深入理解计算机系统》、《计算机网络：自顶向下方法》、《操作系统概念》，想要做一个项目来巩固这段时间所学的知识，考虑到CSAPP中实现了一个TinyWebServer，我打算开发一个高性能Web服务器。  </p><h1 id="相关环境配置"><a href="#相关环境配置" class="headerlink" title="相关环境配置"></a>相关环境配置</h1><ul><li>服务器测试环境  </li><li>Ubuntu版本16.04</li><li>MySQL版本5.7.32</li><li>浏览器测试</li><li>FireFox</li><li>创建数据库  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">create database webserver_database;</span><br><span class="line">&#x2F;&#x2F; 创建一个名为webserver_database的数据库</span><br><span class="line">user database webserver_database;</span><br><span class="line">&#x2F;&#x2F; 在这个数据库中创建表user，关系为(username,passwd)</span><br><span class="line">&#x2F;&#x2F; 保存用户名-密码</span><br><span class="line">create table user(</span><br><span class="line">username char(50) NULL,</span><br><span class="line">   passwd char(50) NULL</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F; 添加一条数据，内容可以填上任意的用户名和密码</span><br><span class="line">INSERT INTO user(username, passwd) VALUES(&#39;wujiahao&#39;,&#39;wujiahao&#39;);</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line"></span><br><span class="line">这个数据库只有一个表user，其保存的是用户的用户名、密码。  </span><br><span class="line">- 文件管理  </span><br><span class="line"> - makefile  </span><br><span class="line"> - 运行方式  </span><br><span class="line"> </span><br><span class="line"> &#96;&#96;&#96;shell</span><br><span class="line"> linux&gt; make</span><br><span class="line"> linux&gt; .&#x2F;server</span><br></pre></td></tr></table></figure><h1 id="知识基础"><a href="#知识基础" class="headerlink" title="知识基础"></a>知识基础</h1><p>本项目中主要涉及以下知识。  </p><ul><li>C++基础  </li><li>数据结构基础  </li><li>计算机网络基础  </li><li>操作系统基础  </li><li>Linux基础  </li><li>服务器开发规范  </li></ul><p>项目中参考的书籍：  </p><ul><li>《深入理解计算机系统》  </li><li>《计算机网络：自顶向下方法》  </li><li>《UNIX环境高级编程》  </li><li>《UNIX网络编程 卷一：套接字联网API》  </li><li>《鸟哥的Linux私房菜：基础篇》  </li><li>《Linux高性能服务器编程》  </li></ul><h2 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a>计算机系统</h2><p>CSAPP主要是理解进程、线程的相关概念，对多进程、多线程编程有一个基本的认识。其中涉及到的进程、线程、信号量、互斥锁、生产者-消费者模型等概念在本项目中用到最多。重点参考本书的第三部分（第10章系统级I/O、第11章网络编程、第12章并发编程）。另外可以读一读第7章链接和第8章异常控制流，对项目文件的管理和理解用户态/内核态有帮助。 </p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>《计算机网络：自顶向下方法》本书我实际上只看了前5章，包括应用层、传输层、网络层，由于计算机网络是一个层次结构，所以只需要掌握这部分内容，在进行服务器开发时，就不存在较大的知识盲区了。</p><h2 id="UNIX编程"><a href="#UNIX编程" class="headerlink" title="UNIX编程"></a>UNIX编程</h2><p>《UNIX环境高级编程》、《UNIX网络编程 卷一：套接字联网API》主要是作为字典，遇到需要用的函数或者不理解的知识时进行查询用的。</p><h2 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a>Linux基础</h2><p>《鸟哥的Linux私房菜：基础篇》比较好的Linux入门书籍，由于笔者时间紧迫，就没有先系统学习了，只在需要的时候查询相关命令。</p><h2 id="服务器开发规范"><a href="#服务器开发规范" class="headerlink" title="服务器开发规范"></a>服务器开发规范</h2><p>主要参考了游双的《Linux高性能服务器编程》，这本书提供了很多服务器开发中运用的技术，并提供了相应的代码（笔者在实际开发中很多代码是基于本书提供的代码所写）：  </p><ul><li><p>主流服务器模型：C/S模型和P2P模型  </p></li><li><p>C/S模型<br>也就是客户端/服务器模型，这个模型很简单，就是所有的资源都被服务器所拥有，客户端需要访问服务器来获取所需的资源。  </p></li><li><p>P2P模型<br>P2P模型比C/S模型更接近网络通信的实际情况，摒弃了以服务器为中心的格局，让网络中所有主机重新回到对等的地位。  </p></li><li><p>比较<br>C/S模型适合资源相对集中的场合，它的实现也更为简单，缺点是当访问量过大的时候，可能所有客户都将得到很慢的响应。P2P模型使得每台机器在消耗服务的同时也给别人提供服务，这样资源能够充分、自由地共享。但是当用户之间传输的请求过多时，网络的负载将会加重。  </p></li><li><p>I/O模型：同步I/O与异步I/O  </p></li><li><p>阻塞I/O<br>当发生系统调用时候，比如recv，用户进程要一直等待到数据拷贝到用户空间，这段时间内进程始终阻塞。它是同步I/O。  </p></li><li><p>非阻塞I/O<br>还是以recv为例子，不管有没有数据都返回，如果没有数据，过一会再调用recv看看，如此循环。但是如果有数据，它要等待数据拷贝到用户空间，因此还是同步I/O。  </p></li><li><p>I/O复用<br>同时监听多个文件描述符，当有可读/可写/异常事件发生的时候，通知进程，进行读写或者处理异常。当没有事件发生时候，正常运行。就当前例子来看还是同步I/O，因为依旧要等待数据读完或者写完才能继续运行。I/O复用可用于同步I/O也可用于异步I/O。  </p></li><li><p>信号驱动的I/O模型<br>通过调用sigaction注册信号函数，等内核数据准备好的时候，系统中断当前程序，执行信号函数（在这里调用recv）。这还是同步I/O。  </p></li><li><p>异步I/O模型<br>调用aio_read，让内核等数据准本好，并且复制到用户进程空间后执行实现指定好的函数。这样子省去了进程等待读数据的事件。这是真正的异步I/O。  </p></li><li><p>I/O的两个阶段<br>内核数据的准备阶段和内核数据复制到用户缓冲区阶段。只有进程不用等待这两个阶段，才是真正的异步I/O。  </p></li><li><p>事件处理模式：Reactor模式/Proactor模式<br>服务器程序通常要处理3类事件，I/O事件、信号和定时事件。在处理事件上有两种高效的事件处理模式：Reactor和Proactor。这两种其实也都是I/O复用模型  </p></li><li><p>Reactor模式<br>Reactor是这样一种模式，它要求主线程只负责监听文件描述上是否有事件发生，有的话就立即将该事件通知工作线程。除此之外，主线程不做任何其他实质性的工作，读写数据、接收新的连接，以及处理客户请求均在工作线程中完成。<br>使用同步I/O模型（以<code>epoll_wait()</code>为例）实现的Reacotr模式的工作流程如下：<br>1）主线程往epoll内核事件表中注册socket上的读就绪事件。<br>2）主线程调用<code>epoll_wait()</code>等待socket上有数据可读。<br>3）当socket上有数据可读时，<code>epoll_wait()</code>通知主线程。主线程将socket可读事件放入请求队列。<br>4）睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写事件。<br>5）主线程调用<code>epoll_wait()</code>等待socket可写。<br>6）当socket可写时，<code>epoll_wait()</code>通知主线程。主线程将socket可写事件放入请求队列。<br>7）睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。<br>重点：要有一个read/write事件处理器。  </p></li><li><p>Proactor模式<br>与Reactor模式不通，Proactor模式将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。<br>使用异步I/O模型（<code>aio_read</code>和<code>aio_write</code>为例）实现得Proactor模式工作流程。<br>1）主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序。（信号）<br>2）主线程继续处理其他逻辑。<br>3）应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用<code>aio_write</code>函数向内核注册socket上的写完成事件，并告诉内核用户缓冲区的位置，以及写操作完成时如何通知应用程序（信号）。<br>4）主线程继续处理其他逻辑。<br>5）当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。<br>6）当用户缓冲区的数据写入socket之后，内核向应用程序发送一个信号，以通知应用程序数据已经传送完毕。<br>7）应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket。  </p></li><li><p>同步模拟Proactor模型<br>《Linux高性能服务器编程》一书中提到了一种用同步I/O来模拟Proactor模式的方法。其原理是：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一“完成事件”。那么工作线程直接获得了读写结果，接下来只要做的只是对读写结果的处理。<br>1）主线程调用<code>epoll_wait()</code>内核事件表中注册socket上的读就绪事件。<br>2）主线程调用<code>epoll_wait()</code>等大socket上有数据可读。<br>3）当socket上有数据可读时，<code>epoll_wait()</code>通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将所有数据封装成一个请求对象并插入请求队列。<br>4）睡眠在请求队列中的某个工作流程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket上的写就绪事件。<br>5）主线程调用<code>epoll_wait()</code>等待socket可写。<br>6）当socket可写时，<code>epoll_wait()</code>通知主线程。主线程往socket上写入服务器处理客户请求的结果。<br>这里同步模拟和异步模拟Proactor的区别在于，同步模拟是主线程自己进行I/O操作，需要等待读完数据，而异步I/O是通过<code>aio_read()</code>异步读取，主线程不需要等待I/O完成。  </p></li><li><p>总结<br>Reactor和Proactor的本质区别在于谁负责I/O操作，其实它们都可以分别利用同步I/O或者异步I/O来实现。</p></li><li><p>并发模式<br>并发编程的目的是让程序“同时”执行多个任务，如果程序是计算密集型的，并发编程并没有优势，反而由于任务切换使得效率低。但如果程序是I/O密集型，则情况不通。和IO不通的是，在并发模式中，同步指的是程序完全按照代码序列的顺序执行；异步指的是程序的执行需要由系统事件来驱动。同步线程效率低，实时性差，但是逻辑简单，异步线程实时性强，效率高，但是相对复杂难以调试。对于服务器而言，既追求实时性，也要同时处理多个请求，我们应该采用半同步半异步模式。  </p></li><li><p>半同步/半异步模式<br>同步线程处理客户逻辑，异步线程处理I/O事件。  </p></li><li><p>领导者/追随者模式<br>多个工作线程轮流获得事件源，轮流监听、分发并处理事件。在任意时刻，程序都仅有一个领导者线程，它负责监听I/O事件。而其他线程则是追随者，它们休眠在线程池，然后等待处理I/O事件。此时新的领导者等待I/O事件，原来的领导者处理I/O事件，二者实现了并发。  </p></li></ul><p>以上就是《Linux高性能服务器编程》中关于服务器开发的一些重要技术和规范。  </p><h1 id="框架设计"><a href="#框架设计" class="headerlink" title="框架设计"></a>框架设计</h1><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>文件<code>lock/locker.h</code>提供了3类，分别是sem、locker、cond，是对信号量、互斥锁、条件变量的封装。  </p><h2 id="sem类"><a href="#sem类" class="headerlink" title="sem类"></a>sem类</h2><p>信号量，提供函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sem</span>();          <span class="comment">//默认构造函数</span></span><br><span class="line"><span class="built_in">sem</span>(<span class="keyword">int</span> num);   <span class="comment">//构造函数，信号量初始为num</span></span><br><span class="line">~<span class="built_in">sem</span>(); <span class="comment">//析构函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wait</span><span class="params">()</span></span>;    <span class="comment">//V操作，信号量-1</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">post</span><span class="params">()</span></span>;    <span class="comment">//P操作，信号+1</span></span><br></pre></td></tr></table></figure><h2 id="locker类"><a href="#locker类" class="headerlink" title="locker类"></a>locker类</h2><p>互斥锁，提供函数如下：  </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">locker</span>();   <span class="comment">//构造函数</span></span><br><span class="line">~<span class="built_in">locker</span>()； <span class="comment">//析构函数</span></span><br><span class="line"><span class="built_in">lock</span>()；    <span class="comment">//上锁</span></span><br><span class="line"><span class="built_in">unlock</span>()；  <span class="comment">//解锁</span></span><br><span class="line">pthread_mutex_t *get()；    //返回互斥锁指针</span><br></pre></td></tr></table></figure><h2 id="cond类"><a href="#cond类" class="headerlink" title="cond类"></a>cond类</h2><p>条件变量，提供的函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cond</span>();<span class="comment">//构造函数</span></span><br><span class="line">~<span class="built_in">cond</span>();<span class="comment">//析构函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wait</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *m_mutex)</span></span>;<span class="comment">//等待目标条件变量</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">timewait</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *m_mutex, struct timespec t)</span></span>;<span class="comment">//等待目标条件变量一定时间</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">signal</span><span class="params">()</span></span>;<span class="comment">//信号唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">broadcast</span><span class="params">()</span></span>;<span class="comment">//信号唤醒</span></span><br></pre></td></tr></table></figure><p><code>wait(pthread_mutex_t *m_mutex)</code>内部调用<code>pthread_cond_wait()</code>，此函数内部操作分为以下步骤：</p><ul><li>先传入一个互斥锁和条件变量，将线程放在条件变量的请求队列后，内部解锁</li><li>线程等待被pthread_cond_broadcast信号唤醒或者pthread_cond_signal信号唤醒，唤醒后去竞争锁，若竞争到锁，则内部再次加锁。<br>使用方式举例说明，下面这是我们设计的用来处理日志事件的循环队列，利用上述三个类，这个队列实现了线程安全。条件变量这样使用：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> (m_size &gt;= m_max_size)</span><br><span class="line">    &#123;</span><br><span class="line">        m_cond.<span class="built_in">broadcast</span>();</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_back = (m_back + <span class="number">1</span>) % m_max_size;</span><br><span class="line">    m_array[m_back] = item;</span><br><span class="line">    m_size++;</span><br><span class="line">    m_cond.<span class="built_in">broadcast</span>();</span><br><span class="line">    m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//pop时,如果当前队列没有元素,将会等待条件变量</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(T &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">while</span> (m_size &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_cond.<span class="built_in">wait</span>(m_mutex.<span class="built_in">get</span>()))</span><br><span class="line">        &#123;</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m_front = (m_front + <span class="number">1</span>) % m_max_size;</span><br><span class="line">    item = m_array[m_front];</span><br><span class="line">    m_size--;</span><br><span class="line">    m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>将事件<code>push</code>进队列之前现对互斥锁<code>m_mutex</code>上锁，然后添加成功后，解锁，并广播<code>m_cond.wait()</code>，因为<code>pop</code>可能因为队列为空而被阻塞，广播将唤醒等待队列中的条件变量。<br><code>pop</code>中先将<code>m_mutex</code>上锁，然后<code>m_cond_wait()</code>函数将条件变量添加到等待队列中后，将mutex_解锁（这样条件变量不会错过条件判断和加入等待队列之间的所有变化）。然后当条件变量满足时，将会去竞争互斥锁，然后竞争成功的条件变量加锁并返回（因为会有多个条件变量被满足来竞争互斥锁）。  </li></ul><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>在<code>log/block_queue.h</code>中实现了一个线程安全的循环队列，其功能和一般的队列区别不大。这个队列用于处理日志事件。<br>在<code>log/log.h,log/log.cc</code>中声明并实现了日志类。</p><h2 id="block-queue类"><a href="#block-queue类" class="headerlink" title="block_queue类"></a>block_queue类</h2><p>一个线程安全的循环队列，操作和普通队列基本一致，不做过多说明。</p><h2 id="log类"><a href="#log类" class="headerlink" title="log类"></a>log类</h2><p>日志类，采用单例模式。<br>单例模式是最常用的设计模式之一，保证一个类只有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。<br>实现思路：私有化它的构造函数，以防止外界创建单例类的对象；使用类的私有静态指针变量窒息那个类的唯一实例，并用一个公有的静态方法获取该实例。<br>单例模式有两种实现方法，分别是懒汉和饿汉模式。顾名思义，懒汉模式，即非常懒，不用的时候不去初始化，所以在第一次被使用时才进行初始化；饿汉模式，即迫不及待，在程序运行时立即初始化。<br>我的实现是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Log</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//C++11以后,使用局部变量懒汉不用加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Log *<span class="title">get_instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Log instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Log</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Log</span>();</span><br><span class="line">    <span class="comment">//其他</span></span><br></pre></td></tr></table></figure><p>静态成员instance只会被生成一次保证了单例。不过需要注意的是C++11之前的在创建<code>instance</code>需要加锁，因为编译器不保证内部静态变量的线程安全。C++11之后不需要了。  </p><p>log包含如下变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> dir_name[<span class="number">128</span>]; <span class="comment">//路径名</span></span><br><span class="line"><span class="keyword">char</span> log_name[<span class="number">128</span>]; <span class="comment">//log文件名</span></span><br><span class="line"><span class="keyword">int</span> m_split_lines;  <span class="comment">//日志最大行数</span></span><br><span class="line"><span class="keyword">int</span> m_log_buf_size; <span class="comment">//日志缓冲区大小</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> m_count;  <span class="comment">//日志行数记录</span></span><br><span class="line"><span class="keyword">int</span> m_today;        <span class="comment">//因为按天分类,记录当前时间是那一天</span></span><br><span class="line">FILE *m_fp;         <span class="comment">//打开log的文件指针</span></span><br><span class="line"><span class="keyword">char</span> *m_buf;</span><br><span class="line">block_queue&lt;string&gt; *m_log_queue;   <span class="comment">//阻塞队列</span></span><br><span class="line">locker m_mutex;                     <span class="comment">//互斥锁</span></span><br><span class="line"><span class="keyword">int</span> m_close_log;                    <span class="comment">//关闭日志</span></span><br></pre></td></tr></table></figure><p>提供了如下成员函数：</p><h3 id="bool-init-const-char-file-name-int-close-log-int-log-buf-size-8192-int-split-lines-int-max-queue-size"><a href="#bool-init-const-char-file-name-int-close-log-int-log-buf-size-8192-int-split-lines-int-max-queue-size" class="headerlink" title="bool init(const char *file_name,int close_log,int log_buf_size=8192,int split_lines,int max_queue_size)"></a><code>bool init(const char *file_name,int close_log,int log_buf_size=8192,int split_lines,int max_queue_size)</code></h3><p>分为异步写入和同步写入两种方式,如果参数max_queue_size&gt;=1表示采取异步。<br>异步模式：<br>初始化阻塞队列，并且创建一个线程（调用flush_log_thread）读取阻塞队列写日志。<br>生成日志文件名（添加时间信息）。<br>创建/打开日志文件。  </p><h3 id="void-write-log-int-level-const-char-format"><a href="#void-write-log-int-level-const-char-format" class="headerlink" title="void write_log(int level, const char *format, ...)"></a><code>void write_log(int level, const char *format, ...)</code></h3><p>生成日志写入条目，包括类型（INFO、ERROR）、时间等信息。<br>判断当前日期和类的日期是否一致，不一致则刷新该文件写入缓冲区并关闭之前的文件描述符，打开新的文件。<br>判断异步写入还是同步写入：<br>如果同步，直接写入文件。<br>如果异步，将代写入信息push进阻塞队列。</p><h3 id="void-flush-void"><a href="#void-flush-void" class="headerlink" title="void flush(void)"></a><code>void flush(void)</code></h3><p>线程安全的刷新文件缓冲区（加互斥锁）。</p><h3 id="static-void-flush-log-thread-void-args"><a href="#static-void-flush-log-thread-void-args" class="headerlink" title="static void *flush_log_thread(void *args)"></a><code>static void *flush_log_thread(void *args)</code></h3><p>提供给写日志工作线程的调用函数。这个函数调用私有成员函数<code>async_write_log()</code></p><h3 id="void-async-write-log"><a href="#void-async-write-log" class="headerlink" title="void *async_write_log()"></a><code>void *async_write_log()</code></h3><p>异步写入日志函数，从阻塞队列取出日志条目，并写入日志。</p><h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><p><code>log.h</code>中提供了几个宏定义，实现了对日志写入的包装，让其他函数能够更加轻松的调用日志类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_DEBUG(format, ...) <span class="meta-keyword">if</span> (0 == m_close_log)&#123;Log::get_instance()-&gt;write_log(0, format,##__VA_ARGS__);Log::get_instance()-&gt;flush();&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_INFO(format, ...) <span class="meta-keyword">if</span> (0 == m_close_log)&#123;Log::get_instance()-&gt;write_log(1, format, ##__VA_ARGS__);Log::get_instance()-&gt;flush();&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_WARN(format, ...) <span class="meta-keyword">if</span> (0 == m_close_log)&#123;Log::get_instance()-&gt;write_log(2, format, ##__VA_ARGS__);Log::get_instance()-&gt;flush();&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_ERROR(format, ...)<span class="meta-keyword">if</span> (0 == m_close_log)&#123;Log::get_instance()-&gt;write_log(3, format, ##__VA_ARGS__);Log::get_instance()-&gt;flush();&#125;</span></span><br></pre></td></tr></table></figure><h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><h2 id="client-data类"><a href="#client-data类" class="headerlink" title="client_data类"></a>client_data类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    sockaddr_in address;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    util_timer *timer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>客户数据类，数据成员有套接字描述符、地址、定时器。  </p><h2 id="util-timer类"><a href="#util-timer类" class="headerlink" title="util_timer类"></a>util_timer类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">util_timer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">util_timer</span>() : <span class="built_in">prev</span>(<span class="literal">NULL</span>), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">time_t</span> expire;  <span class="comment">//定时器终止时间</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*cb_func)(client_data *);</span><br><span class="line">    client_data *user_data;</span><br><span class="line">    util_timer *prev;</span><br><span class="line">    util_timer *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>定时器类，数据成员包括前继结点、后继结点、终止时间、客户数据类。此类服务于定时器链表。</p><h3 id="cb-func-client-data"><a href="#cb-func-client-data" class="headerlink" title="cb_func(client_data *)"></a><code>cb_func(client_data *)</code></h3><p>功能：关闭已连接套接字，并设置epoll内核事件注册表（删除套接字）。<br>此函数在定时器超时时候调用。</p><h2 id="sort-timer-lst类"><a href="#sort-timer-lst类" class="headerlink" title="sort_timer_lst类"></a>sort_timer_lst类</h2><p>升序定时器链表。<br>按照终止时间升序排列的定时器双向链表。<br>包括数据成员头指针、尾指针。<br>提供公有成员函数：<br>void add_timer(util_timer*)<br>void adjust_timer(util_timer*)<br>void del_timer(util_timer*)<br>void tick()  </p><h3 id="add-timer-util-timer"><a href="#add-timer-util-timer" class="headerlink" title="add_timer(util_timer*)"></a><code>add_timer(util_timer*)</code></h3><p>添加定时器到链表中</p><h3 id="adjust-timer-util-timer"><a href="#adjust-timer-util-timer" class="headerlink" title="adjust_timer(util_timer*)"></a><code>adjust_timer(util_timer*)</code></h3><p>调整定时器在链表中的位置。由于事件的发生定时器终止时间可能会发生变化，也需要相应的调整其在链表中的位置。同时插入新的定时器，也需要调整位置</p><h3 id="del-timer-utile-timer"><a href="#del-timer-utile-timer" class="headerlink" title="del_timer(utile_timer*)"></a><code>del_timer(utile_timer*)</code></h3><p>删除定时器。</p><h3 id="tick"><a href="#tick" class="headerlink" title="tick()"></a><code>tick()</code></h3><p>可以理解为滴答，即查看当前时间，将定时器链表中超时间的定时器对象删除，并调用<code>cb_func()</code>删除相应的注册事件和关闭套接字描述符。</p><h2 id="Utils类"><a href="#Utils类" class="headerlink" title="Utils类"></a>Utils类</h2><p>这是一个工具类，直接面向服务器类<code>webserver</code>，负责管理连接的定时器链表、通信管道。<br>包含静态数据成员有：<code>int *u_pipefd</code>：这是管道，用于通信；<code>int u_epollfd</code>：这是epoll文件描述符。  包含数据成员：<code>sort_timer_lst m_timer_lst</code>：定时器链表；<code>int m_TIMESLOT</code>：时间间隔。<br>提供的成员函数：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> timeslot)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">bool</span> one_shot, <span class="keyword">int</span> TRIGMode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addsig</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">void</span>(handler)(<span class="keyword">int</span>), <span class="keyword">bool</span> restart = <span class="literal">true</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_error</span><span class="params">(<span class="keyword">int</span> connfd, <span class="keyword">const</span> <span class="keyword">char</span> *info)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="void-init-int-timeslot"><a href="#void-init-int-timeslot" class="headerlink" title="void init(int timeslot)"></a><code>void init(int timeslot)</code></h3><p>设置定时器时间间隔</p><h3 id="int-setnonblocking-int-fd"><a href="#int-setnonblocking-int-fd" class="headerlink" title="int setnonblocking(int fd)"></a><code>int setnonblocking(int fd)</code></h3><p>将文件描述符设置为非阻塞，即立即返回，不等待I/O。</p><h3 id="void-addfd-int-epollfd-int-fd-bool-one-shot-int-TRIGMode"><a href="#void-addfd-int-epollfd-int-fd-bool-one-shot-int-TRIGMode" class="headerlink" title="void addfd(int epollfd, int fd, bool one_shot, int TRIGMode)"></a><code>void addfd(int epollfd, int fd, bool one_shot, int TRIGMode)</code></h3><p>向epoll内核注册表注册套接字描述符号，并设置触发模式LT/ET。one_shot用于设置同一套接字能否被多个线程处理。</p><h3 id="void-sig-handler-int-sig"><a href="#void-sig-handler-int-sig" class="headerlink" title="void sig_handler(int sig)"></a><code>void sig_handler(int sig)</code></h3><p>静态成员函数。信号处理函数：设计成将传递信号到管道。</p><h3 id="void-addsig-int-sig-void-handler-int-bool-restart-true"><a href="#void-addsig-int-sig-void-handler-int-bool-restart-true" class="headerlink" title="void addsig(int sig, void(handler)(int), bool restart = true)"></a><code>void addsig(int sig, void(handler)(int), bool restart = true)</code></h3><p>为sig信号设置信号处理函数handler。</p><h3 id="void-timer-handler"><a href="#void-timer-handler" class="headerlink" title="void timer_handler()"></a><code>void timer_handler()</code></h3><p>定时任务处理，包括<code>tick()</code>、和发出SIGALRM信号。</p><h3 id="void-show-error-int-connfd-const-char-info"><a href="#void-show-error-int-connfd-const-char-info" class="headerlink" title="void show_error(int connfd, const char *info)"></a><code>void show_error(int connfd, const char *info)</code></h3><p>向套接字输出错误，一般只用于输出超时信息。</p><h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><p><code>mysql/sql_connection_pool.h</code>、<code>mysql/sql_connection_pool.cc</code>申明了数据库连接池类<code>connection_pool</code>、数据库连接类<code>connectionRAII</code>。<br><code>connection_pool</code>提供数据库连接服务，先初始化好数据库连接，<code>connectionRAII</code>可以理解为前者的一个接口，只获得一个数据库连接，当http服务需要进行数据库连接时，只需要创建一个<code>connectionRAII</code>对象并从连接池获取连接即可。  </p><h2 id="connection-pool"><a href="#connection-pool" class="headerlink" title="connection_pool"></a>connection_pool</h2><p>单例模式实现，包含下列数据成员：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_MaxConn;  <span class="comment">//最大连接数</span></span><br><span class="line"><span class="keyword">int</span> m_CurConn;  <span class="comment">//当前已使用的连接数</span></span><br><span class="line"><span class="keyword">int</span> m_FreeConn; <span class="comment">//当前空闲的连接数</span></span><br><span class="line">locker lock;    <span class="comment">//互斥锁</span></span><br><span class="line">list&lt;MYSQL *&gt; connList; <span class="comment">//连接池</span></span><br><span class="line">sem reserve;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_url;           <span class="comment">//主机地址</span></span><br><span class="line">string m_Port;    <span class="comment">//数据库端口号</span></span><br><span class="line">string m_User;  <span class="comment">//登陆数据库用户名</span></span><br><span class="line">string m_PassWord;    <span class="comment">//登陆数据库密码</span></span><br><span class="line">string m_DatabaseName;  <span class="comment">//使用数据库名</span></span><br><span class="line"><span class="keyword">int</span> m_close_log;    <span class="comment">//日志开关</span></span><br></pre></td></tr></table></figure><p>提供的成员函数包括：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MYSQL *<span class="title">GetConnection</span><span class="params">()</span></span>; <span class="comment">//返回一个数据库连接</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ReleaseConnection</span><span class="params">(MYSQL *conn)</span></span>; <span class="comment">//释放连接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetFreeConn</span><span class="params">()</span></span>; <span class="comment">//获取连接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyPool</span><span class="params">()</span></span>; <span class="comment">//销毁所有连接</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> connection_pool *<span class="title">GetInstance</span><span class="params">()</span></span>;<span class="comment">//单例模式，获取唯一实例</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(string url, string User, string PassWord, string DataBaseName, <span class="keyword">int</span> Port, <span class="keyword">int</span> MaxConn, <span class="keyword">int</span> close_log)</span></span>; <span class="comment">//初始化连接池</span></span><br></pre></td></tr></table></figure><h2 id="connectionRAII"><a href="#connectionRAII" class="headerlink" title="connectionRAII"></a>connectionRAII</h2><p>数据成员包括：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">MYSQL *conRAII;<span class="comment">//数据连接</span></span><br><span class="line">connection_pool *poolRAII;<span class="comment">//数据库连接池</span></span><br></pre></td></tr></table></figure><p>成员函数有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connectionRAII</span>(MYSQL **con, connection_pool *connPool); </span><br><span class="line"><span class="comment">//构造时直接从数据库连接池中获取数据库连接</span></span><br><span class="line">~<span class="built_in">connectionRAII</span>();</span><br></pre></td></tr></table></figure><h1 id="HTTP服务"><a href="#HTTP服务" class="headerlink" title="HTTP服务"></a>HTTP服务</h1><p><code>http_connect.h</code>、<code>http_connect.cc</code>中实现了http服务类-http_connect(为连接提供http服务，一个连接对应一个http_connect对象），还是实现了<code>setnoblocking()</code>、<code>addfd()</code>、<code>removefd()</code>、<code>modfd()</code>等功能函数。<br>上述功能函数用于设置epoll描述符的相关属性、向epoll内核事件表中添加/删除事件的功能。</p><h2 id="http-connect"><a href="#http-connect" class="headerlink" title="http_connect"></a>http_connect</h2><p>本类提供以下成员函数</p><h3 id="void-http-connect-initmysql-result-connection-pool-connPool"><a href="#void-http-connect-initmysql-result-connection-pool-connPool" class="headerlink" title="void http_connect::initmysql_result(connection_pool* connPool)"></a><code>void http_connect::initmysql_result(connection_pool* connPool)</code></h3><p>初始化对象的mysql连接，并将用户数据库数据读入到外部变量查找表users中。  </p><h3 id="void-http-connect-close-conn"><a href="#void-http-connect-close-conn" class="headerlink" title="void http_connect::close_conn()"></a><code>void http_connect::close_conn()</code></h3><p>关闭一个连接</p><h3 id="void-http-connect-init-int-sockfd-const-sockaddr-in-amp-addr-char-root-int-TRIGMode-int-close-log-string-user-string-passwd-string-sqlname"><a href="#void-http-connect-init-int-sockfd-const-sockaddr-in-amp-addr-char-root-int-TRIGMode-int-close-log-string-user-string-passwd-string-sqlname" class="headerlink" title="void http_connect::init(int sockfd, const sockaddr_in &amp;addr, char *root, int TRIGMode,int close_log, string user, string passwd, string sqlname)"></a><code>void http_connect::init(int sockfd, const sockaddr_in &amp;addr, char *root, int TRIGMode,int close_log, string user, string passwd, string sqlname)</code></h3><p>初始化连接：  </p><ol><li>将文件描述符添加到内核事件表中（addfd()）；  </li><li>设置http响应方式；  </li><li>设置日志是否关闭；  </li><li>设置数据库信息；  </li><li>调用init()初始化状态信息以及缓冲区。  </li></ol><h3 id="void-http-connect-init"><a href="#void-http-connect-init" class="headerlink" title="void http_connect::init()"></a><code>void http_connect::init()</code></h3><p>初始化http_connect对象的各种信息以及缓冲区。  </p><h3 id="http-connect-LINE-STATUS-http-connect-parse-line"><a href="#http-connect-LINE-STATUS-http-connect-parse-line" class="headerlink" title="http_connect::LINE_STATUS http_connect::parse_line()"></a><code>http_connect::LINE_STATUS http_connect::parse_line()</code></h3><p>状态机，用于分析出一行内容，返回值为行的读取状态，有LINE_OK,LINE_BAD,LINE_OPEN</p><h3 id="bool-http-connect-read-once"><a href="#bool-http-connect-read-once" class="headerlink" title="bool http_connect::read_once()"></a><code>bool http_connect::read_once()</code></h3><p>读取客户数据，直到数据读取完毕或者无数据可读。  </p><ol><li>读缓冲区用完，返回false；  </li><li>选择读取方式LT或者ET；  </li><li>选择LT模式则只调用一次recv读取数据，并返回；  </li><li>选择ET模式则循环调用recv直到读取完毕或者发生错误；  </li></ol><h3 id="http-connect-HTTP-CODE-http-connect-parse-request-line"><a href="#http-connect-HTTP-CODE-http-connect-parse-request-line" class="headerlink" title="http_connect::HTTP_CODE http_connect::parse_request_line()"></a><code>http_connect::HTTP_CODE http_connect::parse_request_line()</code></h3><p>读取http请求报文，并解析返回状态码。  </p><ol><li>检测是否是有效http请求，否则返回BAD_REQUEST；  </li><li>读取url和http版本；  </li><li>确认是否为主界面url（登陆/注册）；  </li><li>修改请求行状态m_check_state为CHECK_STATE_HEADER并返回NO_REQUEST;</li></ol><h3 id="http-connect-HTTP-CODE-http-connect-parse-headers-char-text"><a href="#http-connect-HTTP-CODE-http-connect-parse-headers-char-text" class="headerlink" title="http_connect::HTTP_CODE http_connect::parse_headers(char *text)"></a><code>http_connect::HTTP_CODE http_connect::parse_headers(char *text)</code></h3><p>解析一个http请求的首部行信息。  </p><ol><li>为空则返回GET_REQUESt；    </li><li>匹配Connection（长连接或者短连接）；    </li><li>匹配Content-length（实体部分长度）；  </li><li>匹配Host（客户主机）；  </li><li>如果前面无法匹配，则向日志写入信息；  </li><li>返回NO_REQUEST。  </li></ol><h3 id="http-connect-HTTP-CODE-http-connect-parse-content-char-text"><a href="#http-connect-HTTP-CODE-http-connect-parse-content-char-text" class="headerlink" title="http_connect::HTTP_CODE http_connect::parse_content(char *text)"></a><code>http_connect::HTTP_CODE http_connect::parse_content(char *text)</code></h3><p>判断http请求是否被完整的读入缓冲区。</p><h3 id="http-connect-HTTP-CODE-http-connect-process-read"><a href="#http-connect-HTTP-CODE-http-connect-process-read" class="headerlink" title="http_connect::HTTP_CODE http_connect::process_read()"></a><code>http_connect::HTTP_CODE http_connect::process_read()</code></h3><ol><li>定位到读缓冲区内开始位置；  </li><li>修改开始位置到m_checked_idx；  </li><li>判断http请求的读取状态；  </li><li>如果是正在解析请求行，则调用parse_request_line()；  </li><li>如果是正在解析首部行，则调用parse_headers(text)，若返回GET_REQUEST则调用do_request()执行响应；  </li><li>如果是正在解析实体，则调用parse_content()，若返回GET_REQUEST则调用do_request()执行响应，者之LINE_OPEN；  </li><li>如果都不是，返回内部错误。  </li></ol><h3 id="void-http-connect-unmap"><a href="#void-http-connect-unmap" class="headerlink" title="void http_connect::unmap()"></a><code>void http_connect::unmap()</code></h3><p>释放读入到内存的被请求资源。</p><h3 id="bool-http-connect-add-reponse-const-char-format"><a href="#bool-http-connect-add-reponse-const-char-format" class="headerlink" title="bool http_connect::add_reponse(const char *format, ...)"></a><code>bool http_connect::add_reponse(const char *format, ...)</code></h3><p>向要返回的报文中添加响应，即写入缓冲区中。<br>还有相关函数<code>add_status_line()</code>、<code>add_headers()</code>、<code>add_content()</code>，分别表示写入状态行，写入首部行，写入实体。</p><h3 id="bool-http-connect-process-write-HTTP-CODE-ret"><a href="#bool-http-connect-process-write-HTTP-CODE-ret" class="headerlink" title="bool http_connect::process_write(HTTP_CODE ret)"></a><code>bool http_connect::process_write(HTTP_CODE ret)</code></h3><p>写事件处理函数，通过调用本函数来实现对返回HTTP报文的写。</p><h3 id="void-http-connect-process"><a href="#void-http-connect-process" class="headerlink" title="void http_connect::process()"></a><code>void http_connect::process()</code></h3><p>读取或写入数据，并向内核事件表注册IO就绪事件。</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p><code>threadpool.h</code>实现了threadpool类，该类能够提供多线程的http服务。</p><h2 id="threadpool类"><a href="#threadpool类" class="headerlink" title="threadpool类"></a>threadpool类</h2><p>提供了如下成员函数：</p><h3 id="threadpool-threadpool"><a href="#threadpool-threadpool" class="headerlink" title="threadpool::threadpool(...)"></a><code>threadpool::threadpool(...)</code></h3><p>构造函数，初始化对象参数并且创建线程(将线程设置成分离的)。</p><h3 id="threadpool-threadpool-1"><a href="#threadpool-threadpool-1" class="headerlink" title="threadpool::~threadpool()"></a><code>threadpool::~threadpool()</code></h3><p>释放线程数组资源。</p><h3 id="bool-threadpool-append-reactor-http-connect-request-int-state"><a href="#bool-threadpool-append-reactor-http-connect-request-int-state" class="headerlink" title="bool threadpool::append_reactor(http_connect *request, int state)"></a><code>bool threadpool::append_reactor(http_connect *request, int state)</code></h3><p>将一个http_connect对象添加到请求队列中（Reactor模式）。</p><h3 id="bool-threadpool-append-proactor-http-connect-request"><a href="#bool-threadpool-append-proactor-http-connect-request" class="headerlink" title="bool threadpool::append_proactor(http_connect *request)"></a><code>bool threadpool::append_proactor(http_connect *request)</code></h3><p>将一个http_connect对象添加到请求队列中（Proactor模式）。</p><h3 id="void-threadpool-worker-void-arg"><a href="#void-threadpool-worker-void-arg" class="headerlink" title="void *threadpool::worker(void* arg)"></a><code>void *threadpool::worker(void* arg)</code></h3><p>线程函数，调用run()函数。</p><h3 id="void-threadpool-run"><a href="#void-threadpool-run" class="headerlink" title="void threadpool::run()"></a><code>void threadpool::run()</code></h3><ol><li>从请求队列读取http_connect对象；  </li><li>判断事件处理模式；  </li><li>如果是Reactor模式则进行I/O操作并向内核注册写事件就绪；  </li><li>如果是Proactor模式则调用process()处理。</li></ol><h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><p><code>webserver.h</code>、<code>webserver.cc</code>定义并且实现了服务器类webserver，该类是本项目最核心的类，所有类围绕webserver提供服务。</p><h1 id="webserver类"><a href="#webserver类" class="headerlink" title="webserver类"></a>webserver类</h1><h3 id="void-init-int-string-string-string-int-int-int-int-int-int-int"><a href="#void-init-int-string-string-string-int-int-int-int-int-int-int" class="headerlink" title="void init(int,string,string,string,int,int,int,int,int,int,int)"></a><code>void init(int,string,string,string,int,int,int,int,int,int,int)</code></h3><p>初始化相关参数，包括服务器端口、数据库用户名、数据库密码等等。</p><h3 id="void-thread-pool"><a href="#void-thread-pool" class="headerlink" title="void thread_pool()"></a><code>void thread_pool()</code></h3><p>初始化线程池</p><h3 id="void-sql-pool"><a href="#void-sql-pool" class="headerlink" title="void sql_pool()"></a><code>void sql_pool()</code></h3><p>初始化数据库连接池</p><h3 id="void-log-write"><a href="#void-log-write" class="headerlink" title="void log_write()"></a><code>void log_write()</code></h3><p>初始化日志类，并且打开一个日志文件</p><h3 id="void-trig-mode"><a href="#void-trig-mode" class="headerlink" title="void trig_mode"></a><code>void trig_mode</code></h3><p>设置监听套接字和已连接套接字的触发模式（LT/ET）</p><h3 id="void-eventListen"><a href="#void-eventListen" class="headerlink" title="void eventListen()"></a><code>void eventListen()</code></h3><p>事件监听函数：<br>1）打开一个监听套接字<br>2）设置这个监听套接字的相关参数<br>3）设置Uilts类成员utils<br>4）创建epoll内核事件表<br>5）向utils添加套接字事件（包括设置定时器和将套接字和epoll关联起来）<br>6）创建通信管道，并将读管道和epoll关联起来<br>7）将管道变量、epoll套接字描述符赋值给Utils<br>8）设置信号SIGPIPE、SIGALRM、SIGTERM的处理<br>9）发出SIGALRM信号</p><h3 id="void-eventLoop"><a href="#void-eventLoop" class="headerlink" title="void eventLoop()"></a><code>void eventLoop()</code></h3><p>事件循环函数。<br>1）调用<code>epoll_wait()</code>等待IO事件发生。<br>2）处理事件：<br>如果是监听套接字，则处理监听数据。<br>如果对应文件描述符断开连接/发生错误，则阐述对应的管理类（定时器），调用deal_timer()。<br>如果是信号管道的读端口且有可读事件发生，则调用信号处理函数，并返回服务器停止、超时信息。<br>如果是读事件，处理客户连接上的读事件（dealwithdata）。<br>如果是写事件，处理客户连接上的写事件（dealwithwrite）。<br>3）如果超时，则调用utils的定时任务，并输出日志信息</p><h3 id="void-timer-int-connfd-struct-sockaddr-in，client-address"><a href="#void-timer-int-connfd-struct-sockaddr-in，client-address" class="headerlink" title="void timer(int connfd, struct sockaddr_in，client_address)"></a><code>void timer(int connfd, struct sockaddr_in，client_address)</code></h3><p>1）初始化套接字对应的http连接类<br>2）初始化定时器，并加入定时器链表</p><h3 id="void-adjust-timer-util-timer-timer"><a href="#void-adjust-timer-util-timer-timer" class="headerlink" title="void adjust_timer(util_timer *timer)"></a><code>void adjust_timer(util_timer *timer)</code></h3><p>修改定时器终止时间，调整定时器在链表中的位置。</p><h3 id="void-deal-timer-util-timer-timer-int-sockfd"><a href="#void-deal-timer-util-timer-timer-int-sockfd" class="headerlink" title="void deal_timer(util_timer *timer, int sockfd)"></a><code>void deal_timer(util_timer *timer, int sockfd)</code></h3><p>删除定时器，关闭套接字。</p><h3 id="bool-dealclinetdata"><a href="#bool-dealclinetdata" class="headerlink" title="bool dealclinetdata()"></a><code>bool dealclinetdata()</code></h3><p>1）接收客户端连接，其中有LT/ET模式可选。<br>2）在http连接管理类、定时器管理类中初始化这个连接。</p><h3 id="bool-dealwithsignal-bool-amp-timeout-bool-amp-stop-server"><a href="#bool-dealwithsignal-bool-amp-timeout-bool-amp-stop-server" class="headerlink" title="bool dealwithsignal(bool &amp;timeout, bool &amp;stop_server)"></a><code>bool dealwithsignal(bool &amp;timeout, bool &amp;stop_server)</code></h3><p>1）从管道读取信号到缓冲区。<br>2）处理SIGARM信号（返回timeout信息）<br>3）处理终止信号（返回stop_server信息）</p><h3 id="void-dealwithread-int-sockfd"><a href="#void-dealwithread-int-sockfd" class="headerlink" title="void dealwithread(int sockfd)"></a><code>void dealwithread(int sockfd)</code></h3><p>提供了Reactor和Proacotr两种事件处理模式。<br>Reactor：<br>调整定时器。<br>将事件放入请求队列。<br>Proactor：<br>读取数据，若读取失败调用deal_timer()，读取成功则将事件添加进入请求队列，调整定时器（adjust_timer）。</p><h3 id="void-dealwithwrite-int-sockfd"><a href="#void-dealwithwrite-int-sockfd" class="headerlink" title="void dealwithwrite(int sockfd)"></a><code>void dealwithwrite(int sockfd)</code></h3><p>提供了Reactor和Proacotr两种事件处理模式。<br>Reactor：<br>调整定时器。<br>将事件放入请求队列。<br>Proactor：<br>读取数据，若读取失败调用deal_timer()，读取成功则将事件添加进入请求队列，调整定时器（adjust_timer）。</p><h1 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h1><p>服务器项目仅仅只是完成项目还是不够的，我们还需要进行压力测试来检验这个服务器的性能如何，只要经过了压力测试，才说说明这个服务器是稳定的。</p><h2 id="Webbench"><a href="#Webbench" class="headerlink" title="Webbench"></a>Webbench</h2><p>在本项目中我使用Webbench来进行压力测试。Webbench是知名的网站压力测试工具，它是由<a href="http://www.51testing.com/">Lionbridge公司</a>开发。Webbench能测试处在相同硬件上，不同服务的性能以及不同硬件上同一个服务的运行状况。webbench的标准测试可以向我们展示服务器的两项内容：每秒钟相应请求数和每秒钟传输数据量。webbench不但能具有便准静态页面的测试能力，还能对动态页面（ASP,PHP,JAVA,CGI）进 行测试的能力。还有就是他支持对含有SSL的安全网站例如电子商务网站进行静态或动态的性能测试。Webbench最多可以模拟3万个并发连接去测试网站的负载能力。</p>]]></content>
      
      
      <categories>
          
          <category> Linux C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>构建Web内容的技术</title>
      <link href="2021/02/12/%E6%9E%84%E5%BB%BAWeb%E5%86%85%E5%AE%B9%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
      <url>2021/02/12/%E6%9E%84%E5%BB%BAWeb%E5%86%85%E5%AE%B9%E7%9A%84%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="Web页面几乎全由HTML构建"><a href="#Web页面几乎全由HTML构建" class="headerlink" title="Web页面几乎全由HTML构建"></a>Web页面几乎全由HTML构建</h2><p>HTML（HypeTest Markup Language，超文本标记语言）是为了发送Web上的超文本而开发的标记语言。超文本是一种文档系统，可将文档中任意位置的信息与其他嘻嘻你系建立关联，即超链接文本。标记语言是指通过在文档的某部分穿插特别的字符串标签，用来修饰文档的语言。我们把出现在HTML文档内的这种特殊字符串叫做HTML标签（Tag）。</p><h2 id="涉及应用CSS"><a href="#涉及应用CSS" class="headerlink" title="涉及应用CSS"></a>涉及应用CSS</h2><p>CSS（Cascading Style 层叠样式表）可以指定如何展现HTML内的各种元素，属于样式表标准之一。即使是相同的HTML文档，通过改变应用的CSS，用浏览器看到页面外观也会随之改变。CSS的理念就是让文档的结构和设计分离，达到解耦的目的。  </p><h1 id="动态HTML"><a href="#动态HTML" class="headerlink" title="动态HTML"></a>动态HTML</h1><p>所谓动态HTML，是指使用客户端脚本语言将静态的HTML内容变为动态技术的总称。鼠标单击点开的新闻、Google Maps等可滚动的地图就用到了动态HTML。  </p><h1 id="Web应用"><a href="#Web应用" class="headerlink" title="Web应用"></a>Web应用</h1><h2 id="通过Web提供功能的Web应用"><a href="#通过Web提供功能的Web应用" class="headerlink" title="通过Web提供功能的Web应用"></a>通过Web提供功能的Web应用</h2><p>Web应用是指通过Web功能提供的应用程序。比如购物网站、网上银行等。</p><h2 id="与Web服务器及程序协作的CGI"><a href="#与Web服务器及程序协作的CGI" class="headerlink" title="与Web服务器及程序协作的CGI"></a>与Web服务器及程序协作的CGI</h2><p>CGI（Common Gateway Interface，通用网关接口）是指Web服务器在接收到客户端发送过来的请求后转发给程序的一组机制。在CGI的作用下，程序会对请求内容做出相应的动作，比如创建HTML等动态内容。<br>使用CGI的程序叫做CGI程序，通常是Perl、PHP、Ruby和C等编程语言编写而成。</p><h1 id="数据发布的格式及语言"><a href="#数据发布的格式及语言" class="headerlink" title="数据发布的格式及语言"></a>数据发布的格式及语言</h1><h2 id="可扩展标记语言"><a href="#可扩展标记语言" class="headerlink" title="可扩展标记语言"></a>可扩展标记语言</h2><p>XML（Extensible Markup Language，可扩展标记语言）是一种可按应用目标进行扩展的通用标记语言。旨在通过使用XML，使互联网数据共享更容易。<br>XML和HTML都是从通用标记语言SGML简化而成的。与HTML相比，它对数据的记录方式做了特殊处理。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP与HTTPS</title>
      <link href="2021/02/09/HTTP%E4%B8%8EHTTPS/"/>
      <url>2021/02/09/HTTP%E4%B8%8EHTTPS/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h1><p>为了传输方便，在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分割，并在各个报文上打上标记序号及端口号转发给网络层。<br>在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。这样一来，发往玩过的通信请求就准备齐全了。<br>接收端的服务器在链路层接收到数据，按序往上层发送，一直刀应用层。<br>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层之间传输数据时，没经过一层时都会把对应的首部消去。  </p><h2 id="负责传输的IP协议"><a href="#负责传输的IP协议" class="headerlink" title="负责传输的IP协议"></a>负责传输的IP协议</h2><p>IP协议的作用是把各种数据包传送给对方。保证确实传送刀对方那里，则需要满足各类条件。其中两个重要的条件是IP地址和MAC地址。</p><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本不会更改。  </p><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>IP间的通信依赖MAC地址。在网络上，通信的双方在同一局域网（LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的MAC地址来搜索下一个中转目标。这时，会采用ARP协议。ARP协议是一种用以解析地址的协议，根据通信双方的IP地址就可以反查出对应的MAC地址。  </p><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>按层次分，TCP位于传输层，提供可靠的字节流服务。所谓字节流服务是指，为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理。而可靠数据服务是指，能够把数据准确可靠地传输给对方。一言以蔽之，TCP协议为了更容易传送大数据才把数据分割，而且TCP协议能够确认数据最终是否送达对方。  </p><h3 id="负责域名解析的DNS服务"><a href="#负责域名解析的DNS服务" class="headerlink" title="负责域名解析的DNS服务"></a>负责域名解析的DNS服务</h3><p>DNS服务是和HTTP协议一样位于应用层的协议。它提供域名到IP地址的解析服务。  </p><h3 id="各种协议与HTTP协议的关系"><a href="#各种协议与HTTP协议的关系" class="headerlink" title="各种协议与HTTP协议的关系"></a>各种协议与HTTP协议的关系</h3><p>如果我们想浏览<a href="http://xxx.com/">http://xxx.com/</a> Web页面，过程如下：<br>想DNS服务器请求xxx.com的IP地址，DNS服务器返回xxx.com对应的IP地址20X.189.105.112；<br>HTTP协议：生成针对目标Web服务器的HTTP请求报文；<br>TCP协议：将报文分割成报文段，把每个报文可靠地传输给对方。<br>IP协议：搜索地方的地址，一边中转一边传送；<br>TCP协议：从对方那里接收到报文段，按序号重组请求报文；<br>HTTP协议：对Web服务器请求的内容处理；<br>请求的结果按照TCP/IP通信协议向用户进行回传。  </p><h1 id="统一资源标识符"><a href="#统一资源标识符" class="headerlink" title="统一资源标识符"></a>统一资源标识符</h1><p>URI是Uniform Resource Identifier的缩写。URI用字符串标识某一互联网资源，而URL标识资源的地址。URL是URI的子集。  </p><h2 id="URI格式"><a href="#URI格式" class="headerlink" title="URI格式"></a>URI格式</h2><p>例子：<code>http://user:pass@www.example.jp:80/dir/index.htm?uid=1#ch1</code><br><code>http://</code>：协议方案名；<br><code>user:pass</code>：登录信息（认证）；<br><code>www.example.jp</code>：服务器地址；<br><code>80</code>：服务器端口号；<br><code>dir/index.htm</code>：带层次的文件路径；<br><code>uid=1</code>：查询字符串，可用于传入参数；<br><code>ch1</code>：片段标识符。  </p><h1 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h1><h2 id="请求报文格式"><a href="#请求报文格式" class="headerlink" title="请求报文格式"></a>请求报文格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 请求行：请求方法+URI+协议版本</span><br><span class="line">POST &#x2F;form&#x2F;entry HTTP&#x2F;1.1</span><br><span class="line">&#x2F;&#x2F; 首部行</span><br><span class="line">Host: hackr.jp</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 16</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 内容实体</span><br><span class="line">name&#x3D;ueno&amp;age&#x3D;37</span><br></pre></td></tr></table></figure><h2 id="响应报文格式"><a href="#响应报文格式" class="headerlink" title="响应报文格式"></a>响应报文格式</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 状态行：协议版本+状态码+状态码原因短语</span><br><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line">// 首部行</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Tue, 10 Jul 2012 06:50:15 GMT</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>362</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"></span><br><span class="line">// 内容实体</span><br><span class="line">&lt;html&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><p><strong>GET</strong>：获取资源；<br><strong>POST</strong>：传输实体的主体；<br><strong>PUT</strong>：传输文件；<br><strong>HEAD</strong>：获得报文首部，用于确认URI的有效性和资源更新的日期时间等；<br><strong>DELETE</strong>：删除文件，是与PUT相反的方法。DELETE方法按请求URI删除指定的资源；<br><strong>OPTIONS</strong>：询问支持的方法，用来查询针对请求URI指定的资源支持的方法。<br><strong>TRACE</strong>：追踪路径；<br><strong>CONNECT</strong>：要求用隧道协议连接代理，实现用隧道协议进行TCP通信，主要使用SSL（Secure Sockets Layer）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。  </p><h2 id="Cookie技术"><a href="#Cookie技术" class="headerlink" title="Cookie技术"></a>Cookie技术</h2><p>由于HTTP协议是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。<br>Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。<br>Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。<br>当客户端再次往该服务器发送该请求时，客户端会自动在请求报文中加如Cookie值后发送出去。<br>服务器端发现客户端发送过来的Cookie后，回去检查究竟是从哪个客户端发送来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。  </p><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><table>  <tr>    <th></th>    <th>类别</th>    <th>原因短语</th>  </tr>  <tr>    <td>1XX</td>    <td>Informational（信息性状态码）</td>    <td>接收的请求正在处理</td>  </tr>  <tr>    <td>2XX</td>    <td>Sucess（成功状态码）</td>    <td>请求正常处理完毕</td>  </tr>  <tr>    <td>3XX</td>    <td>Redirection（重定向状态码）</td>    <td>需要附加操作以完成请求</td>  </tr>  <tr>    <td>4XX</td>    <td>Client Error（客户端错误状态码）</td>    <td>服务器无法处理请求</td>  </tr>  <tr>    <td>5XX</td>    <td>Server Error</td>    <td>服务器处理请求出错</td>  </tr></table><h3 id="2XX成功"><a href="#2XX成功" class="headerlink" title="2XX成功"></a>2XX成功</h3><h4 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h4><p>表示从客户端发来的请求在服务器端被正常处理了。</p><h4 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h4><p>该状态码表示服务器接收的请求已经处理，但是返回的响应报文不包含实体的主体部分。  </p><h4 id="206-Partial-Content"><a href="#206-Partial-Content" class="headerlink" title="206 Partial Content"></a>206 Partial Content</h4><p>表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定的范围的实体内容。  </p><h3 id="3XX重定向"><a href="#3XX重定向" class="headerlink" title="3XX重定向"></a>3XX重定向</h3><h4 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h4><p>永久性重定向。该状态码表示请求的资源已经分配了新的URI。</p><h4 id="302-Found"><a href="#302-Found" class="headerlink" title="302 Found"></a>302 Found</h4><p>临时重定向。状态码表示请求的资源已经被分配了新的URI，希望用于（本次）使用新的URI访问。  </p><h4 id="303-See-Other"><a href="#303-See-Other" class="headerlink" title="303 See Other"></a>303 See Other</h4><p>该状态码表示由于请求对应的资源存在另一个URI，应该使用GET方法定向获取请求的资源。  </p><h4 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h4><p>该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304状态码返回时，不包含任何响应的主体部分。304虽然被划分在3XX类别中，但是和重定向没有关系。  </p><h4 id="307-Temporary-Redirect"><a href="#307-Temporary-Redirect" class="headerlink" title="307 Temporary Redirect"></a>307 Temporary Redirect</h4><p>临时重定向，和302 Found有着相同的含义。  </p><h3 id="4XX客户端错误"><a href="#4XX客户端错误" class="headerlink" title="4XX客户端错误"></a>4XX客户端错误</h3><h4 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h4><p>该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。  </p><h4 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h4><p>该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。另外若之前已进行过1次请求，则表示用户认证失败。返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询（challenge）用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。  </p><h4 id="403-Forbbiden"><a href="#403-Forbbiden" class="headerlink" title="403 Forbbiden"></a>403 Forbbiden</h4><p>该状态码表明对请求资源的访问被服务器拒绝了。  </p><h4 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h4><p>该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。这个状态码非常常见。</p><h3 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h3><h4 id="500-Internet-Server-Error"><a href="#500-Internet-Server-Error" class="headerlink" title="500 Internet Server Error"></a>500 Internet Server Error</h4><p>该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的 bug 或某些临时的故障。  </p><h4 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h4><p>该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><h2 id="HTTP缺点"><a href="#HTTP缺点" class="headerlink" title="HTTP缺点"></a>HTTP缺点</h2><ul><li>通信使用明文，内容可能会被窃听；  </li><li>不验证通信方的身份，因此有可能遭遇伪装；  </li><li>无法证明报文的完整性，所以有可能已遭篡改。  </li></ul><h2 id="加密方式"><a href="#加密方式" class="headerlink" title="加密方式"></a>加密方式</h2><h3 id="通信的加密"><a href="#通信的加密" class="headerlink" title="通信的加密"></a>通信的加密</h3><p>一种加密方式就是将通信加密。HTTP协议中没有加密机制，但可以通过和SSL（Secure Socket Layer，安全套接层）或TLS的组合使用，加密HTTP的通信内容。  </p><p>用SSL建立安全通信线路之后，就可以在这条线路上进行HTTP通信了。与SSL组合使用的HTTP被称为HTTPS（HTTP Secure，超文本传输安全协议）。  </p><h3 id="内容的加密"><a href="#内容的加密" class="headerlink" title="内容的加密"></a>内容的加密</h3><p>还有一种将参与通信的内容本身加密的方式。由于HTTP协议中没有加密机制，那么就对HTTP报文进行加密处理后再发送请求。  </p><h2 id="HTTPS是身披SSL外壳的HTTP"><a href="#HTTPS是身披SSL外壳的HTTP" class="headerlink" title="HTTPS是身披SSL外壳的HTTP"></a>HTTPS是身披SSL外壳的HTTP</h2><p>SSL是独立于HTTP的协议，所以不光是HTTP协议，其他运行在应用层的SMTP和Tenet等协议均可配合SSL协议使用。可以说SSL是当今世界上应用最为广泛的网络安全技术。</p><h2 id="相互交换密钥的公开密钥加密技术"><a href="#相互交换密钥的公开密钥加密技术" class="headerlink" title="相互交换密钥的公开密钥加密技术"></a>相互交换密钥的公开密钥加密技术</h2><p>SSL采用一个种叫做公开密钥加密的加密处理方式。</p><ul><li>共享密钥加密：<br>加密和解密使用同一个密钥的方式称为共享密钥加密，也被称为对称密钥加密。<br>但是问题是如何安全地将密钥发给对方？如果中间被攻击者获得，这种加密方式也会失去意义。  </li><li>使用两把密钥的公开密钥加密：<br>公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，一把叫做公开密钥。<br>使用公开密钥加密的方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。  </li><li>HTTPS采用混合加密机制：<br>由于非对称的加密方式较慢，所以可以混合使用上述两种加密方式，先利用非对称加密方式将共享密钥发送给对方，然后之后利用共享密钥加密报文。</li></ul><h2 id="HTTPS握手过程"><a href="#HTTPS握手过程" class="headerlink" title="HTTPS握手过程"></a>HTTPS握手过程</h2><p>握手主要分为三步：  </p><ol><li>客户端发起连接，创建一个条TCP连接（三次握手）；  </li><li>验证服务端Server是真实的Server；  </li><li>发送给Server一个主密钥，然后双方持有该主密钥生成SSL会话所需要的所有对称密钥。<br>假设服务端为Alice，客户端为Bob，那么一旦建立TCP连接，Bob就向Alice发送一个hello报文，Alice则用她的证书进行响应，证书中包含她的公钥。因为该证书已被CA证实过，Bob准确无误地知道该公钥属于Alice。然后Bob产生一个主密钥用Alice的公钥加密该主密钥然后发送给Alice，Alice用她的私钥解密出该公钥，之后双方用此密钥进行加密通信。</li></ol><h1 id="HTTP协议和HTTPS协议区别如下"><a href="#HTTP协议和HTTPS协议区别如下" class="headerlink" title="HTTP协议和HTTPS协议区别如下"></a>HTTP协议和HTTPS协议区别如下</h1><ol><li>HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是经过TLS加密后的，HTTPS具有更高的安全性；  </li><li>HTTPS在TCP三次握手阶段之后，还需要进行SSL 的handshake，协商加密使用的对称加密密钥；  </li><li>HTTPS协议需要服务端申请证书，浏览器端安装对应的根证书；  </li><li>HTTP协议端口是80，HTTPS协议端口是443。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>I/O多路复用</title>
      <link href="2021/02/05/ET-LT%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/02/05/ET-LT%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>I/O多路复用是一种机制：一个进程监听多个描述符，一旦一个某个描述符就绪（读就绪或者写就绪），通知进程进行相应的读写操作。<br>这个机制在Linux中有3个常见实现（select、poll、epoll），但是他们本质都是同步I/O，因为他们都需要在读写事件就绪后自己负责读写。而异步I/O不需要负责读写，异步I/O的实现会负责将数据从内核空间拷贝到内核空间。  </p><h2 id="Select机制"><a href="#Select机制" class="headerlink" title="Select机制"></a>Select机制</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;<span class="comment">//清空一个fdset</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;<span class="comment">//添加一个fd进入fdset</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CTR</span><span class="params">(<span class="keyword">int</span> fd,fd_set *fdset)</span></span>;<span class="comment">//从fdset删除一个fd</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;<span class="comment">//判断fdset里面是否有某个fd</span></span><br></pre></td></tr></table></figure><p>select函数监听的文件描述符分3类，分别是writefds、readfds和exceptfds。调用后select函数会阻塞，知道有描述符就绪，或者超时，函数返回。当select函数返回后，可以通过遍历fdset来找到就绪的描述符。<br>select目前在几乎所有平台上支持，其良好的跨平台支持也是它的一个优点。缺点就是单个进程能够监听的描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义来提升这一限制，但是会降低效率。</p><h2 id="Poll机制"><a href="#Poll机制" class="headerlink" title="Poll机制"></a>Poll机制</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>; </span><br></pre></td></tr></table></figure><p>不同于select使用3个位图来表示3个fdset的方式，poll使用一个pollfd的指针实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">short</span> events;</span><br><span class="line">   <span class="keyword">short</span> revents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递方式。同时，pollfd并没有最大数量限制（但是数量大了性能变差）。和select一样，poll返回后需要轮询pollfd来获取就绪的描述符。</p><p>从上面的例子看，select和poll都需要在返回后同遍历文件描述符来获取已经就绪的socket。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监听的描述符数量增长，其效率线性下降。</p><h2 id="Epoll"><a href="#Epoll" class="headerlink" title="Epoll"></a>Epoll</h2><p>epoll是select和poll的增强版本。epoll更加灵活，没有数量限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放在内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。  </p><h3 id="Epoll具体使用"><a href="#Epoll具体使用" class="headerlink" title="Epoll具体使用"></a>Epoll具体使用</h3><p>epoll操作过程需要3个接口，分别如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>epoll_create()</code>创建一个epoll句柄，size用来告诉内核这个监听的数目一共多大，这个参数无法限制epoll监听的最大数目，而是给出一个建议。 epoll句柄会占用一个fd值。 </li><li><code>epoll_ctl()</code>对指定的描述符fd执行op操作，可以添加（EPOLL_CTL_ADD）/删除（EPOLL_CTL_DEL）/修改（EPOLL_CTL_MOD）对fd的监听事件。event是告诉我们内核需要监听数目事件。<code>struct epoll_event</code>结构如下所示：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>&#123;</span></span><br><span class="line"><span class="keyword">_uint32_t</span> events;<span class="comment">/* Epoll events */</span></span><br><span class="line">   <span class="keyword">epoll_data_t</span> data;  <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//events可以表示为以下几个宏的集合</span></span><br><span class="line">EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</span><br><span class="line">EPOLLOUT：表示对应的文件描述符可以写；</span><br><span class="line">EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span><br><span class="line">EPOLLERR：表示对应的文件描述符发生错误；</span><br><span class="line">EPOLLHUP：表示对应的文件描述符被挂断；</span><br><span class="line">EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</span><br><span class="line">EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里 </span><br></pre></td></tr></table></figure><ul><li><code>epoll_wait()</code>等待epfd上的I/O事件，最多返回maxevents个事件。参数events用来从内核得到事件的集合，maxevents告知内核这个events有多大。</li></ul><h3 id="Epoll底层机制"><a href="#Epoll底层机制" class="headerlink" title="Epoll底层机制"></a>Epoll底层机制</h3><p>Epoll在内核维护了两个数据结构，一个红黑树用来存储监听IO事件的fd，另一个用来存储IO事件的双链表。红黑树能够提供高效的fd查找、修改、删除操作（<code>epoll_ctl()</code>）。一旦某个fd发生了IO事件，就会触发fd的回调函数，将事件添加到双链表中。而<code>epoll_wait()</code>只需要检查链表是否为空即可，不为空等待返回，否则等待IO事件发生触发回调函数。  </p><h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><p>epoll对文件描述符有两种工作模式：<strong>LT（level trigger，水平触发）和ET（edge trigger，边沿触发）</strong>：LT模式是默认模式，LT模式与ET模式区别如下所示：<br><strong>LT</strong>：当epoll检测到描述符事件发生并将此事件通知主程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。<br><strong>ET模式</strong>：当epoll_wait()检测到描述符事件发生并将此事件通知注应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait()时，不会再次响应应用程序并通知此事件。  </p><h3 id="LT模式"><a href="#LT模式" class="headerlink" title="LT模式"></a>LT模式</h3><p>LT是epoll默认的工作方式，支持阻塞和非阻塞两种机制。LT模式下内核会持续通知你文件描述符就绪了，然后你可以对这个就绪的fd进行I/O操作。如果不做任何操作，内核还是会继续通知你的。  </p><h3 id="ET模式"><a href="#ET模式" class="headerlink" title="ET模式"></a>ET模式</h3><p>ET模式相对LT模式更加高效，只支持非阻塞模式。在这个模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不再为那个文件描述符发生更多的就绪通知。直到你做了某些操作导致那个文件描述符不再为就绪状态了。<br>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式时，必须使用非阻塞套接口，以避免一个文件句柄的阻塞导致把其他文件描述符饿死。  </p><h2 id="Epoll总结"><a href="#Epoll总结" class="headerlink" title="Epoll总结"></a>Epoll总结</h2><p>在select/poll中，进程只有在调用一定的方法后才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()注册一个文件描述符，一旦某个文件描述符就绪时，内核会采取回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。  </p><p>epoll的优点主要是以下几个方面：  </p><ol><li>监听的文件描述符不受限制，它所支持的fd上限是最大可打开文件数目；  </li><li>I/O效率不会随着监听的文件描述符规模增大而下降。不同于select/poll轮询的方式，epoll通过每个fd定义的回调函数来实现。只有就绪的fd才会执行回调函数。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>I/O复用</title>
      <link href="2021/02/04/IO%E5%A4%8D%E7%94%A8/"/>
      <url>2021/02/04/IO%E5%A4%8D%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="I-O模型介绍"><a href="#I-O模型介绍" class="headerlink" title="I/O模型介绍"></a>I/O模型介绍</h1><p>同步和异步、阻塞和非阻塞在I/O操作中总是容易分不清楚。<br>I/O操作可以分为：发起I/O请求，执行I/O操作，得到I/O操作结果，返回结果。  </p><h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>同步和异步实际上是一种通信机制，涉及调用方和被调用方。<br><strong>同步</strong>：调用方等待被调用方完成操作然后返回结果；<br><strong>异步</strong>：调用方不需要等待调用方操作，而是被调用方自己操作完成后通知调用方。<br>同步和异步适合用于描述I/O操作的执行部分。</p><h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>阻塞和非阻塞其实是一种调用机制，只涉及调用方，关注的是I/O操作的执行状态，不同点在于请求I/O操作后，针对I/O操作，被调用方的行为。<br>如果调用方等待IO操作完成后返回，则是阻塞的；如果调用方不需要等待I/O操作完成就立即返回，则是非阻塞的，非阻塞的情况下，常常需要多次调用去检查，才能获得I/O操作的结果。</p><h2 id="I-O模型总结"><a href="#I-O模型总结" class="headerlink" title="I/O模型总结"></a>I/O模型总结</h2><ol><li>阻塞I/O<br>当发生系统调用时候，比如recv，用户进程要一直等待到数据拷贝到用户空间，这段时间内进程始终阻塞。它是同步I/O。  </li><li>非阻塞I/O<br>还是以recv为例子，不管有没有数据都返回，如果没有数据，过一会再调用recv看看，如此循环。但是如果有数据，它要等待数据拷贝到用户空间，因此还是同步I/O。（相当于没有数据读的时候阻塞，读的时候还是非阻塞）  </li><li>I/O复用<br>同时监听多个文件描述符，当有可读/可写/异常事件发生的时候，通知进程，进行读写或者处理异常。当没有事件发生时候，正常运行。就当前例子来看还是同步I/O，因为依旧要等待数据读完或者写完才能继续运行。I/O复用可用于同步I/O也可用于异步I/O。</li><li>信号驱动的I/O模型<br>通过调用sigaction注册信号函数，等内核数据准备好的时候，系统中断当前程序，执行信号函数（在这里调用recv）。这还是同步I/O。</li><li>异步I/O模型<br>调用aio_read，让内核等数据准本好，并且复制到用户进程空间后执行实现指定好的函数。这样子省去了进程等待读数据的事件。这是真正的异步I/O。</li><li>I/O的两个阶段<br>内核数据的准备阶段和内核数据复制到用户缓冲区阶段。只有进程不用等待这两个阶段，才是真正的异步I/O。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>死锁</title>
      <link href="2021/02/04/%E6%AD%BB%E9%94%81/"/>
      <url>2021/02/04/%E6%AD%BB%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><h2 id="可抢占资源和不可抢占资源"><a href="#可抢占资源和不可抢占资源" class="headerlink" title="可抢占资源和不可抢占资源"></a>可抢占资源和不可抢占资源</h2><ul><li>可抢占资源：可以从拥有它的进程中抢占而不会产生任何副作用<br>可抢占资源不易产生死锁，因为这种潜在风险可以由进程之间资源的重新分配来化解。  </li><li>不可抢占资源：无法把它从占有它的进程处抢占过来。  </li></ul><h2 id="资源获取"><a href="#资源获取" class="headerlink" title="资源获取"></a>资源获取</h2><p>一种允许用户管理资源的方式是为每个资源配置一个信号量，我们看下面两个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore resource_1;</span><br><span class="line">semaphore resource_2;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">process_A</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">down</span>(&amp;resource_1);</span><br><span class="line"><span class="built_in">down</span>(&amp;resource_2);</span><br><span class="line"><span class="built_in">use_both_resources</span>();</span><br><span class="line"><span class="built_in">up</span>(&amp;resource_2);</span><br><span class="line"><span class="built_in">up</span>(&amp;resource_1);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">process_B</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="built_in">down</span>(&amp;resource_1);</span><br><span class="line"><span class="built_in">down</span>(&amp;resource_2);</span><br><span class="line"><span class="built_in">use_both_resources</span>();</span><br><span class="line"><span class="built_in">up</span>(&amp;resource_2);</span><br><span class="line"><span class="built_in">up</span>(&amp;resource_1);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>上面这个例子，不会发生死锁，而下面这个例子有可能出现死锁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore resource_1;</span><br><span class="line">semaphore resource_2;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">process_A</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">down</span>(&amp;resource_1);</span><br><span class="line"><span class="built_in">down</span>(&amp;resource_2);</span><br><span class="line"><span class="built_in">use_both_resources</span>();</span><br><span class="line"><span class="built_in">up</span>(&amp;resource_2);</span><br><span class="line"><span class="built_in">up</span>(&amp;resource_1);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">process_B</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="built_in">down</span>(&amp;resource_2);</span><br><span class="line"><span class="built_in">down</span>(&amp;resource_1);</span><br><span class="line"><span class="built_in">use_both_resources</span>();</span><br><span class="line"><span class="built_in">up</span>(&amp;resource_1);</span><br><span class="line"><span class="built_in">up</span>(&amp;resource_2);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="死锁概述"><a href="#死锁概述" class="headerlink" title="死锁概述"></a>死锁概述</h1><p>死锁的规范定义：<strong>如果一个进程集合中的每个进程集合都在等待只能由该进程集合中的其他进程才能引发的事件，那么该进程集合就是死锁的</strong>。  </p><h2 id="资源死锁的条件"><a href="#资源死锁的条件" class="headerlink" title="资源死锁的条件"></a>资源死锁的条件</h2><ol><li>互斥条件：每个资源要么已经分配给一个进程，要么可用；  </li><li>占有和等待条件：已经得到某个资源的进程可以再请求新的资源；  </li><li>不可抢占条件：一个资源已经分配给某个进程，那么只能由这个进程释放这个资源；  </li><li>环路等待条件：死锁发生时，系统中一定有两个或两个以上进程组成了一条环路，这个环路上每个进程都在等待下一个进程释放资源。  </li></ol><p>所以如果想避免死锁发生，我们可以从破坏这四个条件入手。  </p><h1 id="死锁检测和死锁恢复"><a href="#死锁检测和死锁恢复" class="headerlink" title="死锁检测和死锁恢复"></a>死锁检测和死锁恢复</h1><h2 id="每种类型一个资源的死锁检测"><a href="#每种类型一个资源的死锁检测" class="headerlink" title="每种类型一个资源的死锁检测"></a>每种类型一个资源的死锁检测</h2><p>用普通的检测有向图是否有环路的算法即可检测死锁。</p><h2 id="每种类型多个资源的死锁检测"><a href="#每种类型多个资源的死锁检测" class="headerlink" title="每种类型多个资源的死锁检测"></a>每种类型多个资源的死锁检测</h2><p>假设两个矩阵C、R，C(i,j)代表当前第i个进程对第j种资源占有个数，R(i,j)代表第i个进程还需要多少个j类资源。然后假设两个向量E、A，E(i)代表资源类型1的个数，A(i)代表资源类型i总共可用个数。那么我们可以用如下算法检测死锁：<br>死锁检测算法如下：<br>1）寻找一个没有标记的进程Pi，对于R矩阵而言第i行向量小于等于A；<br>2）如果找到了这样一个进程，那么将C矩阵的第i行向量加到A中，标记该进程，并转到第一步（可以理解为这个进程可以被分配资源然后完成再释放资源）；<br>3）如果没有找到这样的进程，算法终止。<br>算法结束时，没有被标记的进程都是死锁进程（如果有的话）。</p><h2 id="从死锁中恢复"><a href="#从死锁中恢复" class="headerlink" title="从死锁中恢复"></a>从死锁中恢复</h2><ol><li>利用抢占恢复：这通常需要人工干预。  </li><li>利用回滚恢复：周期性对进程进行检查，并将检查点检查也就是进程的状态写入一个文件以备以后重启（类似于日志）。一旦检测到死锁，那么就很容易发现需要哪些资源。为了进行恢复，要从一个较早的检查点开始，这样所有需要资源的进程会回滚到一个时间点，在此时间点之前该进程获得了一些其他的资源。在检查点之后的所有工作都会丢失。  </li><li>通过杀死进程恢复：注意不要杀死环外的进程。  </li></ol><h1 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h1><h2 id="安全状态和不完全状态"><a href="#安全状态和不完全状态" class="headerlink" title="安全状态和不完全状态"></a>安全状态和不完全状态</h2><p>如果没有死锁发生，且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称状态是安全的。  </p><p>安全状态下，系统能保证不发生死锁。不安全状态则没有这个保证。  </p><h2 id="单个资源的银行家算法"><a href="#单个资源的银行家算法" class="headerlink" title="单个资源的银行家算法"></a>单个资源的银行家算法</h2><p>算法：判断对请求的满足是否会导致进入不安全状态。如果是，就拒绝请求，如果满足请求后仍是安全的，就予以分配。  </p><h2 id="多个资源的银行家算法"><a href="#多个资源的银行家算法" class="headerlink" title="多个资源的银行家算法"></a>多个资源的银行家算法</h2><p>和单个资源类似，用前面所说的多个资源的死锁检测来判断是否安全。<br>但是值得一提的是银行家算法并不实用，一方面很难一开始就知道这个进程所需要的最大资源数目，另一方面系统中进程的数目不是固定的，这可能导致原本可用的资源也变得不可用起来。  </p><h1 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h1><h2 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h2><p>如果一个资源不会被一个进程独占，那么死锁肯定不会发生。  </p><h2 id="破坏占有和等待条件"><a href="#破坏占有和等待条件" class="headerlink" title="破坏占有和等待条件"></a>破坏占有和等待条件</h2><p>只要在一开始将所有需要的资源都读入即可，但是判断需要多少资源时间麻烦事。  </p><h2 id="破坏不可抢占条件"><a href="#破坏不可抢占条件" class="headerlink" title="破坏不可抢占条件"></a>破坏不可抢占条件</h2><p>但是并不是所有资源的都可以修改为可抢占。  </p><h2 id="破坏环路等待条件"><a href="#破坏环路等待条件" class="headerlink" title="破坏环路等待条件"></a>破坏环路等待条件</h2><p>对资源编号，要求进程按照顺序来请求资源。  </p><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h2 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h2><p>饥饿是指系统不能保证某个进程的等待时间上界，从而使该进程长时间等待，当等待时间给进程推进和响应带来明显影响时，称发生了进程饥饿。当饥饿到一定程度的进程所赋予的任务即使完成也不再具有实际意义时称该进程被饿死。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进程和线程</title>
      <link href="2021/02/02/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
      <url>2021/02/02/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>在多道程序设计系统中，CPU由一个进程快速切换至另一个进程，使每个进程各运行几十或几百毫秒。但是实际上一个CPU同时只能运行一个进程，但1s内它可能运行了多个进程，这样就产生了并行的错觉。为了对多个并行活动进行跟踪，操作系统设计者发展了一个概念模型-进程（运行程序时的抽象），使得并行更容易处理。  </p><h2 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h2><p>进程就是一个正在执行程序的实例，包括程序计数器，寄存器和变量的当前值。  </p><h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h2><p>UNIX系统中，只有一个系统调用可以创建新的进程：<code>fork</code>。这个系统调用会创建一个与调用进程相同的副本，这两个进程会拥有相同的存储映像、同样的环境字符串和同样的打开文件。这就是全部情形通常，子进程接着执行<code>execeve</code>以修改器存储映像并允许一个新的程序。  </p><h2 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h2><ol><li>正常退出（自愿的）：通知操作系统它的工作已经完成，在UNIX中该调用<code>exit</code>；  </li><li>出错退出（自愿的）：进程出现错误，捕获错误，然后退出；  </li><li>严重错误（非自愿的）：比如引用不存在的内存、除数是0等，这类错误中，进程可以通知操作系统来处理；  </li><li>被其他进程杀死（非自愿的）：其他进程通过执行一个系统调用：<code>kill</code>来杀死某个进程。  </li></ol><h2 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a>进程的层次结构</h2><p>当一个进程创建出来了后，父进程和子进程以某种形式继续保持联系。自进程可以接着再创建进程，这就形成了进程的层次结构。  </p><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><ol><li>运行态（该时刻进程实际占用CPU）；  </li><li>就绪态（可运行，但因为其他进程正在运行而暂时停止）；  </li><li>阻塞态（除非某种外部事件发生，否则进程不能运行）。  </li></ol><p>运行态可以转变成就绪态和阻塞态，就绪态可以转变成运行态，阻塞态可以转变成就绪态。  </p><h2 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h2><p>为了实现进程模型，操作系统维护一张表格，即进程表。每个进程占用一个进程表项。该表项包含了进程状态的重要信息：程序计数器、堆栈指针、内存分配情况、所打开文件的状态、账号和调度信息，以及其他在进程由运行态转换成就绪态或阻塞态时需要保存的信息。</p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>为什么需要多线程：在许多应用中同时发生着多种活动。其中某些活动随着时间的推移会被阻塞。通过将这些应用程序分解成可以准并行运行的多个顺序线程，程序设计模型会变得更简单。<br>这其实和前面所说的进程看起来并无区别，但是线程引入了一个新的元素：并行实体共享同一地址空间和所有可用数据的能力；另一方面，线程更加轻量级，创建一个线程需要的时间较创建一个进程快10-100倍。<br>需要多线程的第三个原因涉及性能方面的讨论：若多个线程都是CPU密集型的，那么并不能获得性能上的增强，但是如果存在大量的计算和I/O，同游多个线程允许这些活动彼此重叠进行，从而会加快应用程序执行的速度。</p><h2 id="经典的线程模型"><a href="#经典的线程模型" class="headerlink" title="经典的线程模型"></a>经典的线程模型</h2><table>  <tr>    <th>每个进程中的内容</th>    <th>每个线程中的内容</th>  </tr>  <tr>    <td>地址空间</td>    <td>程序计数器</td>  </tr>  <tr>    <td>全局变量</td>    <td>寄存器</td>  </tr>  <tr>    <td>打开文件</td>    <td>堆栈</td>  </tr>  <tr>    <td>子进程</td>    <td>状态</td>  </tr>  <tr>    <td>即将发生的报警</td>    <td></td>  </tr>  <tr>    <td>信号与信号处理程序</td>    <td></td>  </tr>  <tr>    <td>账户信息</td>    <td></td>  </tr></table><h2 id="用户级线程和内核级线程"><a href="#用户级线程和内核级线程" class="headerlink" title="用户级线程和内核级线程"></a>用户级线程和内核级线程</h2><p>用户级线程是指不需要内核支持，在用户程序中实现的线程。它的内核的切换由用户程序自己控制，不需要内核的干涉。但是不能像内核级线程一样更好的运用多核CPU。<br>优点：  </p><ol><li>线程调度不需要内核参与，控制起来简单；  </li><li>可以在不支持线程的操作系统中实现。  </li></ol><p>缺点：  </p><ol><li>用户级线程的阻塞回引起整个进程的阻塞；  </li><li>用户级线程不能利用系统的多重处理，只有一个用户级线程可以被执行。  </li></ol><p>内核级线程：切换由内核控制，由用户态转化为内核态。切换完毕要从内核态返回用户态。可以很好地运用多核CPU。<br>优点：  </p><ol><li>多核时，一个进程的多个线程可以同时执行；  </li><li>由于内核级线程只有很小的数据结构和堆栈，切换速度快。  </li></ol><p>缺点：<br>线程在用户态的运行，而线程的调度和管理在内核实现，在控制权从一个线程传送到另一个线程需要用户态到内核态再到用户态的模式切换，比较占用系统资源。（就是必须要受到内核的监控）。  </p><p>区别：  </p><ol><li>内核支持线程是OS内核可感知的，而用户级线程是OS内核不可感知的；  </li><li>用户级线程的创建、撤消和调度不需要OS内核的支持，所以性能上差一些；  </li><li>用户级线程执行系统调用指令时将导致其所属进程被中断，而内核支持线程执行系统调用指令时，只导致该线程被中断。  </li></ol><h2 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h2><p>编程人员可以决定有多少内核级线程和多少用户级线程彼此多路复用，这一模型最灵活。  </p><h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><p>三个问题：  </p><ol><li>一个进程如何把信息传递给另一个进程？  </li><li>确保两个或更多进程在关键活动中不会出现交叉；  </li><li>进程运行顺序。  </li></ol><h2 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h2><p>两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序，称为竞争条件。  </p><h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>我们需要互斥，即以某种手短确保当一个进程在使用某个共享变量或文件时，其他进程不能做同样的操作。<br>我们把对共享内存进行访问的程序片段称作临界区域或临界区。如果我们能够适当地安排，使得两个进程不可能同时处于临界区中，就能够避免竞争条件。  </p><h2 id="忙等待的互斥"><a href="#忙等待的互斥" class="headerlink" title="忙等待的互斥"></a>忙等待的互斥</h2><ol><li>屏蔽中断：当进程进入临界区后立即屏蔽所有中断，并在就要离开时打开中断。这样子的问题是将屏蔽中断的权力交给用户进程是不明智的，如果没有打开中断，可能导致系统因此终止。  </li><li>锁变量；  </li><li>严格轮换法；  </li><li>Peterson解法；  </li><li>TSL指令<br>那些设计为多处理器的计算机，都有下面一条指令：<br><code>TSL RX, LOCK</code>  </li></ol><p>这个指令可以将一个内存字lock读到寄存器RX中，然后该内存地址上存一个非零值。这个读操作和写操作是不可分割的，即该指令结束之前其他处理器不允许访问该内存字。这通过锁住内存总线来实现，静止其他CPU在本指令结束之前访问内存。  </p><h2 id="信号量-amp-amp-互斥量"><a href="#信号量-amp-amp-互斥量" class="headerlink" title="信号量&amp;&amp;互斥量"></a>信号量&amp;&amp;互斥量</h2><p>信号量、互斥量可以参考我在《CSAPP》的读书笔记第12章的内容。  </p><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>条件变量允许线程由于一些未达到的条件而阻塞。直到另外的线程向它发送信号。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>举例：<br>消费者-生产者问题中，如果缓冲区大小为0，这时候消费者先对互斥量加锁，再对信号量进行P操作，将被阻塞，而由于互斥量加锁，生产者也无法对信号量进行V操作，这种现象叫做死锁。  </p><h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>管程是一种程序结构，由过程、变量及数据结构等组成的一个集合。管程是在编译器层次实现的，在编写程序时可以理解成一个软件包，它提供如下服务：  </p><ul><li>多个彼此可以交互并共用资源的线程  </li><li>多个与资源使用有关的变量  </li><li>一个互斥锁  </li><li>一个用来避免竞态条件的不变量  </li></ul><h1 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h1><p>当计算机系统是多道程序设计系统时，就会发生多个进程或者多个线程竞争CPU。在操作系统中，完成选择工作得这一部分称为调度程序。  </p><h2 id="调度介绍"><a href="#调度介绍" class="headerlink" title="调度介绍"></a>调度介绍</h2><ul><li><p>进程行为：<br>几乎所有进程都是I/O或计算交替突发的，典型地，CPU不停顿地运行一段时间，然后发出一个系统调用以便读写文件。<br>进程也可以分为I/O密集型和计算密集型。  </p></li><li><p>何时调度：  </p></li></ul><p>第一，在创建一个新进程时，选择运行父进程还是子进程；<br>第二，在进程退出时必须做出调度决策，一个进程不再运行，所以必须从就绪进程中选择另外的某个进程；<br>第三，当一个进程阻塞在I/O和信号量上或由于其他原因阻塞时，必须选择另一个进程运行。有时，阻塞原因会成为选择的因素。  </p><ul><li>调度算法分类和目标：<br>不同环境需要不通的调度算法，这里有必要划出的三种环境。<br>1）批处理（吞吐量、周转时间、CPU利用率）；<br>2）交互式（响应时间、均衡性）；<br>3）实时（满足截止时间、可预测性）。  </li></ul><h1 id="经典的IPC问题"><a href="#经典的IPC问题" class="headerlink" title="经典的IPC问题"></a>经典的IPC问题</h1><h2 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h2><p>问题：5个哲学家5把叉子，需要两把叉子才能吃饭：<br>如果同时拿起右边的叉子，则会发生死锁。<br>如何解决：<br>用信号量对5个哲学家提供保护，在开始拿叉子之前，先对相邻两个哲学家的互斥量进行访问，如果他们都没有在吃饭，则拿起叉子。<br>这种解法可以获得最大的并行度。  </p><h2 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h2><p>举例：一个进程正在更新数据库，而这时候，其他读数据库的请求将被阻塞；而一个进程在读数据，其他进程也可以读数据库。这就是典型的读者-写者问题，读者不具有排他性，而写者会排他。<br>解决方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore db = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> rc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">down</span>(&amp;mutex);</span><br><span class="line">rc = rc + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(rc==<span class="number">1</span>)<span class="built_in">down</span>(&amp;db);</span><br><span class="line"><span class="built_in">up</span>(&amp;mutex);</span><br><span class="line"><span class="built_in">read_data_base</span>();</span><br><span class="line"><span class="built_in">down</span>(&amp;mutex);</span><br><span class="line">rc = rc - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(rc == <span class="number">0</span>)<span class="built_in">up</span>(&amp;db);</span><br><span class="line"><span class="built_in">up</span>(&amp;mutex);</span><br><span class="line"><span class="built_in">use_data_read</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">think_up_data</span>();</span><br><span class="line"><span class="built_in">down</span>(&amp;db);</span><br><span class="line"><span class="built_in">write</span>(&amp;db);</span><br><span class="line"><span class="built_in">write_data_base</span>();</span><br><span class="line"><span class="built_in">up</span>(&amp;db);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="进程和线程需要维护的状态"><a href="#进程和线程需要维护的状态" class="headerlink" title="进程和线程需要维护的状态"></a>进程和线程需要维护的状态</h1>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>存储管理</title>
      <link href="2021/01/29/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
      <url>2021/01/29/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要使用虚拟地址空间？"><a href="#为什么要使用虚拟地址空间？" class="headerlink" title="为什么要使用虚拟地址空间？"></a>为什么要使用虚拟地址空间？</h1><ol><li>程序大小的增长速度总是很快，使用虚拟地址空间可以扩大地址空间。  </li><li>如果使用物理地址空间，进程之间共享物理内存，容易造成竞争和程序的崩溃，使用虚拟地址空间还可以增加程序的安全性。  </li><li>使用物理地址空间，同时运行多个程序是困难的。  </li></ol><h1 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h1><h2 id="地址空间的概念"><a href="#地址空间的概念" class="headerlink" title="地址空间的概念"></a>地址空间的概念</h2><p><strong>地址空间</strong> 是一个进程可用于寻址内存的一套地址集合。每个进程都有自己的地址空间，并且这个地址空间独立于其他进程的地址空间。</p><h3 id="基址寄存器和界限寄存器"><a href="#基址寄存器和界限寄存器" class="headerlink" title="基址寄存器和界限寄存器"></a>基址寄存器和界限寄存器</h3><p>经典的重定位方法。基址寄存器存储程序的起始物理地址，界限寄存器存储程序长度。<br>每次一个进程进行访问内存，取一条指令、读取或写一个数据字，CPU会把地址发送到内存总线前，自动把基址值加到进程发出的地址值之上。<br>这个方法比较容易，但是由于每次访问内存都需要进行加法和比较运算，会消耗很多时间。</p><h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><p>现实中我们常常要打开多个程序，每个进程都需要占据一定的内存，如果打开程序比较多，会造成内存不足的问题，有一种简单的处理内存超载的方法，<strong>交换（swapping）技术</strong>。当一个进程空闲时，存放在磁盘上，所以它不运行时不占用内存。另一个方法是<strong>虚拟内存</strong>，虚拟内存使得程序可以只有在一部分被读入内存时运行。  </p><p>交换技术很好理解，我们讨论一下其可能面临的一些问题，我们知道很多程序设计语言都可以动态地分配内存，那么当进程空间视图增大的时候，就会出现问题：  </p><ul><li>有相邻空闲区：将相邻空闲区分配给进程；  </li><li>没有相邻空闲区：把一个或多个进程换出，以便生成足够大的空闲区。<br>如果大部分进程运行时都需要增长，为了减少换入换出的开销，我们在最开始的时候为进程额外分配一些内存，这个预留空间位于堆栈和数据段之间，他们都可以使用其。</li></ul><h2 id="空闲内存管理"><a href="#空闲内存管理" class="headerlink" title="空闲内存管理"></a>空闲内存管理</h2><h3 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h3><p>我们可以把内存划分为小到几个字达到几千字的内存单元，然后用位图来记录使用情况。<br>问题：当我们需要分配占k个单位内存时，，需要在位图中匹配长度为k的0串，这是一个耗时操作。  </p><h3 id="使用链表的存储管理"><a href="#使用链表的存储管理" class="headerlink" title="使用链表的存储管理"></a>使用链表的存储管理</h3><p>维护一个记录已分配内存段和空闲内存段的链表。链表一个结点或者包含一个进程，或者包含一个位于两个进程之间的空闲区。  </p><p>如果按照地址顺序来存放进程和空闲区时，有几种算法可以来为进程分配内存：  </p><ul><li>首次适配算法；  </li><li>下次适配算法；</li><li>最佳适配算法；  </li><li>最差适配算法。  </li></ul><p>如果单独维护空闲区链表和进程链表，可以提高以上四个算法的速度，但是释放内存将内存从进程表中删除并插入到空闲区链表的时间成本高昂。  </p><p>当然如果我们单独维护空闲区链表和进程链表，可以按照大小升序排列，这样可以提高最佳适配的效率。  </p><p>还有一种分配算法叫做<strong>快速适配</strong>，为空闲区维护一个单独的链表。例如，这个表的第一项指向一个大小为4KB的空闲区，第二项指向一个大小为8KB的空闲区，第三项指向一个大小为12KB的空闲区。这样子寻找一个指定大小的空闲区是非常迅速的，但是缺点是合并空闲区相当费时。  </p><h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p>尽管基址寄存器和界限寄存器可以用于创建地址空间的抽象，但无法解决程序大小的膨胀问题。虚拟内存的基本思想是每个程序都拥有自己的地址空间，空间被分为多个块，每一块称作一页。  </p><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>内存管理单元（Memory Management Unit，MMU），MMU把虚拟地址映射为物理内存地址。  </p><p>访问虚拟内存，首先查询页表项（以一级页表为例），如果页表项显示不存在（缓存为命中），则引起缺页中断，陷入内核，由内核将需要的页写入到内存中（如果内存已满，会替换掉一个不常用的页，然后将被替换页写入磁盘）；如果显示存在，从页表项索引到页所在位置；找到物理内存的页后，根据虚拟地址的偏移量来确定最终物理地址。<br>注：页表项还可以添加其他信息，比如读写控制等。  </p><h2 id="转换检测缓冲区（TLB）"><a href="#转换检测缓冲区（TLB）" class="headerlink" title="转换检测缓冲区（TLB）"></a>转换检测缓冲区（TLB）</h2><p>每次内存访问都需要多次访问页表也就是多次访问内存，为了节约时间，使用一种缓存技术TLB，TLB通常在MMU中（硬件实现，所以快），包含少量的表项，每个表项记录一个页面信息，包括虚拟页号，页面的修改位、保护码和该页所对应的物理页框。在每次内存访问时，都会首先访问TLB，寻找匹配表项，如果TLB命中，则不再访问页表，如果不命中，再访问页表，然后再将这次表项读入到TLB（也会淘汰一个TLB表项），下次再访问这个页表，自然会命中了。  </p><h1 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h1><h2 id="最优页面置换算法"><a href="#最优页面置换算法" class="headerlink" title="最优页面置换算法"></a>最优页面置换算法</h2><p>选择最晚将被使用的页面被置换，这个算法很好理解，而且被证明时最优的，但是问题在于我们无法预测页面何时将再被使用。当然可以跟踪页面使用情况来预测，但是这样是不划算的。  </p><h2 id="最近未使用页面置换算法"><a href="#最近未使用页面置换算法" class="headerlink" title="最近未使用页面置换算法"></a>最近未使用页面置换算法</h2><p>最近未使用也很好理解，而且容易实现，性能也够用。  </p><h2 id="先进先出页面置换算法"><a href="#先进先出页面置换算法" class="headerlink" title="先进先出页面置换算法"></a>先进先出页面置换算法</h2><p>还有很多其他页面置换算法，比如时钟页面置换算法，最近最少使用页面置换算法等等，不做赘述。</p><h1 id="分页系统中的设计问题"><a href="#分页系统中的设计问题" class="headerlink" title="分页系统中的设计问题"></a>分页系统中的设计问题</h1><h2 id="局部分配策略和全局分配策略"><a href="#局部分配策略和全局分配策略" class="headerlink" title="局部分配策略和全局分配策略"></a>局部分配策略和全局分配策略</h2><p>局部就是指页面置换时只考虑同一进程的内存，而全局就是考虑所有进程的内存。一般来说，全局的性能更优，而且可以避免一个需要较大内存的进程只被分配了少量物理内存。<br>还有一些动态的分配策略，会实时参考缺页中断率来分配内存。</p><h2 id="负载控制"><a href="#负载控制" class="headerlink" title="负载控制"></a>负载控制</h2><p>即使使用最优页面置换算法，系统也可能发生“抖动”，这在于每个进程都在渴求更多的内存，导致进程不断被频繁换入换出，解决方案是暂时从内存中去掉一些进程。  </p><h3 id="共享页面"><a href="#共享页面" class="headerlink" title="共享页面"></a>共享页面</h3><p>如果不同进程之间共享某页面，可以让他们都指向同一个页面集合，然后当读的时候并不进行页面复制，仅有写发生时进行页面复制，这称为写时复制。  </p><h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><p>通过一个系统调用把文件映射到虚拟地址空间的一部分。这样可以把文件当作一个大型的字符数组来访问，而且这样子可以通过共享内存来通信，一个进程在共享内存上完成了写操作，另一个进程在映射到这个文件的虚拟地址空间之上指向读操作时，它就可以立即看到上一个进程写操作了。这个机制为进程之间提供了一个高带宽通道。</p><h1 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h1><p>一个编译器在编译过程中会创建许多表，其中可能包括：  </p><ol><li>被保存起来供打印清单用的程序正文；  </li><li>符号表，包含变量的名字和属性；  </li><li>包含用到的所有整型量和浮点常量的表；  </li><li>语法分析树，包含程序语法分析的结果；  </li><li>编译器内部过程调用使用的堆栈。  </li></ol><p>我们需要一个能够把程序员从管理表的扩张和收缩工作中解出来的方法，就像虚拟内存使程序员不用再为怎么样把程序划分称覆盖块担心一样。<br>一个直观并且通用的方法是在机器上提供多个互相独立的称为段的地址空间。<br>一个段一般不包含不通类型的内容。在分段系统中，修改一个过程不会影响其他无关的过程的起始地址。<br>分段是一个逻辑实体，程序员知道这一点并把它作为一个逻辑实体来使用。<br>页面的内容从某种意义上是随机的，程序员甚至察觉不到分页的事实，而分段对程序员是已知的。</p><h2 id="分段和分页的结合"><a href="#分段和分页的结合" class="headerlink" title="分段和分页的结合"></a>分段和分页的结合</h2><p>分段和分页可以结合起来使用，一个例子就是MULTICS。具体细节参考《现代操作系统》P134-P135。  </p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>管理事务处理</title>
      <link href="2021/01/28/%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"/>
      <url>2021/01/28/%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h1><p>事务处理是一种机制，用来管理成批执行的MySQL操作，以保证数据库不包含不完整的操作结果。利用事务处理，可以保证一组操作不会中途停止，它们或者作为整体执行，或者完全不执行。如果没有错误发生，整租语句提交给数据库表，如果发生错误，则进行回退，以恢复数据库到某个已知的完全的状态。</p><h1 id="控制事务处理"><a href="#控制事务处理" class="headerlink" title="控制事务处理"></a>控制事务处理</h1><p>MySQL使用下面的语句来标识事务的开始：<br><code>START TRANSACTION;</code></p><h2 id="使用ROLLBACK"><a href="#使用ROLLBACK" class="headerlink" title="使用ROLLBACK"></a>使用ROLLBACK</h2><p>MySQL的ROLLBACK命令用来回退（撤销）MySQL语句，举例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from ordertotals;</span><br><span class="line">&gt; start transaction</span><br><span class="line">&gt; delete from ordertotals;</span><br><span class="line">&gt; select * from ordertotals;</span><br><span class="line">&gt; ROLLBACK;</span><br><span class="line">&gt; select * from ordertotals;</span><br></pre></td></tr></table></figure><p>ROLLBACK只能在一个事务处理内使用（在执行了一条start transaction命令之后）。</p><h2 id="使用COMMIT"><a href="#使用COMMIT" class="headerlink" title="使用COMMIT"></a>使用COMMIT</h2><p>一般的MySQL语句都是直接针对数据库表执行和编写的。这就是所谓的隐含提交，即提交操作时自动进行的，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">delete from orderitems where order_num &#x3D; 20010;</span><br><span class="line">delete from orders where order_num &#x3D; 20010;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><p>在这个例子中，从系统完全删除订单20010.因为涉及更新两个数据库表orders和orderitems，所以使用事务处理块来保证订单不被部分删除。  </p><h2 id="使用保留点"><a href="#使用保留点" class="headerlink" title="使用保留点"></a>使用保留点</h2><p>简单的ROLLBACK和COMMIT语句就可以写入或撤销整个事务处理。但是，只是对简单的事务处理才能这样做，更复杂的事务处理可能需要部分提交或回退。<br>为了支持回退部分事务处理，必须能在事务处理块中合适的位置防止占位符。这样，如果需要回退，可以回退到某个占位符。这些占位符也被称为保留点，为了创建占位符，可如下使用SAVEPOINT语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SAVEPOINT delete1;</span><br></pre></td></tr></table></figure><p>每个保留点都取标识它的唯一名字，以便在回退时，MySQL知道要回退到何处。为了回退到本例给出的保留点，可如下进行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROLLBACK TO delete1;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用触发器</title>
      <link href="2021/01/28/%E4%BD%BF%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
      <url>2021/01/28/%E4%BD%BF%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p><strong>触发器</strong> 是MySQL响应以下任意语句而自动执行的一条MySQL语句。</p><h1 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h1><p>创建触发器需要4条信息：  </p><ol><li>唯一的触发名；  </li><li>触发器关联的表；  </li><li>触发器应该相应的活动；  </li><li>触发器何时执行。  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create trigger newproduct after insert on products </span><br><span class="line">    -&gt; for each row select &#39;Product added&#39; into @add;</span><br></pre></td></tr></table></figure><p><code>create trigger</code>用来创建名为newproduct的新触发器。触发器可在一个操作发生之前或之后执行，这里给出了<code>AFTER INSERT</code>，所以此触发器将在insert语句成功执行后执行。</p><h1 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h1><p>很简单，删除触发器的语法：<code>drop trigger newproduct;</code></p><h1 id="使用触发器"><a href="#使用触发器" class="headerlink" title="使用触发器"></a>使用触发器</h1><h2 id="insert触发器"><a href="#insert触发器" class="headerlink" title="insert触发器"></a>insert触发器</h2><p>insert触发器在insert语句执行之前或之后执行：  </p><ul><li>在insert触发器代码内可以引用一个名为new的虚拟表，访问被插入的行；  </li><li>在before insert触发器中，new中的值也可以被更新（允许修改被插入的值）；  </li><li>对于AUTO_INCREMENT列，new在insert执行之前包含0，在insert执行之后包含新的自动生成值； </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create trigger neworder after insert on orders</span><br><span class="line">    -&gt; for each row select new.order_num into @new_order_num;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into orders(order_date,cust_id)</span><br><span class="line">    -&gt; values(Now(),10001);</span><br><span class="line">Query OK, 1 row affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select @new_order_num;</span><br><span class="line">+----------------+</span><br><span class="line">| @new_order_num |</span><br><span class="line">+----------------+</span><br><span class="line">|          20010 |</span><br><span class="line">+----------------+</span><br></pre></td></tr></table></figure><h2 id="delete触发器"><a href="#delete触发器" class="headerlink" title="delete触发器"></a>delete触发器</h2><ul><li>在delete触发器代码内，你可以引用一个名为OLD的虚拟表，访问被删除的行；  </li><li>OLD中的值全都是只读，不能更新。  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; delimiter &#x2F;&#x2F;</span><br><span class="line">mysql&gt; create trigger deleteorder before delete on orders</span><br><span class="line">    -&gt; for each row</span><br><span class="line">    -&gt; begin</span><br><span class="line">    -&gt; insert into archive_orders(order_num,order_date,cust_id)</span><br><span class="line">    -&gt; values(OLD.order_num,OLD.order_date,OLD.cust_id);</span><br><span class="line">    -&gt; end &#x2F;&#x2F;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; delimiter ;</span><br></pre></td></tr></table></figure><h2 id="update触发器"><a href="#update触发器" class="headerlink" title="update触发器"></a>update触发器</h2><ul><li>在update触发器代码中，你可以引用一个名为OLD的虚拟表访问以前的值，引用一个名为new的虚拟表访问新更新的值；  </li><li>在before update触发器中，new中的值可能也被更新；  </li><li>OLD中的值全都是只读，不能更新。  </li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用游标</title>
      <link href="2021/01/28/%E4%BD%BF%E7%94%A8%E6%B8%B8%E6%A0%87/"/>
      <url>2021/01/28/%E4%BD%BF%E7%94%A8%E6%B8%B8%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<h1 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h1><p>游标只能用于存储过程。</p><h1 id="使用游标"><a href="#使用游标" class="headerlink" title="使用游标"></a>使用游标</h1><h2 id="创建游标"><a href="#创建游标" class="headerlink" title="创建游标"></a>创建游标</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create procedure processorders()</span><br><span class="line">-&gt; begin declare ordernumbers cursor</span><br><span class="line">   -&gt; for</span><br><span class="line">   -&gt; select order_num from orders;</span><br><span class="line">   -&gt; end;</span><br></pre></td></tr></table></figure><h2 id="打开和关闭游标"><a href="#打开和关闭游标" class="headerlink" title="打开和关闭游标"></a>打开和关闭游标</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; open ordernumbers;</span><br><span class="line">mysql&gt; close ordernumbers;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用存储过程</title>
      <link href="2021/01/28/%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
      <url>2021/01/28/%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><p>实际使用MySQL经常会有一个完整得操作需要多条语句才能完成。可以创建存储过程来简化这个问题，存储过程可以视为批文件，虽然它们得作用不仅局限于批处理。</p><h1 id="为什么要使用存储过程"><a href="#为什么要使用存储过程" class="headerlink" title="为什么要使用存储过程"></a>为什么要使用存储过程</h1><ol><li>简化复杂操作。  </li><li>保证数据的完整性。  </li><li>简化对变动的管理。  </li></ol><h1 id="使用存储过程"><a href="#使用存储过程" class="headerlink" title="使用存储过程"></a>使用存储过程</h1><p>使用存储过程需要知道如何执行它们。存储过程的执行远比其定义更经常遇到，因此，我们将从执行存储过程开始介绍。然后再介绍创建和使用存储过程。</p><h2 id="执行存储过程"><a href="#执行存储过程" class="headerlink" title="执行存储过程"></a>执行存储过程</h2><p>MySQL称存储过程的执行为调用，因此MySQL执行存储过程的语句为CALL。CALL接受存储过程的名字以及需要传递给它的任意参数。请看例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL productpricing(@pricelow,@pricehigh,@priceaverage);</span><br></pre></td></tr></table></figure><h2 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE productpricing()</span><br><span class="line">BEGIN</span><br><span class="line">SELECT Avg(prod_prices) as priceaverage</span><br><span class="line">   from products;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>注意：如果使用的是mysql命令行实用程序，应该修改默认的语句分隔符（原来是;）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE PROCEDURE productpricing()</span><br><span class="line">BEGIN</span><br><span class="line">SELECT Avg(prod_prices) as priceaverage</span><br><span class="line">   from products;</span><br><span class="line">END &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h2 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h2><p>存储过程在创建之后被保存在服务器上以供使用。删除可以使用如下语句：<br><code>DROP PROCEDURE productpricing;</code></p><h2 id="使用参数"><a href="#使用参数" class="headerlink" title="使用参数"></a>使用参数</h2><p>一般存储过程不显示结果，只是把结果返回到指定的变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; delimiter &#x2F;&#x2F;</span><br><span class="line">mysql&gt; create procedure productpricing(</span><br><span class="line">    -&gt; out pl decimal(8,2),</span><br><span class="line">    -&gt; out ph decimal(8,2),</span><br><span class="line">    -&gt; out pa decimal(8,2))</span><br><span class="line">    -&gt; begin</span><br><span class="line">    -&gt; select min(prod_price)</span><br><span class="line">    -&gt; into pl</span><br><span class="line">    -&gt; from products;</span><br><span class="line">    -&gt; select max(prod_price)</span><br><span class="line">    -&gt; into ph</span><br><span class="line">    -&gt; from products;</span><br><span class="line">    -&gt; select avg(prod_price)</span><br><span class="line">    -&gt; into pa</span><br><span class="line">    -&gt; from products;</span><br><span class="line">    -&gt; end &#x2F;&#x2F;</span><br><span class="line">mysql&gt; delimiter ;</span><br></pre></td></tr></table></figure><p><code>in</code>是输入，<code>out</code>是输出。</p><p>执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; call productpricing(@pricelow,@pricehigh,@priceaverage);</span><br><span class="line">Query OK, 1 row affected, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select @pricehigh;</span><br><span class="line">+------------+</span><br><span class="line">| @pricehigh |</span><br><span class="line">+------------+</span><br><span class="line">|      55.00 |</span><br><span class="line">+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="建立智能存储过程"><a href="#建立智能存储过程" class="headerlink" title="建立智能存储过程"></a>建立智能存储过程</h2><h2 id="检查存储过程"><a href="#检查存储过程" class="headerlink" title="检查存储过程"></a>检查存储过程</h2><p>为了显示创建一个存储过程的CREATE语句，使用show create procedure语句。例如：<br><code>show create procedure ordertotal;</code></p>]]></content>
      
      
      <categories>
          
          <category> MySQL学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用视图</title>
      <link href="2021/01/28/%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE/"/>
      <url>2021/01/28/%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询。  </p><h2 id="为什么使用视图"><a href="#为什么使用视图" class="headerlink" title="为什么使用视图"></a>为什么使用视图</h2><p>在视图创建之后，可以用与相同的方式利用它们。可以对视图进行select操作，过滤和排序数据，将视图联结到其他试图或表，甚至能添加和更新数据。</p><h2 id="视图的规则和限制"><a href="#视图的规则和限制" class="headerlink" title="视图的规则和限制"></a>视图的规则和限制</h2><ul><li>与表一样，视图必须唯一命名。  </li><li>对于可以创建的视图数目没有限制。  </li><li>为了创建视图，必须有足够的访问权限。这些限制通常由数据库管理人员授予。  </li><li>视图可以嵌套。  </li><li>order by可以用在视图中。  </li><li>视图不能索引。  </li><li>视图可以和表一起使用。  </li></ul><h1 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h1><ul><li><code>create view</code>：创建视图。  </li><li><code>show create view viewname</code>：查看创建视图的语句。  </li><li><code>drop view viewname</code>：删除视图。  </li><li>更新视图可以先<code>DROP</code>原视图，在创建新的同名视图，或者直接创建新的同名视图。  </li></ul><h2 id="利用视图简化复杂联结"><a href="#利用视图简化复杂联结" class="headerlink" title="利用视图简化复杂联结"></a>利用视图简化复杂联结</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create view productcustomers as</span><br><span class="line">    -&gt; select cust_name, cust_contact, prod_id</span><br><span class="line">    -&gt; from customers, orders, orderitems</span><br><span class="line">    -&gt; where customers.cust_id &#x3D; orders.cust_id</span><br><span class="line">    -&gt; and orderitems.order_num &#x3D; orders.order_num;</span><br></pre></td></tr></table></figure><p>然后如果我们要检索，订购了产品TNT2的客户，可以如下进行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select cust_name,cust_contact</span><br><span class="line">    -&gt; from productcustomers</span><br><span class="line">    -&gt; where prod_id &#x3D; &#39;TNT2&#39;;</span><br><span class="line">+----------------+--------------+</span><br><span class="line">| cust_name      | cust_contact |</span><br><span class="line">+----------------+--------------+</span><br><span class="line">| Coyote Inc.    | Y Lee        |</span><br><span class="line">| Yosemite Place | Y Sam        |</span><br><span class="line">+----------------+--------------+</span><br></pre></td></tr></table></figure><h2 id="用视图重新格式化检索出的数据"><a href="#用视图重新格式化检索出的数据" class="headerlink" title="用视图重新格式化检索出的数据"></a>用视图重新格式化检索出的数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create view vendorlocations as</span><br><span class="line">    -&gt; select concat(RTrim(vend_name),&#39; (&#39;,RTrim(vend_country),&#39;)&#39;) as vend_title</span><br><span class="line">    -&gt; from vendors</span><br><span class="line">    -&gt; order by vend_name;</span><br><span class="line">mysql&gt; select * from vendorlocations;</span><br><span class="line">+-------------------------+</span><br><span class="line">| vend_title              |</span><br><span class="line">+-------------------------+</span><br><span class="line">| ACME (USA)              |</span><br><span class="line">| Anvils R Us (USA)       |</span><br><span class="line">| Furball Inc. (USA)      |</span><br><span class="line">| Jet Set (England)       |</span><br><span class="line">| Jouets Et Ours (France) |</span><br><span class="line">| LT Supplies (USA)       |</span><br><span class="line">+-------------------------+</span><br></pre></td></tr></table></figure><h2 id="使用视图过滤不想要的数据"><a href="#使用视图过滤不想要的数据" class="headerlink" title="使用视图过滤不想要的数据"></a>使用视图过滤不想要的数据</h2><h2 id="使用视图与计算字段"><a href="#使用视图与计算字段" class="headerlink" title="使用视图与计算字段"></a>使用视图与计算字段</h2><h2 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h2><p>通常，视图时刻更新的，更新一个视图将更新其基表，如果你对视图增加或删除行，实际上是对其基表增加或删除行，所以更新的首要条件就是MySQL能够定位到更新的基数据。如果视图定义有以下操作，则不能进行视图更新：  </p><ul><li>分组  </li><li>联结  </li><li>子查询  </li><li>聚集函数  </li><li>并  </li><li>DISTINCT  </li><li>导出列</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>创建表</title>
      <link href="2021/01/28/%E5%88%9B%E5%BB%BA%E8%A1%A8/"/>
      <url>2021/01/28/%E5%88%9B%E5%BB%BA%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h1><h2 id="创建表基础"><a href="#创建表基础" class="headerlink" title="创建表基础"></a>创建表基础</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table customers(</span><br><span class="line">   -&gt; cust_idintNOT NULL AUTO_INCREMENT,</span><br><span class="line">   -&gt; cust_namechar(50)NOT NULL ,</span><br><span class="line">   -&gt; cust_addresschar(50)NULL,</span><br><span class="line">   -&gt; cust_citychar(50)NULL,</span><br><span class="line">   -&gt; cust_statechar(5)NULL,</span><br><span class="line">   -&gt; cust_zipchar(10)NULL,</span><br><span class="line">   -&gt; cust_countrychar(50)NULL,</span><br><span class="line">   -&gt; cust_contactchar(50)NULL,</span><br><span class="line">   -&gt; cust_emailchar(255)NULL,</span><br><span class="line">   -&gt; PRIMARY KEY (cust_id)</span><br><span class="line">   -&gt; )ENGINE&#x3D;InnoDB;</span><br></pre></td></tr></table></figure><h2 id="使用NULL值"><a href="#使用NULL值" class="headerlink" title="使用NULL值"></a>使用NULL值</h2><p>NULL值就是没有值或缺值，运行NULL值得列也允许在插入行时，不给出该列得值。</p><h2 id="主键介绍"><a href="#主键介绍" class="headerlink" title="主键介绍"></a>主键介绍</h2><p>表中每个行都必须具有唯一的主键值。主键用下列语句定义：<br><code>PRIMARY KEY (vend_id)</code><br>当然也可以用多个作为主键，举例：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table orderitems(</span><br><span class="line">   -&gt; order_numint   NOT NULL ,</span><br><span class="line">   -&gt; order_item   int   NOT NULL ,</span><br><span class="line">   -&gt; prod_id  char(10)      NOT NULL ,</span><br><span class="line">   -&gt; quantity int   NOT NULL ,</span><br><span class="line">   -&gt; item_price   decimal(8,2)  NOT NULL ,</span><br><span class="line">   -&gt; PRIMARY KEY (order_num, order_item)</span><br><span class="line">   -&gt; )ENGINE&#x3D;InnoDB;</span><br></pre></td></tr></table></figure><h2 id="使用AUTO-INCREMENT"><a href="#使用AUTO-INCREMENT" class="headerlink" title="使用AUTO_INCREMENT"></a>使用AUTO_INCREMENT</h2><p><code>AUTO_INCREMENT</code>告诉MySQL，本列每当增加一行时自动增量。每次执行一个INSERT操作时，MySQL自动对该列增量。</p><h2 id="指定默认值"><a href="#指定默认值" class="headerlink" title="指定默认值"></a>指定默认值</h2><p>如果在插入行时没有给出值，MySQL允许使用默认值，默认值用CREATE TABLE语句得列定义中的DEFAULT关键字指定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table orderitems(</span><br><span class="line">   -&gt; order_numint   NOT NULL ,</span><br><span class="line">   -&gt; order_item   int   NOT NULL ,</span><br><span class="line">   -&gt; prod_id  char(10)      NOT NULL ,</span><br><span class="line">   -&gt; quantity int   NOT NULL DEFAULT 1,</span><br><span class="line">   -&gt; item_price   decimal(8,2)  NOT NULL ,</span><br><span class="line">   -&gt; PRIMARY KEY (order_num, order_item)</span><br><span class="line">   -&gt; )ENGINE&#x3D;InnoDB;</span><br></pre></td></tr></table></figure><h2 id="引擎类型"><a href="#引擎类型" class="headerlink" title="引擎类型"></a>引擎类型</h2><p>MySQL（其他DBMS也一样）有一个具体管理和处理数据的内部引擎。在你使用<code>create table</code>语句时，该引擎具体创建表，而在你使用select或进行其他数据库处理时，该引擎在内部处理你的请求。以下几个是需要知道的引擎：  </p><ul><li>InnoDB是一个可靠的事务处理引擎，它不支持全文本搜索。  </li><li>MEMORY在功能商等同于MyISAM，但由于数据存储在内存中，速度很快。  </li><li>MyISAM是一个性能极高的引擎，它支持全文本搜索，但不支持事务处理。  </li></ul><h1 id="更新表"><a href="#更新表" class="headerlink" title="更新表"></a>更新表</h1><p>为更新表定义，可使用ALTER TABLE语句（理想情况下表一旦被创建就不应该被更新）。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE vendors</span><br><span class="line">    -&gt; ADD vend_phone CHAR(20);</span><br></pre></td></tr></table></figure><p>如果想删除刚刚添加的列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE vendors </span><br><span class="line">    -&gt; DROP column vend_phone;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ALTER TABLE的一种常见用途是定义外键。具体细节不做展开。</p><h1 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h1><p>非常简单：<br><code>DROP TABLE customers2;</code></p><h1 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h1><p>使用<code>RENAME TABLE</code>语句可以重新命名一张表：<br><code>RENAME TABLE customers2 TO customers;</code></p>]]></content>
      
      
      <categories>
          
          <category> MySQL学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>更新和删除数据</title>
      <link href="2021/01/27/%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE/"/>
      <url>2021/01/27/%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h1><p>为了更行（修改）表中的数据可以使用<code>UPDATE</code>语句。举例：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update customers</span><br><span class="line">    -&gt; set cust_email &#x3D; &#39;elmer@fudd.com&#39;</span><br><span class="line">    -&gt; where cust_id &#x3D; 10005;</span><br></pre></td></tr></table></figure><p>基本的update语句由3部分组成：  </p><ul><li>要更新的表  </li><li>列名和它们的新值  </li><li>确定要更新行的过滤条件  </li></ul><p>更新多个列的话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update customers</span><br><span class="line">    -&gt; set cust_email &#x3D; &#39;elmer@fudd.com&#39;,cust_name &#x3D; &#39;the Fudds&#39;</span><br><span class="line">    -&gt; where cust_id &#x3D; 10005;</span><br></pre></td></tr></table></figure><h1 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h1><p>为了从表中删除数据，使用<code>DELETE</code>语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; delete from customers</span><br><span class="line">    -&gt; where cust_id &#x3D; 10006;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>插入数据</title>
      <link href="2021/01/27/%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/"/>
      <url>2021/01/27/%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="数据插入"><a href="#数据插入" class="headerlink" title="数据插入"></a>数据插入</h1><p>插入可以有几种方式：    </p><ol><li>插入完整的行  </li><li>插入行的一部分  </li><li>插入多行  </li><li>插入某些查询结果  </li></ol><h1 id="插入完整的行"><a href="#插入完整的行" class="headerlink" title="插入完整的行"></a>插入完整的行</h1><p>使用基本的<code>INSERT</code>语法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into customers</span><br><span class="line">    -&gt; values(null,&#39;Pep E. LaPew&#39;,</span><br><span class="line">    -&gt; &#39;100 Main Street&#39;,</span><br><span class="line">    -&gt; &#39;Los Angeles&#39;,</span><br><span class="line">    -&gt; &#39;CA&#39;,</span><br><span class="line">    -&gt; &#39;90046&#39;,</span><br><span class="line">    -&gt; &#39;USA&#39;,</span><br><span class="line">    -&gt; NULL,</span><br><span class="line">    -&gt; NULL);</span><br></pre></td></tr></table></figure><p>虽然这种语法很简单，但并不安全，应该尽量避免使用。这高度依赖表中列定义的次序。<br>更安全的方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into customers</span><br><span class="line">    -&gt; (cust_name,cust_address,cust_city,cust_state,cust_zip,</span><br><span class="line">    -&gt; cust_country,cust_contact,cust_email)</span><br><span class="line">    -&gt; values(&#39;Pep E. LaPew&#39;,&#39;100 Main Street&#39;,&#39;Log Angeles&#39;,</span><br><span class="line">    -&gt; &#39;CA&#39;,&#39;90046&#39;,&#39;USA&#39;,NULL,NULL);</span><br></pre></td></tr></table></figure><h1 id="插入多个行"><a href="#插入多个行" class="headerlink" title="插入多个行"></a>插入多个行</h1><p>如果我们想插入多个行，可以使用上面的语句，插入一行对应一个<code>values()</code>。</p><h1 id="插入检索出的数据"><a href="#插入检索出的数据" class="headerlink" title="插入检索出的数据"></a>插入检索出的数据</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into customers</span><br><span class="line">    -&gt; (cust_id,cust_contact,cust_email,cust_name,cust_address,</span><br><span class="line">    -&gt; cust_city,cust_state,cust_zip,cust_country)</span><br><span class="line">    -&gt; select cust_id,cust_contact,cust_email,cust_name,cust_address,</span><br><span class="line">    -&gt; cust_city,cust_state,cust_zip,cust_country</span><br><span class="line">    -&gt; from custnew;</span><br></pre></td></tr></table></figure><p>这个例子使用<code>INSERT SELECT</code>从custnew中将所有数据导入custmers中。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>全文本搜索</title>
      <link href="2021/01/27/%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/"/>
      <url>2021/01/27/%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="理解全文本搜索"><a href="#理解全文本搜索" class="headerlink" title="理解全文本搜索"></a>理解全文本搜索</h1><p><strong>并非所有引擎都支持全文本搜索</strong> 两个最常用的引擎MyISAM和InnoDB，前者支持全文本搜索，而后者不支持。</p><h1 id="使用全文本搜索"><a href="#使用全文本搜索" class="headerlink" title="使用全文本搜索"></a>使用全文本搜索</h1><h2 id="启用全文本搜索支持"><a href="#启用全文本搜索支持" class="headerlink" title="启用全文本搜索支持"></a>启用全文本搜索支持</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table productnotes(</span><br><span class="line">    -&gt; note_idintNOT NULL AUTO_INCREMENT,</span><br><span class="line">    -&gt; prod_id  char(10)NOT NULL,</span><br><span class="line">    -&gt; note_datedatetimeNOT NULL,</span><br><span class="line">    -&gt; note_text textNULL,</span><br><span class="line">    -&gt; PRIMARY KEY(note_id),</span><br><span class="line">    -&gt; FULLTEXT(note_text)</span><br><span class="line">    -&gt; )ENGINE&#x3D;MyISAM;</span><br></pre></td></tr></table></figure><h2 id="进行全文本搜索"><a href="#进行全文本搜索" class="headerlink" title="进行全文本搜索"></a>进行全文本搜索</h2><p>在索引之后，使用两个函数<code>Match()</code>、<code>Against()</code>执行全文本搜索。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select note_text from productnotes </span><br><span class="line">    -&gt; where match(note_text) against(&#39;rabbit&#39;);</span><br><span class="line">+----------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| note_text                                                    |</span><br><span class="line">+----------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Customer complaint: rabbit has been able to detect trap, food apparently less effective now.                         |</span><br><span class="line">| Quantity varies, sold by the sack load.</span><br><span class="line">All guaranteed to be bright and orange, and suitable for use as rabbit bait. |</span><br><span class="line">+----------------------------------------------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><h2 id="使用查询扩展"><a href="#使用查询扩展" class="headerlink" title="使用查询扩展"></a>使用查询扩展</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select note_text</span><br><span class="line">    -&gt; from productnotes</span><br><span class="line">    -&gt; where Match(note_text) against(&#39;anvils&#39; with query expansion);</span><br><span class="line">+----------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| note_text                                                                                                                                                |</span><br><span class="line">+----------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Multiple customer returns, anvils failing to drop fast enough or falling backwards on purchaser. Recommend that customer considers using heavier anvils. |</span><br><span class="line">| Customer complaint:</span><br><span class="line">Sticks not individually wrapped, too easy to mistakenly detonate all at once.</span><br><span class="line">Recommend individual wrapping.                         |</span><br><span class="line">| Customer complaint:</span><br><span class="line">Not heavy enough to generate flying stars around head of victim. If being purchased for dropping, recommend ANV02 or ANV03 instead.  |</span><br><span class="line">| Please note that no returns will be accepted if safe opened using explosives.                                                                            |</span><br><span class="line">| Customer complaint: rabbit has been able to detect trap, food apparently less effective now.                                                             |</span><br><span class="line">| Customer complaint:</span><br><span class="line">Circular hole in safe floor can apparently be easily cut with handsaw.                                                               |</span><br><span class="line">| Matches not included, recommend purchase of matches or detonator (item DTNTR).                                                                           |</span><br><span class="line">+----------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><h2 id="布尔文本搜索"><a href="#布尔文本搜索" class="headerlink" title="布尔文本搜索"></a>布尔文本搜索</h2><p>以布尔方式进行搜索，可以提供关于如下内容的细节：  </p><ul><li>要匹配的词；  </li><li>要排斥的词；  </li><li>排列提示；  </li><li>表达式分组；  </li><li>另外一些内容。  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select note_text</span><br><span class="line">    -&gt; from productnotes</span><br><span class="line">    -&gt; where match(note_text) against(&#39;heavy&#39; in boolean mode);</span><br><span class="line">+---------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| note_text                                                                                                                                               |</span><br><span class="line">+---------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Item is extremely heavy. Designed for dropping, not recommended for use with slings, ropes, pulleys, or tightropes.                                     |</span><br><span class="line">| Customer complaint:</span><br><span class="line">Not heavy enough to generate flying stars around head of victim. If being purchased for dropping, recommend ANV02 or ANV03 instead. |</span><br><span class="line">+---------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>添加排斥信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select note_text from productnotes </span><br><span class="line">    -&gt; where match(note_text) against(&#39;heavy -rope*&#39; in boolean mode);</span><br><span class="line">+---------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| note_text                                                                                                                                               |</span><br><span class="line">+---------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Customer complaint:</span><br><span class="line">Not heavy enough to generate flying stars around head of victim. If being purchased for dropping, recommend ANV02 or ANV03 instead. |</span><br><span class="line">+---------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>这里就将包含<code>rope</code>的行排除掉了。<br>全文本布尔操作符还有很多，具体细节查找相关资料了解。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>组合查询</title>
      <link href="2021/01/27/%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2/"/>
      <url>2021/01/27/%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h1><p>多数SQL查询都只包含从一个或多个表中返回数据的单条SELECT语句。MySQL也允许执行多个查询（多条SELECT语句），并将结果作为单个查询结果集返回。这些组合查询通常称为并（union）或复合查询。</p><h1 id="创建组合查询"><a href="#创建组合查询" class="headerlink" title="创建组合查询"></a>创建组合查询</h1><h2 id="使用UNION"><a href="#使用UNION" class="headerlink" title="使用UNION"></a>使用UNION</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select vend_id, prod_id,prod_price </span><br><span class="line">    -&gt; from products</span><br><span class="line">    -&gt; where prod_price &lt;&#x3D; 5</span><br><span class="line">    -&gt; union </span><br><span class="line">    -&gt; select vend_id, prod_id, prod_price</span><br><span class="line">    -&gt; from products</span><br><span class="line">    -&gt; where vend_id in (1001,1002);</span><br><span class="line">+---------+---------+------------+</span><br><span class="line">| vend_id | prod_id | prod_price |</span><br><span class="line">+---------+---------+------------+</span><br><span class="line">|    1003 | FC      |       2.50 |</span><br><span class="line">|    1002 | FU1     |       3.42 |</span><br><span class="line">|    1003 | SLING   |       4.49 |</span><br><span class="line">|    1003 | TNT1    |       2.50 |</span><br><span class="line">|    1001 | ANV01   |       5.99 |</span><br><span class="line">|    1001 | ANV02   |       9.99 |</span><br><span class="line">|    1001 | ANV03   |      14.99 |</span><br><span class="line">|    1002 | OL1     |       8.99 |</span><br><span class="line">+---------+---------+------------+</span><br></pre></td></tr></table></figure><h3 id="包含或取消重复的行"><a href="#包含或取消重复的行" class="headerlink" title="包含或取消重复的行"></a>包含或取消重复的行</h3><p>union会自动去除重复的行，如果需要改变它，返回所有匹配行，则使用UNION ALL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select vend_id,prod_id,prod_price</span><br><span class="line">    -&gt; from products</span><br><span class="line">    -&gt; where prod_price &lt;&#x3D; 5</span><br><span class="line">    -&gt; union all</span><br><span class="line">    -&gt; select vend_id, prod_id, prod_price</span><br><span class="line">    -&gt; from products</span><br><span class="line">    -&gt; where vend_id in (1001,1002);</span><br><span class="line">+---------+---------+------------+</span><br><span class="line">| vend_id | prod_id | prod_price |</span><br><span class="line">+---------+---------+------------+</span><br><span class="line">|    1003 | FC      |       2.50 |</span><br><span class="line">|    1002 | FU1     |       3.42 |</span><br><span class="line">|    1003 | SLING   |       4.49 |</span><br><span class="line">|    1003 | TNT1    |       2.50 |</span><br><span class="line">|    1001 | ANV01   |       5.99 |</span><br><span class="line">|    1001 | ANV02   |       9.99 |</span><br><span class="line">|    1001 | ANV03   |      14.99 |</span><br><span class="line">|    1002 | FU1     |       3.42 |</span><br><span class="line">|    1002 | OL1     |       8.99 |</span><br><span class="line">+---------+---------+------------+</span><br></pre></td></tr></table></figure><h3 id="对组合查询结果排序"><a href="#对组合查询结果排序" class="headerlink" title="对组合查询结果排序"></a>对组合查询结果排序</h3><p>在使用<code>union</code>组合查询时，只能使用一条<code>order by</code>子句，它必须出席那在最后一条<code>select</code>语句之后，对于结果集，不存在用一种方式排序一部分，而有用另一种方式排序另一部分的情况，因此不允许使用多条<code>order by</code>子句。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>创建高级联结</title>
      <link href="2021/01/27/%E5%88%9B%E5%BB%BA%E9%AB%98%E7%BA%A7%E8%81%94%E7%BB%93/"/>
      <url>2021/01/27/%E5%88%9B%E5%BB%BA%E9%AB%98%E7%BA%A7%E8%81%94%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="创建高级联结"><a href="#创建高级联结" class="headerlink" title="创建高级联结"></a>创建高级联结</h1><h2 id="使用表别名"><a href="#使用表别名" class="headerlink" title="使用表别名"></a>使用表别名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select cust_name, cust_contact</span><br><span class="line">    -&gt; from customers as c, orders as o, orderitems as oi</span><br><span class="line">    -&gt; where c.cust_id &#x3D; o.cust_id and oi.order_num &#x3D; o.order_num </span><br><span class="line">    -&gt; and prod_id &#x3D; &#39;TNT2&#39;;</span><br><span class="line">+----------------+--------------+</span><br><span class="line">| cust_name      | cust_contact |</span><br><span class="line">+----------------+--------------+</span><br><span class="line">| Coyote Inc.    | Y Lee        |</span><br><span class="line">| Yosemite Place | Y Sam        |</span><br><span class="line">+----------------+--------------+</span><br></pre></td></tr></table></figure><h2 id="使用不同类型的联结"><a href="#使用不同类型的联结" class="headerlink" title="使用不同类型的联结"></a>使用不同类型的联结</h2><h3 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a>自联结</h3><p>找到生产prod_id为’DTNTR’的供应商生产的所有产品。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select prod_id, prod_name</span><br><span class="line">    -&gt; from products</span><br><span class="line">    -&gt; where vend_id &#x3D; (select vend_id </span><br><span class="line">    -&gt; from products where prod_id &#x3D; &#39;DTNTR&#39;);</span><br><span class="line">+---------+----------------+</span><br><span class="line">| prod_id | prod_name      |</span><br><span class="line">+---------+----------------+</span><br><span class="line">| DTNTR   | Detonator      |</span><br><span class="line">| FB      | Bird seed      |</span><br><span class="line">| FC      | Carrots        |</span><br><span class="line">| SAFE    | Safe           |</span><br><span class="line">| SLING   | Sling          |</span><br><span class="line">| TNT1    | TNT (1 stick)  |</span><br><span class="line">| TNT2    | TNT (5 sticks) |</span><br><span class="line">+---------+----------------+</span><br></pre></td></tr></table></figure><p>这是一种解决方案，通过子查询来实现。<br>现在来看使用联结的相同查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select p1.prod_id, p1.prod_name</span><br><span class="line">    -&gt; from products as p1, products as p2</span><br><span class="line">    -&gt; where p1.vend_id &#x3D; p2.vend_id</span><br><span class="line">    -&gt; and p2.prod_id &#x3D; &#39;DTNTR&#39;;</span><br><span class="line">+---------+----------------+</span><br><span class="line">| prod_id | prod_name      |</span><br><span class="line">+---------+----------------+</span><br><span class="line">| DTNTR   | Detonator      |</span><br><span class="line">| FB      | Bird seed      |</span><br><span class="line">| FC      | Carrots        |</span><br><span class="line">| SAFE    | Safe           |</span><br><span class="line">| SLING   | Sling          |</span><br><span class="line">| TNT1    | TNT (1 stick)  |</span><br><span class="line">| TNT2    | TNT (5 sticks) |</span><br><span class="line">+---------+----------------+</span><br></pre></td></tr></table></figure><h3 id="自然联结"><a href="#自然联结" class="headerlink" title="自然联结"></a>自然联结</h3><p>自然联结排除多次出现，使每个列只返回一次。</p><h3 id="外部联结"><a href="#外部联结" class="headerlink" title="外部联结"></a>外部联结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select customers.cust_id, orders.order_num </span><br><span class="line">    -&gt; from customers left outer join orders</span><br><span class="line">    -&gt; on customers.cust_id &#x3D; orders.cust_id;</span><br><span class="line">+---------+-----------+</span><br><span class="line">| cust_id | order_num |</span><br><span class="line">+---------+-----------+</span><br><span class="line">|   10001 |     20005 |</span><br><span class="line">|   10001 |     20009 |</span><br><span class="line">|   10002 |      NULL |</span><br><span class="line">|   10003 |     20006 |</span><br><span class="line">|   10004 |     20007 |</span><br><span class="line">|   10005 |     20008 |</span><br><span class="line">+---------+-----------+</span><br></pre></td></tr></table></figure><p>外部联结不同于内部联结的是，除了关联的行，外部联结还会包含没有关联的行。外部联结除了要使用<code>outer</code>之外，还必须要使用是left或者right。使用left代表左边表（customers）中选择所有行，right代表右边表选择所有行。当然，未匹配行但被选择的行的将会被置为NULL。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select c.cust_id, c.cust_name,o.cust_id, o.order_num</span><br><span class="line">    -&gt; from customers as c left outer join orders as o</span><br><span class="line">    -&gt; on c.cust_id &#x3D; o.cust_id;</span><br><span class="line">+---------+----------------+---------+-----------+</span><br><span class="line">| cust_id | cust_name      | cust_id | order_num |</span><br><span class="line">+---------+----------------+---------+-----------+</span><br><span class="line">|   10001 | Coyote Inc.    |   10001 |     20005 |</span><br><span class="line">|   10001 | Coyote Inc.    |   10001 |     20009 |</span><br><span class="line">|   10002 | Mouse House    |    NULL |      NULL |</span><br><span class="line">|   10003 | Wascals        |   10003 |     20006 |</span><br><span class="line">|   10004 | Yosemite Place |   10004 |     20007 |</span><br><span class="line">|   10005 | E Fudd         |   10005 |     20008 |</span><br><span class="line">+---------+----------------+---------+-----------+</span><br></pre></td></tr></table></figure><h3 id="使用带聚集函数的联结"><a href="#使用带聚集函数的联结" class="headerlink" title="使用带聚集函数的联结"></a>使用带聚集函数的联结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select c.cust_name, c.cust_id,count(o.order_num) as num_ord </span><br><span class="line">    -&gt; from customers as c inner join orders as o   </span><br><span class="line">    -&gt; on c.cust_id &#x3D; o.cust_id group by c.cust_id;</span><br><span class="line">+----------------+---------+---------+</span><br><span class="line">| cust_name      | cust_id | num_ord |</span><br><span class="line">+----------------+---------+---------+</span><br><span class="line">| Coyote Inc.    |   10001 |       2 |</span><br><span class="line">| Wascals        |   10003 |       1 |</span><br><span class="line">| Yosemite Place |   10004 |       1 |</span><br><span class="line">| E Fudd         |   10005 |       1 |</span><br><span class="line">+----------------+---------+---------+</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>联结表</title>
      <link href="2021/01/27/%E8%81%94%E7%BB%93%E8%A1%A8/"/>
      <url>2021/01/27/%E8%81%94%E7%BB%93%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h1><h2 id="联结"><a href="#联结" class="headerlink" title="联结"></a>联结</h2><p><strong>外键</strong> 外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。<br><strong>可伸缩性</strong> 能够适应不断增加的工作量而不失败。设计良好的数据库或应用程序称之为可伸缩性好</p><h2 id="创建联结"><a href="#创建联结" class="headerlink" title="创建联结"></a>创建联结</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select vend_name, prod_name, prod_price </span><br><span class="line">    -&gt; from vendors,products</span><br><span class="line">    -&gt; where vendors.vend_id &#x3D; products.vend_id</span><br><span class="line">    -&gt; order by vend_name, prod_name;</span><br><span class="line">+-------------+----------------+------------+</span><br><span class="line">| vend_name   | prod_name      | prod_price |</span><br><span class="line">+-------------+----------------+------------+</span><br><span class="line">| ACME        | Bird seed      |      10.00 |</span><br><span class="line">| ACME        | Carrots        |       2.50 |</span><br><span class="line">| ACME        | Detonator      |      13.00 |</span><br><span class="line">| ACME        | Safe           |      50.00 |</span><br><span class="line">| ACME        | Sling          |       4.49 |</span><br><span class="line">| ACME        | TNT (1 stick)  |       2.50 |</span><br><span class="line">| ACME        | TNT (5 sticks) |      10.00 |</span><br><span class="line">| Anvils R Us | .5 ton anvil   |       5.99 |</span><br><span class="line">| Anvils R Us | 1 ton anvil    |       9.99 |</span><br><span class="line">| Anvils R Us | 2 ton anvil    |      14.99 |</span><br><span class="line">| Jet Set     | JetPack 1000   |      35.00 |</span><br><span class="line">| Jet Set     | JetPack 2000   |      55.00 |</span><br><span class="line">| LT Supplies | Fuses          |       3.42 |</span><br><span class="line">| LT Supplies | Oil can        |       8.99 |</span><br><span class="line">+-------------+----------------+------------+</span><br></pre></td></tr></table></figure><p><strong>笛卡尔积</strong> 由没有联解条件的表关系返回的结果为笛卡尔积。检索出来的行的数目将是第一个表中的行数乘以第二个表中的行数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select vend_name, prod_name, prod_price </span><br><span class="line">    -&gt; from vendors,products</span><br><span class="line">    -&gt; order by vend_name, prod_price;</span><br><span class="line">+----------------+----------------+------------+</span><br><span class="line">| vend_name      | prod_name      | prod_price |</span><br><span class="line">+----------------+----------------+------------+</span><br><span class="line">| ACME           | Carrots        |       2.50 |</span><br><span class="line">| ACME           | TNT (1 stick)  |       2.50 |</span><br><span class="line">| ACME           | Fuses          |       3.42 |</span><br><span class="line">| ACME           | Sling          |       4.49 |</span><br><span class="line">| ACME           | .5 ton anvil   |       5.99 |</span><br><span class="line">| ACME           | Oil can        |       8.99 |</span><br><span class="line">| ACME           | 1 ton anvil    |       9.99 |</span><br><span class="line">| ACME           | TNT (5 sticks) |      10.00 |</span><br><span class="line">| ACME           | Bird seed      |      10.00 |</span><br><span class="line">| ACME           | Detonator      |      13.00 |</span><br><span class="line">| ACME           | 2 ton anvil    |      14.99 |</span><br><span class="line">| ACME           | JetPack 1000   |      35.00 |</span><br><span class="line">| ACME           | Safe           |      50.00 |</span><br><span class="line">| ACME           | JetPack 2000   |      55.00 |</span><br><span class="line">| Anvils R Us    | Carrots        |       2.50 |</span><br><span class="line">| Anvils R Us    | TNT (1 stick)  |       2.50 |</span><br><span class="line">| Anvils R Us    | Fuses          |       3.42 |</span><br><span class="line">| Anvils R Us    | Sling          |       4.49 |</span><br><span class="line">| Anvils R Us    | .5 ton anvil   |       5.99 |</span><br><span class="line">| Anvils R Us    | Oil can        |       8.99 |</span><br><span class="line">| Anvils R Us    | 1 ton anvil    |       9.99 |</span><br><span class="line">| Anvils R Us    | TNT (5 sticks) |      10.00 |</span><br><span class="line">| Anvils R Us    | Bird seed      |      10.00 |</span><br><span class="line">| Anvils R Us    | Detonator      |      13.00 |</span><br><span class="line">| Anvils R Us    | 2 ton anvil    |      14.99 |</span><br><span class="line">| Anvils R Us    | JetPack 1000   |      35.00 |</span><br><span class="line">| Anvils R Us    | Safe           |      50.00 |</span><br><span class="line">| Anvils R Us    | JetPack 2000   |      55.00 |</span><br><span class="line">| Furball Inc.   | Carrots        |       2.50 |</span><br><span class="line">| Furball Inc.   | TNT (1 stick)  |       2.50 |</span><br><span class="line">| Furball Inc.   | Fuses          |       3.42 |</span><br><span class="line">| Furball Inc.   | Sling          |       4.49 |</span><br><span class="line">| Furball Inc.   | .5 ton anvil   |       5.99 |</span><br><span class="line">| Furball Inc.   | Oil can        |       8.99 |</span><br><span class="line">| Furball Inc.   | 1 ton anvil    |       9.99 |</span><br><span class="line">| Furball Inc.   | TNT (5 sticks) |      10.00 |</span><br><span class="line">| Furball Inc.   | Bird seed      |      10.00 |</span><br><span class="line">| Furball Inc.   | Detonator      |      13.00 |</span><br><span class="line">| Furball Inc.   | 2 ton anvil    |      14.99 |</span><br><span class="line">| Furball Inc.   | JetPack 1000   |      35.00 |</span><br><span class="line">| Furball Inc.   | Safe           |      50.00 |</span><br><span class="line">| Furball Inc.   | JetPack 2000   |      55.00 |</span><br><span class="line">| Jet Set        | TNT (1 stick)  |       2.50 |</span><br><span class="line">| Jet Set        | Carrots        |       2.50 |</span><br><span class="line">| Jet Set        | Fuses          |       3.42 |</span><br><span class="line">| Jet Set        | Sling          |       4.49 |</span><br><span class="line">| Jet Set        | .5 ton anvil   |       5.99 |</span><br><span class="line">| Jet Set        | Oil can        |       8.99 |</span><br><span class="line">| Jet Set        | 1 ton anvil    |       9.99 |</span><br><span class="line">| Jet Set        | TNT (5 sticks) |      10.00 |</span><br><span class="line">| Jet Set        | Bird seed      |      10.00 |</span><br><span class="line">| Jet Set        | Detonator      |      13.00 |</span><br><span class="line">| Jet Set        | 2 ton anvil    |      14.99 |</span><br><span class="line">| Jet Set        | JetPack 1000   |      35.00 |</span><br><span class="line">| Jet Set        | Safe           |      50.00 |</span><br><span class="line">| Jet Set        | JetPack 2000   |      55.00 |</span><br><span class="line">| Jouets Et Ours | Carrots        |       2.50 |</span><br><span class="line">| Jouets Et Ours | TNT (1 stick)  |       2.50 |</span><br><span class="line">| Jouets Et Ours | Fuses          |       3.42 |</span><br><span class="line">| Jouets Et Ours | Sling          |       4.49 |</span><br><span class="line">| Jouets Et Ours | .5 ton anvil   |       5.99 |</span><br><span class="line">| Jouets Et Ours | Oil can        |       8.99 |</span><br><span class="line">| Jouets Et Ours | 1 ton anvil    |       9.99 |</span><br><span class="line">| Jouets Et Ours | TNT (5 sticks) |      10.00 |</span><br><span class="line">| Jouets Et Ours | Bird seed      |      10.00 |</span><br><span class="line">| Jouets Et Ours | Detonator      |      13.00 |</span><br><span class="line">| Jouets Et Ours | 2 ton anvil    |      14.99 |</span><br><span class="line">| Jouets Et Ours | JetPack 1000   |      35.00 |</span><br><span class="line">| Jouets Et Ours | Safe           |      50.00 |</span><br><span class="line">| Jouets Et Ours | JetPack 2000   |      55.00 |</span><br><span class="line">| LT Supplies    | Carrots        |       2.50 |</span><br><span class="line">| LT Supplies    | TNT (1 stick)  |       2.50 |</span><br><span class="line">| LT Supplies    | Fuses          |       3.42 |</span><br><span class="line">| LT Supplies    | Sling          |       4.49 |</span><br><span class="line">| LT Supplies    | .5 ton anvil   |       5.99 |</span><br><span class="line">| LT Supplies    | Oil can        |       8.99 |</span><br><span class="line">| LT Supplies    | 1 ton anvil    |       9.99 |</span><br><span class="line">| LT Supplies    | TNT (5 sticks) |      10.00 |</span><br><span class="line">| LT Supplies    | Bird seed      |      10.00 |</span><br><span class="line">| LT Supplies    | Detonator      |      13.00 |</span><br><span class="line">| LT Supplies    | 2 ton anvil    |      14.99 |</span><br><span class="line">| LT Supplies    | JetPack 1000   |      35.00 |</span><br><span class="line">| LT Supplies    | Safe           |      50.00 |</span><br><span class="line">| LT Supplies    | JetPack 2000   |      55.00 |</span><br><span class="line">+----------------+----------------+------------+</span><br></pre></td></tr></table></figure><h3 id="内部联结"><a href="#内部联结" class="headerlink" title="内部联结"></a>内部联结</h3><p>目前为止所用的联结称为等值联结，它基于两个表之间的相等测试。其实，对于这种联结可以使用稍微不通的语法来明确指定联结的类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select vend_name,prod_name,prod_price </span><br><span class="line">    -&gt; from vendors inner join products on vendors.vend_id &#x3D; products.vend_id;</span><br><span class="line">+-------------+----------------+------------+</span><br><span class="line">| vend_name   | prod_name      | prod_price |</span><br><span class="line">+-------------+----------------+------------+</span><br><span class="line">| Anvils R Us | .5 ton anvil   |       5.99 |</span><br><span class="line">| Anvils R Us | 1 ton anvil    |       9.99 |</span><br><span class="line">| Anvils R Us | 2 ton anvil    |      14.99 |</span><br><span class="line">| LT Supplies | Fuses          |       3.42 |</span><br><span class="line">| LT Supplies | Oil can        |       8.99 |</span><br><span class="line">| ACME        | Detonator      |      13.00 |</span><br><span class="line">| ACME        | Bird seed      |      10.00 |</span><br><span class="line">| ACME        | Carrots        |       2.50 |</span><br><span class="line">| ACME        | Safe           |      50.00 |</span><br><span class="line">| ACME        | Sling          |       4.49 |</span><br><span class="line">| ACME        | TNT (1 stick)  |       2.50 |</span><br><span class="line">| ACME        | TNT (5 sticks) |      10.00 |</span><br><span class="line">| Jet Set     | JetPack 1000   |      35.00 |</span><br><span class="line">| Jet Set     | JetPack 2000   |      55.00 |</span><br><span class="line">+-------------+----------------+------------+</span><br></pre></td></tr></table></figure><h3 id="联结多个表"><a href="#联结多个表" class="headerlink" title="联结多个表"></a>联结多个表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select prod_name, vend_name, prod_price, quantity from orderitems, products, vendors where products.vend_id &#x3D; vendors.vend_id and orderitems.prod_id &#x3D; products.prod_id and order_num &#x3D; 20005;</span><br><span class="line">+----------------+-------------+------------+----------+</span><br><span class="line">| prod_name      | vend_name   | prod_price | quantity |</span><br><span class="line">+----------------+-------------+------------+----------+</span><br><span class="line">| .5 ton anvil   | Anvils R Us |       5.99 |       10 |</span><br><span class="line">| 1 ton anvil    | Anvils R Us |       9.99 |        3 |</span><br><span class="line">| TNT (5 sticks) | ACME        |      10.00 |        5 |</span><br><span class="line">| Bird seed      | ACME        |      10.00 |        1 |</span><br><span class="line">+----------------+-------------+------------+----------+</span><br></pre></td></tr></table></figure><p>但是尽量减少不必要的联结，影响性能。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用子查询</title>
      <link href="2021/01/27/%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2/"/>
      <url>2021/01/27/%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="使用子查询"><a href="#使用子查询" class="headerlink" title="使用子查询"></a>使用子查询</h1><h2 id="利用子查询进行过滤"><a href="#利用子查询进行过滤" class="headerlink" title="利用子查询进行过滤"></a>利用子查询进行过滤</h2><p>数据库表常常是关系表，所有数据不会存储在一个数据表中，比如订单存储在两个表中，对于包含订单号、客户ID、订单日期的每个订单，orders表存储一行。各订单的物品存储在相关的orderitems表中，如果我们要查找包含物品TNT2的客户如何做？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select cust_id from orders </span><br><span class="line">    -&gt; where order_num in (select order_num</span><br><span class="line">    -&gt; from orderitems</span><br><span class="line">    -&gt; where prod_id &#x3D; &#39;TNT2&#39;</span><br><span class="line">    -&gt; );</span><br><span class="line">+---------+</span><br><span class="line">| cust_id |</span><br><span class="line">+---------+</span><br><span class="line">|   10001 |</span><br><span class="line">|   10004 |</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure><p>括号内的内容就是一个子查询，从orderitems表中查找包含了TNT2的订单，并返回订单号列，然后再从orders表中找到满足订单号的行，并返回客户ID列。<br>子查询可以多层嵌套。</p><h2 id="作为计算字段使用子查询"><a href="#作为计算字段使用子查询" class="headerlink" title="作为计算字段使用子查询"></a>作为计算字段使用子查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select cust_name,cust_state,</span><br><span class="line">    -&gt; (select count(*)</span><br><span class="line">    -&gt; from orders </span><br><span class="line">    -&gt; where orders.cust_id &#x3D; customers.cust_id) as orders</span><br><span class="line">    -&gt; from customers</span><br><span class="line">    -&gt; order by cust_name;</span><br><span class="line">+----------------+------------+--------+</span><br><span class="line">| cust_name      | cust_state | orders |</span><br><span class="line">+----------------+------------+--------+</span><br><span class="line">| Coyote Inc.    | MI         |      2 |</span><br><span class="line">| E Fudd         | IL         |      1 |</span><br><span class="line">| Mouse House    | OH         |      0 |</span><br><span class="line">| Wascals        | IN         |      1 |</span><br><span class="line">| Yosemite Place | AZ         |      1 |</span><br><span class="line">+----------------+------------+--------+</span><br></pre></td></tr></table></figure><p>这条<code>SELECT</code>语句对customers表中的每个客户返回3列：cust_name、cust_state、orders。orders是一个计算字段，它是由圆括号中的子查询建立的。该子查询对检索出的每个客户执行一次，再此历次中执行了5次，因为检索出来5各客户。注意我们应该使用完全限定列名，而不应该这样使用：<br><code>cust_id = cust_id</code>。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分组数据</title>
      <link href="2021/01/27/%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE/"/>
      <url>2021/01/27/%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h1><h2 id="创建分组"><a href="#创建分组" class="headerlink" title="创建分组"></a>创建分组</h2><p>分组是在<code>SELECT</code>语句的GROUP BY子句中创建的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select vend_id, count(*) as num_prods</span><br><span class="line">    -&gt; from products</span><br><span class="line">    -&gt; group by vend_id;</span><br><span class="line">+---------+-----------+</span><br><span class="line">| vend_id | num_prods |</span><br><span class="line">+---------+-----------+</span><br><span class="line">|    1001 |         3 |</span><br><span class="line">|    1002 |         2 |</span><br><span class="line">|    1003 |         7 |</span><br><span class="line">|    1005 |         2 |</span><br><span class="line">+---------+-----------+</span><br></pre></td></tr></table></figure><p><code>GROUP BY</code>按照<code>vend_id</code>排序并分组数据。这导致对每个vend_id而不是整个表计算<code>num_prods</code>计算一次。</p><h2 id="过滤分组"><a href="#过滤分组" class="headerlink" title="过滤分组"></a>过滤分组</h2><p>这里不能使用<code>WHERE</code>来过滤分组（where过滤的是行）。而实使用<code>HAVING</code>来过滤分组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select cust_id,count(*) as orders</span><br><span class="line">    -&gt; from orders</span><br><span class="line">    -&gt; group by cust_id</span><br><span class="line">    -&gt; having count(*)&gt;&#x3D;2;</span><br><span class="line">+---------+--------+</span><br><span class="line">| cust_id | orders |</span><br><span class="line">+---------+--------+</span><br><span class="line">|   10001 |      2 |</span><br><span class="line">+---------+--------+</span><br></pre></td></tr></table></figure><p>同时使用<code>WHERE</code>和<code>HAVING</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select vend_id, count(*) as num_prods</span><br><span class="line">    -&gt; from products</span><br><span class="line">    -&gt; where prod_price &gt;&#x3D; 10</span><br><span class="line">    -&gt; group by vend_id</span><br><span class="line">    -&gt; having count(*)&gt;&#x3D;2;</span><br><span class="line">+---------+-----------+</span><br><span class="line">| vend_id | num_prods |</span><br><span class="line">+---------+-----------+</span><br><span class="line">|    1003 |         4 |</span><br><span class="line">|    1005 |         2 |</span><br><span class="line">+---------+-----------+</span><br></pre></td></tr></table></figure><p>这条语句中，第一行使用了聚集函数的基本<code>SELECT</code>。<code>WHERE</code>先过滤所有prod_price至少为10的行。然后按照vend_id分组数据，<code>having</code>子句过滤计数为2或2以上的分组。</p><h2 id="分组和排序"><a href="#分组和排序" class="headerlink" title="分组和排序"></a>分组和排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select order_num, SUM(quantity*item_price) as ordertotal</span><br><span class="line">    -&gt; from orderitems</span><br><span class="line">    -&gt; group by order_num</span><br><span class="line">    -&gt; having sum(quantity*item_price) &gt;&#x3D; 50</span><br><span class="line">    -&gt; order by ordertotal;</span><br><span class="line">+-----------+------------+</span><br><span class="line">| order_num | ordertotal |</span><br><span class="line">+-----------+------------+</span><br><span class="line">|     20006 |      55.00 |</span><br><span class="line">|     20008 |     125.00 |</span><br><span class="line">|     20005 |     149.87 |</span><br><span class="line">|     20007 |    1000.00 |</span><br><span class="line">+-----------+------------+</span><br></pre></td></tr></table></figure><h2 id="SELECT子句顺序"><a href="#SELECT子句顺序" class="headerlink" title="SELECT子句顺序"></a>SELECT子句顺序</h2><table>  <tr>    <td>子句</td>    <td>说明</td>    <td>是否必须使用</td>  </tr>  <tr>    <td>SELECT</td>    <td>要返回的列或表达式</td>    <td>是</td>  </tr>  <tr>    <td>FROM</td>    <td>从中检索数据的表</td>    <td>仅在从表选择数据时候用到</td>  </tr>  <tr>    <td>WHERE</td>    <td>行级过滤</td>    <td>否</td>  </tr>  <tr>    <td>GROUP BY</td>    <td>大分组说明</td>    <td>仅在按组计算聚集时使用</td>  </tr>  <tr>    <td>HAVING</td>    <td>组级过滤</td>    <td>否</td>  </tr>  <tr>    <td>ORDER BY</td>    <td>输出排序顺序</td>    <td>否</td>  </tr>  <tr>    <td>LIMIT</td>    <td>要检索的行数</td>    <td>否</td>  </tr></table>]]></content>
      
      
      <categories>
          
          <category> MySQL学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>汇总数据</title>
      <link href="2021/01/27/%E6%B1%87%E6%80%BB%E6%95%B0%E6%8D%AE/"/>
      <url>2021/01/27/%E6%B1%87%E6%80%BB%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h1><h2 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h2><p>我们经常需要汇总数据而不用把他们实际检索出来，为此，MySQL提供了专门的函数。<br><strong>聚集函数</strong> 运行在行组上，计算和返回单个值的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AVG():返回某个列的平均值</span><br><span class="line">COUNT():返回某个列的行数</span><br><span class="line">MAX():返回某个列的最大值</span><br><span class="line">MIN():返回某个列的最小值</span><br><span class="line">SUM():返回某个列值之后</span><br></pre></td></tr></table></figure><h3 id="AVG-函数"><a href="#AVG-函数" class="headerlink" title="AVG()函数"></a>AVG()函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select avg(prod_price) as avg_price</span><br><span class="line">    -&gt; from products;</span><br><span class="line">+-----------+</span><br><span class="line">| avg_price |</span><br><span class="line">+-----------+</span><br><span class="line">| 16.133571 |</span><br><span class="line">+-----------+</span><br></pre></td></tr></table></figure><p>默认忽略列值为NULL的行。</p><h3 id="COUNT-函数"><a href="#COUNT-函数" class="headerlink" title="COUNT()函数"></a>COUNT()函数</h3><p><code>COUNT()</code>函数用来计数。可利用<code>COUNT()</code>确定表中的行的数目或符合特定条件的行的数目。<br>COUNT()函数有两种使用的方式：</p><ul><li>使用<code>COUNT(*)</code>对表中所有行进行计数。  </li><li>使用<code>COUNT(column)</code>忽略值为NULL的行。  </li></ul><p>剩下的函数使用和AVG()类似，不做多讲。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用数据处理函数</title>
      <link href="2021/01/27/%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/"/>
      <url>2021/01/27/%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="使用数据处理函数"><a href="#使用数据处理函数" class="headerlink" title="使用数据处理函数"></a>使用数据处理函数</h1><h2 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h2><p>大多数SQL实现支持以下类型的函数。</p><ul><li>用于处理文本串  </li><li>用于在数值数据上进行算术操作  </li><li>用于处理日期和时间并从这些值中提取特定成分的日期和时间函数  </li><li>返回DBMS正在使用的特殊信息的系统函数</li></ul><h3 id="文本处理函数"><a href="#文本处理函数" class="headerlink" title="文本处理函数"></a>文本处理函数</h3><p>使用Upper()将文本转换为大写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select vend_name, upper(vend_name) as vend_name_upcase</span><br><span class="line">    -&gt; from vendors order by vend_name;</span><br><span class="line">+----------------+------------------+</span><br><span class="line">| vend_name      | vend_name_upcase |</span><br><span class="line">+----------------+------------------+</span><br><span class="line">| ACME           | ACME             |</span><br><span class="line">| Anvils R Us    | ANVILS R US      |</span><br><span class="line">| Furball Inc.   | FURBALL INC.     |</span><br><span class="line">| Jet Set        | JET SET          |</span><br><span class="line">| Jouets Et Ours | JOUETS ET OURS   |</span><br><span class="line">| LT Supplies    | LT SUPPLIES      |</span><br><span class="line">+----------------+------------------+</span><br></pre></td></tr></table></figure><p>常用的文本处理函数有<code>Left()</code>、<code>Length()</code>等等，具体使用查阅相关资料。</p><h3 id="日期和时间处理函数"><a href="#日期和时间处理函数" class="headerlink" title="日期和时间处理函数"></a>日期和时间处理函数</h3><p>函数较多，具体查阅相关资料。</p><h3 id="数值处理函数"><a href="#数值处理函数" class="headerlink" title="数值处理函数"></a>数值处理函数</h3><p>有<code>Abs()</code>、<code>Cos()</code>、<code>Exp()</code>等许多数值处理函数。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>创建计算字段</title>
      <link href="2021/01/27/%E5%88%9B%E5%BB%BA%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5/"/>
      <url>2021/01/27/%E5%88%9B%E5%BB%BA%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="创建计算字段"><a href="#创建计算字段" class="headerlink" title="创建计算字段"></a>创建计算字段</h1><h2 id="拼接字段"><a href="#拼接字段" class="headerlink" title="拼接字段"></a>拼接字段</h2><p><strong>拼接(concatenate)</strong> 将值联结到一起构成单个值。解决办法就是把两个列拼接起来，在MySQL的SELECT语句中，可使用<code>Concat()</code>函数来拼接两个列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select Concat(vend_name,&#39; (&#39;,vend_country, &#39;)&#39;) </span><br><span class="line">    -&gt; from vendors order by vend_name;</span><br><span class="line">+------------------------------------------+</span><br><span class="line">| Concat(vend_name,&#39; (&#39;,vend_country, &#39;)&#39;) |</span><br><span class="line">+------------------------------------------+</span><br><span class="line">| ACME (USA)                               |</span><br><span class="line">| Anvils R Us (USA)                        |</span><br><span class="line">| Furball Inc. (USA)                       |</span><br><span class="line">| Jet Set (England)                        |</span><br><span class="line">| Jouets Et Ours (France)                  |</span><br><span class="line">| LT Supplies (USA)                        |</span><br><span class="line">+------------------------------------------+</span><br></pre></td></tr></table></figure><p>还可以通过删除数据右侧多余的空格来整理数据，比如<code>RTrim()</code>，<code>LTrim()</code>可以删除左边多余的空格。</p><h2 id="执行算术计算"><a href="#执行算术计算" class="headerlink" title="执行算术计算"></a>执行算术计算</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select prod_id,</span><br><span class="line">    -&gt; quantity,</span><br><span class="line">    -&gt; item_price,</span><br><span class="line">    -&gt; quantity*item_price as expanded_price</span><br><span class="line">    -&gt; from orderitems</span><br><span class="line">    -&gt; where order_num &#x3D; 20005;</span><br><span class="line">+---------+----------+------------+----------------+</span><br><span class="line">| prod_id | quantity | item_price | expanded_price |</span><br><span class="line">+---------+----------+------------+----------------+</span><br><span class="line">| ANV01   |       10 |       5.99 |          59.90 |</span><br><span class="line">| ANV02   |        3 |       9.99 |          29.97 |</span><br><span class="line">| TNT2    |        5 |      10.00 |          50.00 |</span><br><span class="line">| FB      |        1 |      10.00 |          10.00 |</span><br><span class="line">+---------+----------+------------+----------------+</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>用正则表达式进行搜索</title>
      <link href="2021/01/27/%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%90%9C%E7%B4%A2/"/>
      <url>2021/01/27/%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="用正则表达式进行搜索"><a href="#用正则表达式进行搜索" class="headerlink" title="用正则表达式进行搜索"></a>用正则表达式进行搜索</h1><h2 id="正则表达式介绍"><a href="#正则表达式介绍" class="headerlink" title="正则表达式介绍"></a>正则表达式介绍</h2><p>正则表达式是用来匹配文本的特殊的串。如果想要从一个文本文件匹配一个电话号码，就可以使用正则表达式。</p><h2 id="使用MySQL正则表达式"><a href="#使用MySQL正则表达式" class="headerlink" title="使用MySQL正则表达式"></a>使用MySQL正则表达式</h2><h3 id="基本字符匹配"><a href="#基本字符匹配" class="headerlink" title="基本字符匹配"></a>基本字符匹配</h3><p>下面的语句检索列prod_name包含文本1000的所有行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select prod_name</span><br><span class="line">    -&gt; from products</span><br><span class="line">    -&gt; where prod_name regexp &#39;1000&#39;</span><br><span class="line">    -&gt; order by prod_name;</span><br><span class="line">+--------------+</span><br><span class="line">| prod_name    |</span><br><span class="line">+--------------+</span><br><span class="line">| JetPack 1000 |</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure><p>为什么要费力的使用正则表达式了，我们可以再看看下面这个例子，<code>.</code>标识匹配任意字符，因此1000和2000都匹配返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select prod_name</span><br><span class="line">    -&gt; from products</span><br><span class="line">    -&gt; where prod_name regexp &#39;.000&#39;</span><br><span class="line">    -&gt; order by prod_name</span><br><span class="line">    -&gt; ;</span><br><span class="line">+--------------+</span><br><span class="line">| prod_name    |</span><br><span class="line">+--------------+</span><br><span class="line">| JetPack 1000 |</span><br><span class="line">| JetPack 2000 |</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure><h3 id="进行OR匹配"><a href="#进行OR匹配" class="headerlink" title="进行OR匹配"></a>进行OR匹配</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select prod_name</span><br><span class="line">    -&gt; from products</span><br><span class="line">    -&gt; where prod_name regexp &#39;1000|2000&#39;</span><br><span class="line">    -&gt; order by prod_name;</span><br><span class="line">+--------------+</span><br><span class="line">| prod_name    |</span><br><span class="line">+--------------+</span><br><span class="line">| JetPack 1000 |</span><br><span class="line">| JetPack 2000 |</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure><p>语句中使用了正则表达式<code>1000|2000</code>，其中<code>|</code>表示匹配其中之一。</p><h3 id="匹配几个字符之一"><a href="#匹配几个字符之一" class="headerlink" title="匹配几个字符之一"></a>匹配几个字符之一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select prod_name from products</span><br><span class="line">    -&gt; where prod_name regexp &#39;[123] Ton&#39;;</span><br><span class="line">+-------------+</span><br><span class="line">| prod_name   |</span><br><span class="line">+-------------+</span><br><span class="line">| 1 ton anvil |</span><br><span class="line">| 2 ton anvil |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure><p>这里<code>[123]</code>定义了一组字符，它的意思是匹配1或2或3。<code>[]</code>是另一种形式的OR语句，事实上正则表达式<code>[123]Ton</code>是<code>[1|2|3]Ton</code>的缩写。</p><h3 id="匹配范围"><a href="#匹配范围" class="headerlink" title="匹配范围"></a>匹配范围</h3><p>如果我们要匹配0-9，可以这么写<code>[0123456789]</code>，也可以这么写：<code>[0-9]</code>。</p><h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><p>定位符有;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">^:文本的开始</span><br><span class="line">$:文本的结尾</span><br><span class="line">[[:&lt;:]]词的开始</span><br><span class="line">[[:&gt;:]]词的结尾</span><br></pre></td></tr></table></figure><p>可以这样使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select prod_name</span><br><span class="line">    -&gt; from products</span><br><span class="line">    -&gt; where prod_name regexp &#39;^[0-9\\.]&#39;</span><br><span class="line">    -&gt; order by prod_name;</span><br><span class="line">+--------------+</span><br><span class="line">| prod_name    |</span><br><span class="line">+--------------+</span><br><span class="line">| .5 ton anvil |</span><br><span class="line">| 1 ton anvil  |</span><br><span class="line">| 2 ton anvil  |</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>用通配符进行过滤</title>
      <link href="2021/01/27/%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>2021/01/27/%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="用通配符进行过滤"><a href="#用通配符进行过滤" class="headerlink" title="用通配符进行过滤"></a>用通配符进行过滤</h1><h2 id="LIKE操作符"><a href="#LIKE操作符" class="headerlink" title="LIKE操作符"></a>LIKE操作符</h2><h3 id="通配符"><a href="#通配符" class="headerlink" title="%通配符"></a>%通配符</h3><p>在搜索串中<code>%</code>用来标识任何字符出现任意次数。例如为了找到所有以词jet起头的产品，可以使用以下select语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select prod_id, prod_name</span><br><span class="line">    -&gt; from products</span><br><span class="line">    -&gt; where prod_name like &quot;jet%&quot;;</span><br><span class="line">+---------+--------------+</span><br><span class="line">| prod_id | prod_name    |</span><br><span class="line">+---------+--------------+</span><br><span class="line">| JP1000  | JetPack 1000 |</span><br><span class="line">| JP2000  | JetPack 2000 |</span><br><span class="line">+---------+--------------+</span><br></pre></td></tr></table></figure><p>可以使用多个通配符，比如”%anvil%”用来搜索所有包括anvil子串的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select prod_id, prod_name from products where prod_name like &quot;%anvil%&quot;;</span><br><span class="line">+---------+--------------+</span><br><span class="line">| prod_id | prod_name    |</span><br><span class="line">+---------+--------------+</span><br><span class="line">| ANV01   | .5 ton anvil |</span><br><span class="line">| ANV02   | 1 ton anvil  |</span><br><span class="line">| ANV03   | 2 ton anvil  |</span><br><span class="line">+---------+--------------+</span><br></pre></td></tr></table></figure><p><code>%</code>可以匹配0到任意个字符。</p><h3 id="下划线（-）通配符"><a href="#下划线（-）通配符" class="headerlink" title="下划线（_）通配符"></a>下划线（_）通配符</h3><p><code>_</code>和<code>%</code>的作用是一样的，不同的是<code>_</code>只能匹配一个字符。<br>就不举例了。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据过滤</title>
      <link href="2021/01/27/%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4/"/>
      <url>2021/01/27/%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="数据过滤"><a href="#数据过滤" class="headerlink" title="数据过滤"></a>数据过滤</h1><h2 id="组合WHERE子句"><a href="#组合WHERE子句" class="headerlink" title="组合WHERE子句"></a>组合WHERE子句</h2><h3 id="AND和OR操作符"><a href="#AND和OR操作符" class="headerlink" title="AND和OR操作符"></a>AND和OR操作符</h3><p>这两个操作符的作用通过名字就可以看出来，如果没有，结合一下例子，一定可以知道：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select vend_id, prod_price</span><br><span class="line">    -&gt; from products</span><br><span class="line">    -&gt; where vend_id &#x3D; 1003 and prod_price &lt;&#x3D; 10;+---------+------------+</span><br><span class="line">| vend_id | prod_price |</span><br><span class="line">+---------+------------+</span><br><span class="line">|    1003 |      10.00 |</span><br><span class="line">|    1003 |       2.50 |</span><br><span class="line">|    1003 |       4.49 |</span><br><span class="line">|    1003 |       2.50 |</span><br><span class="line">|    1003 |      10.00 |</span><br><span class="line">+---------+------------+</span><br><span class="line">&#x2F;&#x2F; 返回了同时满足vend_id&#x3D;1003和prod_price&lt;&#x3D;10的行。</span><br><span class="line">&#x2F;&#x2F; 接下来我们将and换成or试试看</span><br><span class="line">mysql&gt; select vend_id, prod_price from products where vend_id &#x3D; 1003 or prod_price &lt;&#x3D; 10;</span><br><span class="line">+---------+------------+</span><br><span class="line">| vend_id | prod_price |</span><br><span class="line">+---------+------------+</span><br><span class="line">|    1001 |       5.99 |</span><br><span class="line">|    1001 |       9.99 |</span><br><span class="line">|    1003 |      13.00 |</span><br><span class="line">|    1003 |      10.00 |</span><br><span class="line">|    1003 |       2.50 |</span><br><span class="line">|    1002 |       3.42 |</span><br><span class="line">|    1002 |       8.99 |</span><br><span class="line">|    1003 |      50.00 |</span><br><span class="line">|    1003 |       4.49 |</span><br><span class="line">|    1003 |       2.50 |</span><br><span class="line">|    1003 |      10.00 |</span><br><span class="line">+---------+------------+</span><br><span class="line">&#x2F;&#x2F; 这里我们发现返回的行至少满足vend_id&#x3D;1003和prod_price&lt;&#x3D;10两个条件其中之一。</span><br></pre></td></tr></table></figure><h3 id="计算次序"><a href="#计算次序" class="headerlink" title="计算次序"></a>计算次序</h3><p>如果同时使用and和or操作符，优先计算and（可以结合高级语言的运算符优先级考虑，C语言中&amp;&amp;优先级高于||）。如果我们希望更改操作符被计算的次序，可以使用圆括号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select prod_name, prod_price</span><br><span class="line">    -&gt; from products</span><br><span class="line">    -&gt; where (vend_id &#x3D; 1002 or vend_id &#x3D; 1003) and prod_price &gt;&#x3D; 10;</span><br><span class="line">+----------------+------------+</span><br><span class="line">| prod_name      | prod_price |</span><br><span class="line">+----------------+------------+</span><br><span class="line">| Detonator      |      13.00 |</span><br><span class="line">| Bird seed      |      10.00 |</span><br><span class="line">| Safe           |      50.00 |</span><br><span class="line">| TNT (5 sticks) |      10.00 |</span><br><span class="line">+----------------+------------+</span><br></pre></td></tr></table></figure><h2 id="IN操作符"><a href="#IN操作符" class="headerlink" title="IN操作符"></a>IN操作符</h2><p>IN操作符用来指定条件范围，范围中每个条件都可以进行匹配。IN取合法值的由逗号分隔的清单，全都括在圆括号中。下面的例子说明了这个操作符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select prod_name, prod_price</span><br><span class="line">    -&gt; from products</span><br><span class="line">    -&gt; where vend_id in (1001,1002,1003)</span><br><span class="line">    -&gt; order by prod_name;</span><br><span class="line">+----------------+------------+</span><br><span class="line">| prod_name      | prod_price |</span><br><span class="line">+----------------+------------+</span><br><span class="line">| .5 ton anvil   |       5.99 |</span><br><span class="line">| 1 ton anvil    |       9.99 |</span><br><span class="line">| 2 ton anvil    |      14.99 |</span><br><span class="line">| Bird seed      |      10.00 |</span><br><span class="line">| Carrots        |       2.50 |</span><br><span class="line">| Detonator      |      13.00 |</span><br><span class="line">| Fuses          |       3.42 |</span><br><span class="line">| Oil can        |       8.99 |</span><br><span class="line">| Safe           |      50.00 |</span><br><span class="line">| Sling          |       4.49 |</span><br><span class="line">| TNT (1 stick)  |       2.50 |</span><br><span class="line">| TNT (5 sticks) |      10.00 |</span><br><span class="line">+----------------+------------+</span><br></pre></td></tr></table></figure><h2 id="NOT操作符"><a href="#NOT操作符" class="headerlink" title="NOT操作符"></a>NOT操作符</h2><p><strong>NOT</strong> <code>WHERE</code>子句中用来否定后跟条件的关键字。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>过滤数据</title>
      <link href="2021/01/27/%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE/"/>
      <url>2021/01/27/%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h1><h2 id="使用WHERE子句"><a href="#使用WHERE子句" class="headerlink" title="使用WHERE子句"></a>使用WHERE子句</h2><p>在<code>select</code>语句中，数据根据<code>where</code>子句中指定的搜索条件进行过滤。<code>where</code>子句在表名之后给出，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select prod_name, prod_price from products where prod_price &#x3D; 2.50;</span><br><span class="line">+---------------+------------+</span><br><span class="line">| prod_name     | prod_price |</span><br><span class="line">+---------------+------------+</span><br><span class="line">| Carrots       |       2.50 |</span><br><span class="line">| TNT (1 stick) |       2.50 |</span><br><span class="line">+---------------+------------+</span><br></pre></td></tr></table></figure><p><strong>SQL过滤与应用过滤</strong> 数据也可以在应用层过滤。为此目的，SQL的SELECT语句为客户机应用检索超出实际所需的数据，然后客户机代码对返回数据进行循环，以提取出需要的行。但是在客户机上过滤数据，服务器将不得不通过网络发送多余的数据，这将导致网络带宽的浪费。<br><strong>WHERE子句的位置</strong> 在同时使用<code>ORDER BY</code>和<code>WHERE</code>子句时，应该让<code>ORDER BY</code>位于<code>WHERE</code>之后，否则将产生错误。</p><h2 id="WHERE子句操作符"><a href="#WHERE子句操作符" class="headerlink" title="WHERE子句操作符"></a>WHERE子句操作符</h2><p><code>where</code>不仅能进行相等测试，还能进行其他测试，如下所示：  </p><table>  <tr>    <th>操作符</th>    <th>说明</th>  </tr>  <tr>    <td>=</td>    <td>等于</td>  </tr>  <tr>    <td><\></td>    <td>不等于</td>  </tr>  <tr>    <td>!=</td>    <td>不等于</td>  </tr>  <tr>    <td>< </td>    <td>小于</td>  </tr>  <tr>    <td><= </td>    <td>小于等于</td>  </tr>  <tr>    <td>> </td>    <td>大于</td>  </tr>  <tr>    <td>>= </td>    <td>大于等于</td>  </tr>  <tr>    <td>BETWEEN</td>    <td>在指定的两个值之间</td>  </tr></table><h3 id="范围值检查"><a href="#范围值检查" class="headerlink" title="范围值检查"></a>范围值检查</h3><p>为了检查某个返回，我们使用<code>BETWEEN</code>操作符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select prod_name, prod_price</span><br><span class="line">    -&gt; from products</span><br><span class="line">    -&gt; where prod_price between 5 and 10;</span><br><span class="line">+----------------+------------+</span><br><span class="line">| prod_name      | prod_price |</span><br><span class="line">+----------------+------------+</span><br><span class="line">| .5 ton anvil   |       5.99 |</span><br><span class="line">| 1 ton anvil    |       9.99 |</span><br><span class="line">| Bird seed      |      10.00 |</span><br><span class="line">| Oil can        |       8.99 |</span><br><span class="line">| TNT (5 sticks) |      10.00 |</span><br><span class="line">+----------------+------------+</span><br></pre></td></tr></table></figure><p>从这个例子中，我们可以看出，在使用<code>between</code>时，必须指定两个值–所需范围的最大值和最小值，然后这两个值要用<code>AND</code>分割开来，<code>between</code>匹配范围中的所有值，包括两个边界值。</p><h3 id="空值检查"><a href="#空值检查" class="headerlink" title="空值检查"></a>空值检查</h3><p><code>IS NULL</code> 可以用于空值检查。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select cust_id from customers</span><br><span class="line">    -&gt; where cust_email is null;</span><br><span class="line">+---------+</span><br><span class="line">| cust_id |</span><br><span class="line">+---------+</span><br><span class="line">|   10002 |</span><br><span class="line">|   10005 |</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序检索数据</title>
      <link href="2021/01/27/%E6%8E%92%E5%BA%8F%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE/"/>
      <url>2021/01/27/%E6%8E%92%E5%BA%8F%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="排序检索数据"><a href="#排序检索数据" class="headerlink" title="排序检索数据"></a>排序检索数据</h1><h2 id="排序数据"><a href="#排序数据" class="headerlink" title="排序数据"></a>排序数据</h2><p><strong>子句</strong> SQL语句由子句构成，有些子句是必需的，而有些是可选的。一个子句通常由一个关键字和所提供的数据组成。子句的例子有SELECT语句的FROM子句。为了明确地排序用SELECT语句检索的数据，可使用<code>ORDER BY</code>子句。<code>ORDER BY</code>子句取一个或多个列的名字，据此对输出进行排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select prod_name from products order by prod_name;</span><br><span class="line">+----------------+</span><br><span class="line">| prod_name      |</span><br><span class="line">+----------------+</span><br><span class="line">| .5 ton anvil   |</span><br><span class="line">| 1 ton anvil    |</span><br><span class="line">| 2 ton anvil    |</span><br><span class="line">| Bird seed      |</span><br><span class="line">| Carrots        |</span><br><span class="line">| Detonator      |</span><br><span class="line">| Fuses          |</span><br><span class="line">| JetPack 1000   |</span><br><span class="line">| JetPack 2000   |</span><br><span class="line">| Oil can        |</span><br><span class="line">| Safe           |</span><br><span class="line">| Sling          |</span><br><span class="line">| TNT (1 stick)  |</span><br><span class="line">| TNT (5 sticks) |</span><br><span class="line">+----------------+</span><br></pre></td></tr></table></figure><h2 id="按多个列排序和指定排序方向"><a href="#按多个列排序和指定排序方向" class="headerlink" title="按多个列排序和指定排序方向"></a>按多个列排序和指定排序方向</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select prod_name, prod_price, prod_name</span><br><span class="line">    -&gt; from products</span><br><span class="line">    -&gt; order by prod_price DESC, prod_name;</span><br><span class="line">+----------------+------------+----------------+</span><br><span class="line">| prod_name      | prod_price | prod_name      |</span><br><span class="line">+----------------+------------+----------------+</span><br><span class="line">| JetPack 2000   |      55.00 | JetPack 2000   |</span><br><span class="line">| Safe           |      50.00 | Safe           |</span><br><span class="line">| JetPack 1000   |      35.00 | JetPack 1000   |</span><br><span class="line">| 2 ton anvil    |      14.99 | 2 ton anvil    |</span><br><span class="line">| Detonator      |      13.00 | Detonator      |</span><br><span class="line">| Bird seed      |      10.00 | Bird seed      |</span><br><span class="line">| TNT (5 sticks) |      10.00 | TNT (5 sticks) |</span><br><span class="line">| 1 ton anvil    |       9.99 | 1 ton anvil    |</span><br><span class="line">| Oil can        |       8.99 | Oil can        |</span><br><span class="line">| .5 ton anvil   |       5.99 | .5 ton anvil   |</span><br><span class="line">| Sling          |       4.49 | Sling          |</span><br><span class="line">| Fuses          |       3.42 | Fuses          |</span><br><span class="line">| Carrots        |       2.50 | Carrots        |</span><br><span class="line">| TNT (1 stick)  |       2.50 | TNT (1 stick)  |</span><br><span class="line">+----------------+------------+----------------+</span><br></pre></td></tr></table></figure><p>这里先按照<code>prod_price</code>排序，如果其值相同，再按照<code>prod_name</code>排序，<code>DESC</code>是控制排序方向为降序，只作用于其前面的<code>prod_price</code>，然后<code>ASC</code>用来控制升序，但是由于默认升序，所以一般不用。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>检索数据</title>
      <link href="2021/01/26/%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE/"/>
      <url>2021/01/26/%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="检索数据"><a href="#检索数据" class="headerlink" title="检索数据"></a>检索数据</h1><h2 id="SELECT语句"><a href="#SELECT语句" class="headerlink" title="SELECT语句"></a>SELECT语句</h2><p>检索一列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select prod_name from products;</span><br><span class="line">+----------------+</span><br><span class="line">| prod_name      |</span><br><span class="line">+----------------+</span><br><span class="line">| .5 ton anvil   |</span><br><span class="line">| 1 ton anvil    |</span><br><span class="line">| 2 ton anvil    |</span><br><span class="line">| Detonator      |</span><br><span class="line">| Bird seed      |</span><br><span class="line">| Carrots        |</span><br><span class="line">| Fuses          |</span><br><span class="line">| JetPack 1000   |</span><br><span class="line">| JetPack 2000   |</span><br><span class="line">| Oil can        |</span><br><span class="line">| Safe           |</span><br><span class="line">| Sling          |</span><br><span class="line">| TNT (1 stick)  |</span><br><span class="line">| TNT (5 sticks) |</span><br><span class="line">+----------------+</span><br></pre></td></tr></table></figure><p>注：多条sql语句必须以分号（；）分隔。SQL语句不区分大小写，所以SELECT和select是一样的。</p><h2 id="检索多个列"><a href="#检索多个列" class="headerlink" title="检索多个列"></a>检索多个列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select prod_id,prod_name,prod_price from products;</span><br><span class="line">+---------+----------------+------------+</span><br><span class="line">| prod_id | prod_name      | prod_price |</span><br><span class="line">+---------+----------------+------------+</span><br><span class="line">| ANV01   | .5 ton anvil   |       5.99 |</span><br><span class="line">| ANV02   | 1 ton anvil    |       9.99 |</span><br><span class="line">| ANV03   | 2 ton anvil    |      14.99 |</span><br><span class="line">| DTNTR   | Detonator      |      13.00 |</span><br><span class="line">| FB      | Bird seed      |      10.00 |</span><br><span class="line">| FC      | Carrots        |       2.50 |</span><br><span class="line">| FU1     | Fuses          |       3.42 |</span><br><span class="line">| JP1000  | JetPack 1000   |      35.00 |</span><br><span class="line">| JP2000  | JetPack 2000   |      55.00 |</span><br><span class="line">| OL1     | Oil can        |       8.99 |</span><br><span class="line">| SAFE    | Safe           |      50.00 |</span><br><span class="line">| SLING   | Sling          |       4.49 |</span><br><span class="line">| TNT1    | TNT (1 stick)  |       2.50 |</span><br><span class="line">| TNT2    | TNT (5 sticks) |      10.00 |</span><br><span class="line">+---------+----------------+------------+</span><br></pre></td></tr></table></figure><h2 id="检索所有列"><a href="#检索所有列" class="headerlink" title="检索所有列"></a>检索所有列</h2><p>使用通配符*</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from products;</span><br><span class="line">&#x2F;&#x2F;结果比较长不做展示</span><br></pre></td></tr></table></figure><h2 id="检索不同的行"><a href="#检索不同的行" class="headerlink" title="检索不同的行"></a>检索不同的行</h2><p>如果我们想保证输出是不通的怎么办呢，这是后就需要关键字<code>DISTINCT</code>了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select vend_id from products;</span><br><span class="line">+---------+</span><br><span class="line">| vend_id |</span><br><span class="line">+---------+</span><br><span class="line">|    1001 |</span><br><span class="line">|    1001 |</span><br><span class="line">|    1001 |</span><br><span class="line">|    1002 |</span><br><span class="line">|    1002 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1005 |</span><br><span class="line">|    1005 |</span><br><span class="line">+---------+</span><br><span class="line">mysql&gt; select distinct vend_id from products;</span><br><span class="line">+---------+</span><br><span class="line">| vend_id |</span><br><span class="line">+---------+</span><br><span class="line">|    1001 |</span><br><span class="line">|    1002 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1005 |</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure><p>可以看出，再添加了<code>distinct</code>之后，输出保证了，<code>vend_id</code>每个取值不重复出现。<br>注：<code>distinct</code>不能部分使用，如果给出<code>select distinct vend_id, prod_price from products;</code>，除非指定的两个列都相同，否则所有行都将被检索出来。</p><h2 id="限制结果"><a href="#限制结果" class="headerlink" title="限制结果"></a>限制结果</h2><p>可以使用<code>limit</code>语句来限制结果输出的行数，举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select vend_id from products limit 5;</span><br><span class="line">+---------+</span><br><span class="line">| vend_id |</span><br><span class="line">+---------+</span><br><span class="line">|    1001 |</span><br><span class="line">|    1001 |</span><br><span class="line">|    1001 |</span><br><span class="line">|    1002 |</span><br><span class="line">|    1002 |</span><br><span class="line">+---------+</span><br><span class="line">mysql&gt; select vend_id from products limit 5,3;</span><br><span class="line">+---------+</span><br><span class="line">| vend_id |</span><br><span class="line">+---------+</span><br><span class="line">|    1003 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1003 |</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure><p><code>limit 5</code>限制了只输出前五行，然后第二个sql语句中的<code>limit 5,3</code>是从第5行开始输出3行（前面输出了0-5行，行数从0开始计算）。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用MySQL</title>
      <link href="2021/01/26/%E4%BD%BF%E7%94%A8MySQL/"/>
      <url>2021/01/26/%E4%BD%BF%E7%94%A8MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="使用MySQL"><a href="#使用MySQL" class="headerlink" title="使用MySQL"></a>使用MySQL</h1><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Linux&gt; mysql -u xxx -p</span><br><span class="line">&#x2F;&#x2F;xxx是用户名</span><br></pre></td></tr></table></figure><p>然后再输入密码，就可以连接上本地的MySQL服务器了。端口使用默认端口3306。  </p><h2 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h2><p><strong>关键字（key word）</strong>作为MySQL语言组织的一个保留字。不要用关键字命名一个表或列。常见的关键字有<code>use</code>、<code>select</code>、<code>where</code>等等。<br>选择数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use crashcource;</span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure><h2 id="了解数据库和表"><a href="#了解数据库和表" class="headerlink" title="了解数据库和表"></a>了解数据库和表</h2><p>以下命令可以用来展示当前MySQL服务器中有哪些数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mydb               |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| study              |</span><br><span class="line">| sys                |</span><br><span class="line">| webserver_database |</span><br><span class="line">+--------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以下命令可以用来查询当前数据中有哪些表（前提是你已经连接上了数据库）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show tables;</span><br><span class="line">+-----------------+</span><br><span class="line">| Tables_in_study |</span><br><span class="line">+-----------------+</span><br><span class="line">| customers       |</span><br><span class="line">| orderitems      |</span><br><span class="line">| orders          |</span><br><span class="line">| productnotes    |</span><br><span class="line">| products        |</span><br><span class="line">| vendors         |</span><br><span class="line">+-----------------+</span><br></pre></td></tr></table></figure><p>这个数据库内的表是用<a href="https://forta.com/books/0672327120/">MySQL必知必会官方网站</a>上提供的sql脚本<code>create.sql</code>、<code>populate.sql</code>生成的。生成方式如下（你需要先将文件下载下来）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database XXX;</span><br><span class="line">&#x2F;&#x2F; XXX是你创建的数据库，名字你可以任意定义</span><br><span class="line">mysql&gt; use XXX;</span><br><span class="line">mysql&gt; source create.sql;</span><br><span class="line">&#x2F;&#x2F; 此文件创建表</span><br><span class="line">mysql&gt; source populate.sql; </span><br><span class="line">&#x2F;&#x2F; 创建完成了</span><br></pre></td></tr></table></figure><p>如下方法可以显示表中所有可用的列，以及相关参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show columns from customers;</span><br><span class="line">+--------------+-----------+------+-----+---------+----------------+</span><br><span class="line">| Field        | Type      | Null | Key | Default | Extra          |</span><br><span class="line">+--------------+-----------+------+-----+---------+----------------+</span><br><span class="line">| cust_id      | int(11)   | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| cust_name    | char(50)  | NO   |     | NULL    |                |</span><br><span class="line">| cust_address | char(50)  | YES  |     | NULL    |                |</span><br><span class="line">| cust_city    | char(50)  | YES  |     | NULL    |                |</span><br><span class="line">| cust_state   | char(5)   | YES  |     | NULL    |                |</span><br><span class="line">| cust_zip     | char(10)  | YES  |     | NULL    |                |</span><br><span class="line">| cust_country | char(50)  | YES  |     | NULL    |                |</span><br><span class="line">| cust_contact | char(50)  | YES  |     | NULL    |                |</span><br><span class="line">| cust_email   | char(255) | YES  |     | NULL    |                |</span><br><span class="line">+--------------+-----------+------+-----+---------+----------------+</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Makefile学习</title>
      <link href="2021/01/23/Makefile%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/01/23/Makefile%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux编译过程"><a href="#Linux编译过程" class="headerlink" title="Linux编译过程"></a>Linux编译过程</h1><ol><li>-E 预处理：把 .h、.c文件展开形成一个个文件。宏定义直接替换头文件、库文件。最后生成.i文件。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> gcc -E hello.c -o hello.i</span></span><br></pre></td></tr></table></figure></li><li>-S 汇编： .i文件生成一个汇编代码文件 .s<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> gcc -S hello.i -o hello.s</span></span><br></pre></td></tr></table></figure></li><li>-c 编译： .s文件生成一个.o文件<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> gcc -C hello.s -o hello.o</span></span><br></pre></td></tr></table></figure></li><li>-o 链接：生成可运行文件 hello<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> gcc hello.o hello</span></span><br></pre></td></tr></table></figure></li><li>也可以直接来<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> gcc hello.c -o hello</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="脚本语言：Makefile"><a href="#脚本语言：Makefile" class="headerlink" title="脚本语言：Makefile"></a>脚本语言：Makefile</h1><p>Linux C/C++ 必须要使用的一个编译脚本。<br>Makefile 大型项目开发。</p><ol><li>第一层：显示规则<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#是注释</span></span><br><span class="line"><span class="comment">#第一层：显示规则</span></span><br><span class="line"><span class="comment">#目标文件：依赖文件</span></span><br><span class="line"><span class="comment">#[TAB]指令</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#第一个目标文件应该是我的最终文件！！！（递归思维）</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#rm -rf hello.o hello.S hello.i hello</span></span><br><span class="line"><span class="comment">#伪目标：.PHONY</span></span><br><span class="line"><span class="section">hello:hello.o</span></span><br><span class="line">gcc hello.o -o hello</span><br><span class="line"><span class="section">hello.o:hello.S</span></span><br><span class="line">gcc -c hello.S -o hello.o</span><br><span class="line"><span class="section">hello.S:hello.i</span></span><br><span class="line">gcc -S hello.i -o hello.S</span><br><span class="line"><span class="section">hello.i:hello.c</span></span><br><span class="line">gcc -E hello.c -o hello.i</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:</span></span><br><span class="line"><span class="section">clearall:</span></span><br><span class="line">rm -rf hello.o hello.S hello.i hello</span><br><span class="line"><span class="section">clear:</span></span><br><span class="line">    rm -rf hello.o hello.S hello.i</span><br></pre></td></tr></table></figure></li><li>第二层<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#变量 =(替换)  +=(追加)  :=(常量)</span></span><br><span class="line">TAR = test</span><br><span class="line">OBJ = circle.o cube.o main.o</span><br><span class="line">CC := gcc</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TAR)</span>:<span class="variable">$(OBJ)</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$(TAR)</span></span><br><span class="line"></span><br><span class="line"><span class="section">circle.o:circle.c</span></span><br><span class="line"><span class="variable">$(CC)</span> -c circle.c -o circle.o</span><br><span class="line"><span class="section">cube.o:cube.c</span></span><br><span class="line"><span class="variable">$(CC)</span> -c cube.c -o cube.o</span><br><span class="line"><span class="section">main.o:main.c</span></span><br><span class="line"><span class="variable">$(CC)</span> -c main.c -o main.o</span><br></pre></td></tr></table></figure></li><li>第三层：隐含规则<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># %.c $.o 任意的.c或者.o   *.c *.o所有的.c .o</span></span><br><span class="line">TAR = test</span><br><span class="line">OBJ = circle.o cube.o main.o</span><br><span class="line">CC := gcc</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TAR)</span>:<span class="variable">$(OBJ)</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(OBJ)</span> -o <span class="variable">$(TAR)</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line"><span class="variable">$(CC)</span> -c %.c -o %.o </span><br></pre></td></tr></table></figure></li><li>第四层：通配符<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $@所有的目标文件</span></span><br><span class="line"><span class="comment"># $^所有的依赖文件</span></span><br><span class="line"><span class="comment"># $&lt;所有的依赖文件的第一个文件</span></span><br><span class="line">TAR = test</span><br><span class="line">OBJ = circle.o cube.o main.o</span><br><span class="line">CC := gcc</span><br><span class="line">RMRF := rm -rf</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TAR)</span>:<span class="variable">$(OBJ)</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$^</span> -o <span class="variable">$@</span> </span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:</span></span><br><span class="line"><span class="section">clearall:</span></span><br><span class="line">    <span class="variable">$(RMRF)</span> <span class="variable">$(OBJ)</span> <span class="variable">$(TAR)</span></span><br><span class="line"><span class="section">clear:</span></span><br><span class="line">    <span class="variable">$(RMRF)</span> <span class="variable">$(OBJ)</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL API</title>
      <link href="2021/01/22/MySQL-API/"/>
      <url>2021/01/22/MySQL-API/</url>
      
        <content type="html"><![CDATA[<p>常见的MySQL API函数如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MYSQL *<span class="title">mysql_real_connect</span> <span class="params">(MYSQL *mysql,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">char</span> *host,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">char</span> *user, </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">char</span> *passwd, </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">char</span> *db, </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> port,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">char</span> *unix_socket,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">long</span> client_flag)</span></span>;</span><br><span class="line"><span class="comment">// 返回一个MYSQL指针，host未null或者localhost时链接本地的计算机</span></span><br><span class="line"><span class="comment">// user和passwd是账号和密码</span></span><br><span class="line"><span class="comment">// db是数据库名称，port是端口，MySQL服务器默认端口号是3306</span></span><br><span class="line"><span class="comment">// unix_socket为null标识不适用socket或管道机制，最后一个参数经常设置为0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mysql_select_db</span><span class="params">(MYSQL *mysql,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">char</span> *db)</span></span>;</span><br><span class="line"><span class="comment">// 选择一个数据库，db是数据库名，类似 USE</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mysql_query</span><span class="params">(MYSQL *mysql, <span class="keyword">const</span> <span class="keyword">char</span> *q)</span></span>;</span><br><span class="line"><span class="comment">// 建立一个查询，q是查询语句，C风格字符串，内容语法和MySQL一致</span></span><br><span class="line"></span><br><span class="line"><span class="function">MYSQL_RES *<span class="title">mysql_store_result</span><span class="params">(MYSQL *mysql)</span></span>;</span><br><span class="line"><span class="comment">// 将全部数据保存在本机</span></span><br><span class="line"><span class="comment">// 返回一个结果指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">mysql_num_fields</span><span class="params">(MYSQL_RES *res)</span></span>;</span><br><span class="line"><span class="comment">// 返回结果集的行数</span></span><br><span class="line"></span><br><span class="line"><span class="function">MYSQL_FIELD *<span class="title">mysql_fetch_fields</span><span class="params">(MYSQL_RES *res)</span></span>;</span><br><span class="line"><span class="comment">// 对于结果集，返回所有MYSQL_FIELD结构的数组。每个结构提供了结果集中1列的字段定义。</span></span><br><span class="line"></span><br><span class="line"><span class="function">MYSQL_ROW <span class="title">mysql_fetch_row</span><span class="params">(MYSQL_RES *result)</span></span>;</span><br><span class="line"><span class="comment">// 检索结果集的下一行。在mysql_store_result()之后使用时，如果没有要检索的行，mysql_fetch_row()返回NULL。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mysql_close</span><span class="params">(MYSQL *sock)</span></span>;</span><br><span class="line"><span class="comment">// 关闭一个数据库连接</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最小生成树</title>
      <link href="2021/01/19/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>2021/01/19/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h1><p>本算法性质是集合A中的边总是构成一棵树。<br>算法原理：<br>这棵树从任意的根结点r开始，一直长大到覆盖V中的所有结点时为止。算法每一步在连接集合A和A之外的结点的所有边中，选择一条权重最低的结边加入到A中。  </p><p>为了有效的实现Prim算法，需要一种快速的方法来选择一条新的边，以便加入到由集合A中所有边所构成的树里。在下面的伪代码中，连通图G和最小生成树的根结点r将作为算法的输入。在算法的执行过程中，所有不在树A中的结点都存放在一个基于key属性的最小优先队列Q中。对每个结点v，v.key保存的是连接v和树中结点的所有边中的最小边的权重。<br>伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MST-PRIM(G,w,r)</span><br><span class="line">for each u in G.V</span><br><span class="line">u:key &#x3D; inf</span><br><span class="line">u:p &#x3D; none</span><br><span class="line">r:key&#x3D;0</span><br><span class="line">Q&#x3D;G.V</span><br><span class="line">while Q!&#x3D;空集</span><br><span class="line">u&#x3D;extract-min(Q)</span><br><span class="line">for each v in G.adj[u]</span><br><span class="line">if v in Q and w(u,v)&lt;v.key</span><br><span class="line">v.p&#x3D;u</span><br><span class="line">v.key&#x3D;w(u,v)</span><br></pre></td></tr></table></figure><h1 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h1><p>在所连接森林中两棵不同树的边里面，找到权重最小的边(u,v)。设C1和C2为边(u,v)所连接的两棵树。由于边(u,v)一定是连接C1和其他某棵树的一条轻量级边，边(u,v)是C1的一条安全边。很显然，Kruskal算法属于贪心算法，因为它每次都选择一条权重最小的边加入到森林。<br>我们使用一个不相交集合数据结构来维护几个互不相交的元素集合。每个集合代表当前森林中的一棵树。操作FIND-SET(v)用来返回包含元素u的集合的代表元素。我们可以通过测试FIND-SET(u)是否等于FIND-SET(v)来判断结点u和结点v是否属于同一棵树。Kruskal算法使用UNION过程来对两棵树合并。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MST-KRUSKAL(G,w)</span><br><span class="line">A&#x3D;空集</span><br><span class="line">for each vertex v in G.V</span><br><span class="line">MAKE-SET(v)</span><br><span class="line">sort the edge of G.E into nondecreasing order by weight w</span><br><span class="line">for each edge(u,v) in G.E,taken in nondecreasing order by weight</span><br><span class="line">if FIND-SET(v)!&#x3D;FIND-SET(v)</span><br><span class="line">A&#x3D;A 并 &#123;(u,v)&#125;</span><br><span class="line">UNION(u,v)</span><br><span class="line">return A</span><br></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points/">链接</a></p><h2 id="Prim算法-1"><a href="#Prim算法-1" class="headerlink" title="Prim算法"></a>Prim算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">distance</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; a,vector&lt;<span class="keyword">int</span>&gt;&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(a[<span class="number">0</span>]-b[<span class="number">0</span>])+<span class="built_in">abs</span>(a[<span class="number">1</span>]-b[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostConnectPoints</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">matrix</span>(n,vector&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">                matrix[j][i]=matrix[i][j]=<span class="built_in">distance</span>(points[i],points[j]);</span><br><span class="line">        <span class="comment">// 从点0开始生成最小生成树</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(n,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cost</span><span class="params">(n,INT_MAX)</span></span>;</span><br><span class="line">        visited[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cost[i]=matrix[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> min_index,min_cost=INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(visited[j])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(cost[j]&lt;min_cost)&#123;</span><br><span class="line">                    min_cost=cost[j];</span><br><span class="line">                    min_index=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res+=min_cost;</span><br><span class="line">            visited[min_index]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(visited[j])<span class="keyword">continue</span>;</span><br><span class="line">                cost[j]=<span class="built_in">min</span>(cost[j],matrix[min_index][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>堆实现版本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt;&amp; points, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将points转化成邻接矩阵</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">g</span>(n, vector&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> dist = <span class="built_in">abs</span>(points[i][<span class="number">0</span>] - points[j][<span class="number">0</span>]) + <span class="built_in">abs</span>(points[i][<span class="number">1</span>] - points[j][<span class="number">1</span>]);</span><br><span class="line">                g[i][j] = dist;</span><br><span class="line">                g[j][i] = dist;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 记录V[i]到Vnew的最近距离</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">lowcost</span><span class="params">(n, INT_MAX)</span></span>;</span><br><span class="line">        <span class="comment">// 记录V[i]是否加入到了Vnew</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 格式：&lt;距离, 下标&gt;</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;, greater&lt;&gt; &gt; pq;</span><br><span class="line">        pq.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, start));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [dist, i] = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (v[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            v[i] = <span class="number">0</span>;</span><br><span class="line">            res += dist;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> w = g[i][j];</span><br><span class="line">                <span class="keyword">if</span> (v[j] == <span class="number">-1</span> &amp;&amp; lowcost[j] &gt; w) &#123;</span><br><span class="line">                    lowcost[j] = w;</span><br><span class="line">                    pq.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(w, j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostConnectPoints</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">prim</span>(points, <span class="number">0</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>作者：yexiso<br><a href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points/solution/prim-and-kruskal-by-yexiso-c500/">链接</a></p><h2 id="Kruskal算法-1"><a href="#Kruskal算法-1" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Djset</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; parent; <span class="comment">// 记录节点的根</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; rank;   <span class="comment">// 记录根节点的深度（用于优化）</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; size;   <span class="comment">// 记录每个连通分量的节点个数</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; len;    <span class="comment">// 记录每个连通分量里的所有边长度</span></span><br><span class="line">    <span class="keyword">int</span> num;            <span class="comment">// 记录节点个数</span></span><br><span class="line">    <span class="built_in">Djset</span>(<span class="keyword">int</span> n): <span class="built_in">parent</span>(n), <span class="built_in">rank</span>(n), <span class="built_in">len</span>(n, <span class="number">0</span>), <span class="built_in">size</span>(n, <span class="number">1</span>), <span class="built_in">num</span>(n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 压缩方式：直接指向根节点</span></span><br><span class="line">        <span class="keyword">if</span> (x != parent[x]) &#123;</span><br><span class="line">            parent[x] = <span class="built_in">find</span>(parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootx = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">int</span> rooty = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (rootx != rooty) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rank[rootx] &lt; rank[rooty]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(rootx, rooty);</span><br><span class="line">            &#125;</span><br><span class="line">            parent[rooty] = rootx;</span><br><span class="line">            <span class="keyword">if</span> (rank[rootx] == rank[rooty]) rank[rootx] += <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// rooty的父节点设置为rootx,同时将rooty的节点数和边长度累加到rootx,</span></span><br><span class="line">            size[rootx] += size[rooty];</span><br><span class="line">            len[rootx] += len[rooty] + length;</span><br><span class="line">            <span class="comment">// 如果某个连通分量的节点数 包含了所有节点，直接返回边长度</span></span><br><span class="line">            <span class="keyword">if</span> (size[rootx] == num) <span class="keyword">return</span> len[rootx];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> start; <span class="comment">// 顶点1</span></span><br><span class="line">    <span class="keyword">int</span> end;   <span class="comment">// 顶点2</span></span><br><span class="line">    <span class="keyword">int</span> len;   <span class="comment">// 长度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostConnectPoints</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">Djset <span class="title">ds</span><span class="params">(n)</span></span>;</span><br><span class="line">        vector&lt;Edge&gt; edges;</span><br><span class="line">        <span class="comment">// 建立点-边式数据结构</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                Edge edge = &#123;i, j, <span class="built_in">abs</span>(points[i][<span class="number">0</span>] - points[j][<span class="number">0</span>]) + <span class="built_in">abs</span>(points[i][<span class="number">1</span>] - points[j][<span class="number">1</span>])&#125;;</span><br><span class="line">                edges.<span class="built_in">emplace_back</span>(edge);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 按边长度排序</span></span><br><span class="line">        <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>(), [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a.len &lt; b.len;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连通分量合并</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : edges) &#123;</span><br><span class="line">           res = ds.<span class="built_in">merge</span>(e.start, e.end, e.len);</span><br><span class="line">           <span class="keyword">if</span> (res != <span class="number">-1</span>) <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CH12并发编程</title>
      <link href="2021/01/14/CH12%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>2021/01/14/CH12%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><p>现代操作系统提供三种基本的构造并发程序的方法：</p><ul><li>进程</li><li>I/O多路复用</li><li>线程</li></ul><h2 id="基于进程的并发编程"><a href="#基于进程的并发编程" class="headerlink" title="基于进程的并发编程"></a>基于进程的并发编程</h2><p>构造并发进程最简单的方法就是用进程。<br>服务器接受连接请求-&gt;返回一个已连接描述符（假设为4）-&gt;服务器派生一个子进程-&gt;关闭原服务器的已连接描述符4的副本（避免内存崩溃）。</p><h3 id="基于进程的并发服务器"><a href="#基于进程的并发服务器" class="headerlink" title="基于进程的并发服务器"></a>基于进程的并发服务器</h3><ul><li>首先，通常服务器会允许很长时间，所以我们必须要包括一个SIGCHLD处理程序来回收僵死子进程的资源。因为当SIGCHLD处理程序执行时，SIGCHLD信号是阻塞的，而Linux信号是不排队的，所以SIGCHLD处理程序必须准备好回收多个僵尸子进程的资源。</li><li>其次父子进程必须关闭它们各自的connfd副本。就像我们已经提到过的，这对父进程而言尤为重要，它必须关闭它的已连接描述符，以避免内存泄露。</li><li>最后，因为套接字的文件表表项中的引用计数，直到父子进程的connfd都关闭了，到客户端的连接才会终止。</li></ul><h3 id="进程的优劣"><a href="#进程的优劣" class="headerlink" title="进程的优劣"></a>进程的优劣</h3><p>对于在父、子进程间共享状态信息，进程有一个非常清晰的模型：共享文件表，但是不共享用户地址空间。进程有独立的地址空间一方面避免了进程不小心覆盖另一个进程的虚拟内存，另一方面使得进程共享状态信息更加困难。为了共享信息，它们必须使用显式的IPC（进程间通信）机制。</p><h2 id="基于I-O多路复用的并发编程"><a href="#基于I-O多路复用的并发编程" class="headerlink" title="基于I/O多路复用的并发编程"></a>基于I/O多路复用的并发编程</h2><p>假设要求你编写一个echo服务器，它也能对用户从标准输入键入的交互 命令做出响应。在这个情况下服务器必须响应两个互相独立的I/O事件（连接请求何用户在键盘键入命令行），我们先等待哪个事件呢？针对这种问题的一个解决办法是I/O多路复用计数，基本思路就是使用select函数，要求内核挂起进程，只有在一个或多个I/O事件发生后，才将控制返回给相应的应用程序。<br>（<strong>跳过</strong>）</p><h2 id="基于线程的并发编程"><a href="#基于线程的并发编程" class="headerlink" title="基于线程的并发编程"></a>基于线程的并发编程</h2><p>线程（Thread）就是运行在进程上下文中的逻辑流。线程由内核自动调度，每个线程都有它自己的线程上下文，包括一个唯一的整数线程ID（Thread ID，TID）、栈、栈指针、程序计数器、通用目的寄存器何条件码。所有的运行在一个进程里的线程共享该进程的整个虚拟地址空间。</p><h3 id="线程执行模型"><a href="#线程执行模型" class="headerlink" title="线程执行模型"></a>线程执行模型</h3><p>每个进程开始生命周期时都是单一线程，这个线程称为主线程（math thread），在某一时刻主线程创建一个对等线程，从这个时间点开始，两个线程就并发地运行了。最后，因为主线程执行一个慢速系统调用，例如read或者sleep，或者因为被系统的间隔计时器中断，控制就会通过上下文切换传递到对等线程。对等线程会执行一段时间；然后控制传回主线程，依次类推。  </p><h3 id="Posix线程"><a href="#Posix线程" class="headerlink" title="Posix线程"></a>Posix线程</h3><p>Posix线程是在C程序中处理线程的一个标准接口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*调用命令：gcc main.c -o main -pthread*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid,<span class="literal">NULL</span>,thread,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line">    <span class="built_in">pthread_join</span>(tid,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> *(func)(<span class="keyword">void</span> *);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *tid,<span class="keyword">pthread_attr_t</span> *attr,func *f,<span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure><p><code>pthread_create</code>函数创建一个新的进程，并带着一个输入变量arg，在新进程的上下文运行线程例程f。能用attr参数来改变新创建线程的默认属性（已超出范围，在示例中总是用一个为NULL的attr参数来调用pthread_create函数）。<br>当<code>pthread_create</code>函数返回时，参数tid包含新创建线程的ID。新线程可以通过调用<code>pthread_self</code>函数来获得它自己的线程ID。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h3><p>一个线程以下列方式之一来终止的：</p><ul><li>当顶层的线程例程返回时，线程会隐式地终止。</li><li>通过调用<code>pthread_exit</code>函数，线程会显式地终止。如果主线程调用<code>pthread_exit</code>，它会等待所有其他对等线程终止，然后再终止主线程和整个进程，返回值为<code>thread_return</code>。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *thread_return)</span></span>;</span><br></pre></td></tr></table></figure></li><li>某个对等线程调用Linux的<code>exit()</code>函数，该函数终止进程以及所有与该进程相关的线程。</li><li>另一个对等线程通过以当前线程ID为参数调用<code>pthread_cancel</code>函数来终止当前进程。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="回收已终止线程的资源"><a href="#回收已终止线程的资源" class="headerlink" title="回收已终止线程的资源"></a>回收已终止线程的资源</h3><p>线程通过调用<code>pthread_join</code>函数等待其他线程终止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> tid,<span class="keyword">void</span> **thread_return)</span></span>;</span><br></pre></td></tr></table></figure><p><code>pthread_join</code>函数会阻塞，直到tid线程终止，然后将线程例程返回的通用<code>(void *)</code>指针赋值为<code>thread_return</code>指向的位置，然后回收已终止线程占用的所有内存资源。</p><h3 id="分离线程"><a href="#分离线程" class="headerlink" title="分离线程"></a>分离线程</h3><p>在任何一个时间点上，线程是<strong>可结合的</strong>或者是<strong>分离的</strong>。一个可结合的线程是能够被其他线程收回和杀死。在被其他线程回收之前，它的内存资源是不释放的。相反，一个分离的线程是不能被其他线程回收或杀死的。它的内存资源在它终止时由系统自动释放。<br>默认情况下，线程被创建为可结合的，为了避免内存泄露，每个可结合线程都应该要么被其他线程显式地收回，要么通过调用<code>pthread_detach</code>函数被分离。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="初始化线程"><a href="#初始化线程" class="headerlink" title="初始化线程"></a>初始化线程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_once</span><span class="params">(<span class="keyword">pthread_once_t</span> *once_control,<span class="keyword">void</span> (*init_routine)(<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>once_control 变量是一个全局或者静态变量，总是被初始化为PTHREAD_ONCE_INIT。当你第一次用参数once_control调用pthread_once时，它调用init_routine，这是一个没有输入参数、声明也不返回的函数。</p><h3 id="基于线程并发服务器"><a href="#基于线程并发服务器" class="headerlink" title="基于线程并发服务器"></a>基于线程并发服务器</h3><h2 id="基于线程程序中的共享变量"><a href="#基于线程程序中的共享变量" class="headerlink" title="基于线程程序中的共享变量"></a>基于线程程序中的共享变量</h2><h3 id="线程内存模型"><a href="#线程内存模型" class="headerlink" title="线程内存模型"></a>线程内存模型</h3><p>每个线程和其他线程一起共享进程上下文的剩余部分。这包括整个用户虚拟地址空间，它是由只读<br>文本、读/写数据、堆以及所有的共享库代码和数据区域组成的。线程也共享相同的打开文件集合。</p><h3 id="将变量映射到内存"><a href="#将变量映射到内存" class="headerlink" title="将变量映射到内存"></a>将变量映射到内存</h3><ul><li><strong>全局变量</strong><br>定义在函数之外的变量，在运行时，虚拟内存的读/写区域只包含每个全局变量的一个实例，任何线程都可以引用。</li><li><strong>本地自动变量</strong><br>定义在函数内部但是没有static属性的变量。</li><li><strong>本地静态变量</strong><br>定义在函数内部并有static属性的变量。</li></ul><h3 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h3><p>我们说一个变量$v$是共享的，当且仅当它的一个实例被一个以上的线程引用。</p><h2 id="用信号量同步线程"><a href="#用信号量同步线程" class="headerlink" title="用信号量同步线程"></a>用信号量同步线程</h2><p>共享变量十分方便，但是它们也引入了同步错误的可能性。</p><h3 id="进度图"><a href="#进度图" class="headerlink" title="进度图"></a>进度图</h3><p><strong>临界区</strong>（在线程中操作共享变量的指令），这个临界区不应该和其他进程的临界区交替执行。我们想要确保每个线程在执行它的临界区中的指令时，拥有对共享变量的互斥的访问，通常这种现象称为<strong>互斥</strong>。<br>在进度图中，两个临界区的交集形成的状态空间称为<strong>不安全区</strong>。  </p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量s是具有非负整数值的全局变量，只能由两种特殊的操作来处理，这两种操作称为P和V：</p><ul><li>P(s)：如果s是非零的，那么P将s减1，并且立即返回。如果S为零，那么就挂起这个线程，直到s变为非零，而一个V操作会重启这个线程。在重启之后，P操作将s减1，并将控制权返回给调用者。</li><li>V(s)：V操作将s加1，如果有任何线程阻塞在P操作等待s变为非零，那么V操作将会重启这些线程中的一个，然后该线程将s减1，完成它的P操作。<br>P中测试和减1操作是不可分割的，也就是说，一旦预测信号量变为非零，那么V操作会重启这些线程中的一个，然后该线程将s减1，完成它的P操作。<br>P中的测试和减1操作是不可分割的。V中的加1操作是不可分割的（也就是加载、加1和存储信号是V必须只能重启一个正在等待的线程）。<br>P和V的定义保证了一个正在运行的程序不可能进入到一种信号量为负值的状态，为控制并发程序的轨迹线提供了强有力的工具。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> *sem,<span class="number">0</span>,<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> *s)</span></span>;</span><br></pre></td></tr></table></figure>sem_init函数将信号量sem初始化为value。每个信号量在使用前必须初始化。针对我们的目的，中间的参数总是为0.程序通过调用sem_wait和sem_post函数来执行P和V操作。</li></ul><h3 id="使用信号量来实现互斥"><a href="#使用信号量来实现互斥" class="headerlink" title="使用信号量来实现互斥"></a>使用信号量来实现互斥</h3><p>基本思想是将每个共享比那辆与一个信号量s联系起来，然后用P(s)和V(s)操作将相应的临界区包围起来。以这种方式保护起来共享变量的信号量叫做二元信号量（因为总是为0/1）。以提供互斥为目的的二元信号量常常也称为互斥锁。在一个互斥锁上执行P操作称为对互斥锁加锁，执行V操作称为对互斥锁解锁。</p><h3 id="利用信号量来调度共享资源"><a href="#利用信号量来调度共享资源" class="headerlink" title="利用信号量来调度共享资源"></a>利用信号量来调度共享资源</h3><ol><li>生产者-消费者问题<br>生产者和消费者进程共享有n个槽的有限缓冲区。生产者线程反复地生成新的项目，并把它们插入到缓冲区中。消费者线程不断地从缓冲区中取出这些项目，然后消费（使用）它们。<br>因为插入和取出都涉及更新共享变量，所以我们必须保证缓冲区的访问时互斥的，但仅仅互斥是不够的，我们还需要调度对缓冲区的访问。如果缓冲区时满的，那么生产者必须等待直到有槽位变为可用。与之相似的，如果缓冲区时空的，消费者必须等待直到有一个项目变为可用。</li></ol><p><strong>例子</strong>：在一个多媒体系统中生产者编码视频帧，而消费者解码并在屏幕中呈现出来，缓冲区的目的时为了减少视频流的抖动。<br>下面是一个简单的用来构造生产者-消费者程序的包:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *buf;          <span class="comment">/* Buffer array */</span>         </span><br><span class="line">    <span class="keyword">int</span> n;             <span class="comment">/* 规模 */</span></span><br><span class="line">    <span class="keyword">int</span> front;         <span class="comment">/* 记录该数组的第一项，buf[(front+1)%n] is first item */</span></span><br><span class="line">    <span class="keyword">int</span> rear;          <span class="comment">/* 记录该数组的最后一项，buf[rear%n] is last item */</span></span><br><span class="line">    <span class="keyword">sem_t</span> mutex;       <span class="comment">/* 提供互斥的缓冲区访问 */</span></span><br><span class="line">    <span class="keyword">sem_t</span> slots;       <span class="comment">/* 记录空槽位 */</span></span><br><span class="line">    <span class="keyword">sem_t</span> items;       <span class="comment">/* 记录可用项目的数量 */</span></span><br><span class="line">&#125; <span class="keyword">sbuf_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_init</span><span class="params">(<span class="keyword">sbuf_t</span> *sp, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">/*为缓冲区分配堆内存，并为三个信号量设置初值*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_deinit</span><span class="params">(<span class="keyword">sbuf_t</span> *sp)</span></span>;</span><br><span class="line"><span class="comment">/*sbuf_deinit函数是当应用程序使用万缓冲区时，释放缓冲区存储的*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_insert</span><span class="params">(<span class="keyword">sbuf_t</span> *sp, <span class="keyword">int</span> item)</span></span>;</span><br><span class="line"><span class="comment">/*sbuf_insert函数等待一个可用的槽位，对互斥锁加锁，添加项目，对互斥锁解锁*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sbuf_remove</span><span class="params">(<span class="keyword">sbuf_t</span> *sp)</span></span>;</span><br><span class="line"><span class="comment">/*sbuf_remove函数和sbuf_insert函数是对称的在等待一个可用的缓冲区项目后，</span></span><br><span class="line"><span class="comment">对互斥锁加锁，从缓冲区的前面取出该项目，对互斥锁解锁*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_init</span><span class="params">(<span class="keyword">sbuf_t</span> *sp, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp-&gt;buf = <span class="built_in">calloc</span>(n, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)); </span><br><span class="line">    sp-&gt;n = n;                       <span class="comment">/* Buffer holds max of n items */</span></span><br><span class="line">    sp-&gt;front = sp-&gt;rear = <span class="number">0</span>;        <span class="comment">/* Empty buffer iff front == rear */</span></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;sp-&gt;mutex, <span class="number">0</span>, <span class="number">1</span>);      <span class="comment">/* Binary semaphore for locking */</span></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;sp-&gt;slots, <span class="number">0</span>, n);      <span class="comment">/* Initially, buf has n empty slots */</span></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;sp-&gt;items, <span class="number">0</span>, <span class="number">0</span>);      <span class="comment">/* Initially, buf has zero data items */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_deinit</span><span class="params">(<span class="keyword">sbuf_t</span> *sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(sp-&gt;buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_insert</span><span class="params">(<span class="keyword">sbuf_t</span> *sp, <span class="keyword">int</span> item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;sp-&gt;slots);                          <span class="comment">/* Wait for available slot */</span></span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;sp-&gt;mutex);                          <span class="comment">/* Lock the buffer */</span></span><br><span class="line">    sp-&gt;buf[(++sp-&gt;rear)%(sp-&gt;n)] = item;   <span class="comment">/* Insert the item */</span></span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;sp-&gt;mutex);                          <span class="comment">/* Unlock the buffer */</span></span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;sp-&gt;items);                          <span class="comment">/* Announce available item */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sbuf_remove</span><span class="params">(<span class="keyword">sbuf_t</span> *sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;sp-&gt;items);                          <span class="comment">/* Wait for available item */</span></span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;sp-&gt;mutex);                          <span class="comment">/* Lock the buffer */</span></span><br><span class="line">    item = sp-&gt;buf[(++sp-&gt;front)%(sp-&gt;n)];  <span class="comment">/* Remove the item */</span></span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;sp-&gt;mutex);                          <span class="comment">/* Unlock the buffer */</span></span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;sp-&gt;slots);                          <span class="comment">/* Announce available slot */</span></span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>读者-写者问题<br>这是一个互斥问题的概括，一组并发的程序要访问一个共享对象，例如一个主存中的数据结构，或者一个磁盘上的数据库。有些线程只读对象（读者），而其他线程只修改对象（写者）。<br>读者-写者问题的几个变种：  </li></ol><ul><li>读者优先，要求不让读者等待。</li><li>写者优先，要求一旦一个写者准备好可以写，它就会尽可能快地完成它的写操作。 </li></ul><h3 id="综合：基于预线程化的并发服务器"><a href="#综合：基于预线程化的并发服务器" class="headerlink" title="综合：基于预线程化的并发服务器"></a>综合：基于预线程化的并发服务器</h3><p>（跳过）</p><h2 id="使用线程提高并行性"><a href="#使用线程提高并行性" class="headerlink" title="使用线程提高并行性"></a>使用线程提高并行性</h2><h2 id="其他并发问题"><a href="#其他并发问题" class="headerlink" title="其他并发问题"></a>其他并发问题</h2><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>四个线程不安全函数类：</p><ol><li>不保护共享变量的函数</li><li>保持跨越多个调用的状态的函数</li><li>返回指向静态变量的指针的函数</li><li>调用线程不安全的函数</li></ol><h3 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h3><h3 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h3><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>互斥锁加锁顺序规则：给定所有互斥锁操作的一个全序，如果每个线程都是以一种顺序获得互斥锁并以相反的顺序释放，那么这个程序就是无死锁的。</p>]]></content>
      
      
      <categories>
          
          <category> 深入理解计算机系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CH11网络编程</title>
      <link href="2021/01/14/CH11%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>2021/01/14/CH11%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a><strong>网络编程</strong></h1><h2 id="客户端-服务器编程模型"><a href="#客户端-服务器编程模型" class="headerlink" title="客户端-服务器编程模型"></a>客户端-服务器编程模型</h2><p>流程：  </p><ol><li>客户端发送请求  </li><li>服务器处理请求  </li><li>服务器发送响应  </li><li>客户端处理相应   </li></ol><p>值得注意的是：客户端和服务器都是指进程而非主机，一个主机上可以允许多个客户端进程、服务器进程。</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>网络-&gt;网络适配器（网卡）-&gt;I/O和内存总线-&gt;内存。<br>网络是一个按照地理位置远近组成的层次结构，最底层是LAN（Local Area Network，局域网）。最流行的局域网技术是以太网（一个以太网段包含一个些电缆和一个集线器）。使用一个些电缆和叫做网桥（bridge）的小盒子，多个以太网段可以连接成较大的局域网，称为桥连接以太网。<br>在层次的更高级别中，多个不兼容的局域网可以由一个叫做路由器的特殊计算机连接起来，组成一个互联网络（internet）。<br>一般来说，路由器可以用来由各种局域网和广域网（WAN）构建互联网络。<br>互联网至关重要的特性就是它能由采用完全不同和不兼容的计数的各种局域网和广域网组成。但是如何能够让某台源主机跨越所有这些不兼容的网络发送数据位到另一台目的主机呢？解决办法就是一层允许在每台主机和路由器上的协议软件。这种协议必须提供两种基本能力：  </p><ol><li>命名机制：每台主机至少被分配一个这种互联网络地址，这个地址唯一地标识了这台主机。  </li><li>传送机制：互联网络协议通过定义一种把数据捆扎成不连续的片（称为<strong>包</strong>）的统一方式来消除差异。包包括包头和有效载荷，包头包括包的大小以及源主机和目的主机的地址，有效载荷包括从源主机发出的数据位。  </li></ol><h2 id="全球IP因特网"><a href="#全球IP因特网" class="headerlink" title="全球IP因特网"></a>全球IP因特网</h2><p>每台因特网主机都运行实现TCP/IP协议。<br>TCP/IP实际上是一个协议族，其中每个提供不同的功能。例如，IP协议提供基本的命名方法和递送机制（不可靠，如果数据报在网络中丢失并不会试图恢复）。UDP稍微扩展了IP协议，这样一来包可以在进程间而不是主机间传送。TCP是一个建立在IP之上的复杂协议，提供了进程间可靠的全双工（双向）连接。<br>从程序员的角度，我们可以把因特网看做一个世界范围的主机集合，满足一下特性：  </p><ul><li>主机集合被映射为一组32位的IP地址  </li><li>这组IP地址被映射为一组因特网域名的标识符  </li><li>因特网主机上的进程能够通过连接和任何其他因特网主机上的进程通信。    </li></ul><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>IP地址是大端法存储。<br>IP地址通常使用点分十进制表示法来表示。例如：128.2.194.242就是地址0x8002c2f2的点分十进制表示。</p><h3 id="因特网域名"><a href="#因特网域名" class="headerlink" title="因特网域名"></a>因特网域名</h3><p>域名是一串用句点分隔的单词（字母、数字、和破折号），例如 whaleshark.ics.cs.cmu.edu。<br>域名集合形成了一个层次结构，每个域名编码了它在这个层次中的位置。<br>常见的第一层域名有com、edu、gov、org、net，下一层是二级域名，例如cmu.edu。<br>因特网定义了域名集合和IP集合之间的映射，通过分布在世界范围内的数据库来维护。<br>每台因特网主机都有本地定义的域名，这个域名总是映射为回送地址127.0.0.1，localhost名字为引用运行在同一台机器上的客户端和服务器提供了一种便利的可移植的方式，这对调试相当有用。</p><h3 id="因特网连接"><a href="#因特网连接" class="headerlink" title="因特网连接"></a>因特网连接</h3><p>一个套接字是连接的一个端点，每个套接字都有相应的套接字地址，是有一个因特网地址和一个16位的整数端口组成的，用“地址：端口”来表示。<br>客户端发起连接请求（客户端套接字地址中的端口由内核自动分配，称为临时端口），然而服务端套接字地址的端口通常是某个知名端口，与提供的服务相对应，例如Web服务器通常使用端口80，而电子邮件服务器使用端口25。<br>每个具有知名端口的服务都有一个对应的知名的服务名，例如Web服务的名字为http，email的知名名字为smtp。<br>一个连接是由它两端的套接字地址唯一确定的。这对套接字地址叫做套接字对。</p><h2 id="套接字接口"><a href="#套接字接口" class="headerlink" title="套接字接口"></a>套接字接口</h2><p>套接字接口（socket interface）是一组函数，它们和Unix I/O函数结合起来，用以创建网络应<br>用。大多数现代系统上都实现套接字接口，包括所有Unix变种。</p><h3 id="套接字地址结构"><a href="#套接字地址结构" class="headerlink" title="套接字地址结构"></a>套接字地址结构</h3><p>因特网的套接字地址存放在类型为sockaddr_in的16字结构中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></span><br><span class="line">    uint_16     sin_family; <span class="comment">//通常设为AF_INET，代表是同Internet（TCP/IP）地址族。</span></span><br><span class="line">    uint_16     sin_port;   <span class="comment">//保存端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>  <span class="title">sin_addr</span>;</span>   <span class="comment">//IP地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>];  <span class="comment">//没有特殊含义，是为了让sockaddr与sockaddr_in两个数据结构保持大小相同而保留的空字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>&#123;</span></span><br><span class="line">    uint_16 sa_family;</span><br><span class="line">    <span class="keyword">char</span>    sa_data[<span class="number">14</span>];    <span class="comment">// Address data</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注：_in后缀是互联网（Internet）的缩写。<br>connect、bind和accept函数要求一个指向与协议相关的套接字地址结构的指针。解决办法是定义套接字函数要求一个指向通用sockaddr结构的指针，然后要求应用程序将与协议特定的结构的指针强制转换成这个通用结构。</p><h3 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h3><p>客户端和服务器使用socket函数来创建一个套接字描述符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain,<span class="keyword">int</span> type,<span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h3><p>客户端通过调用connect函数来建立和服务器的连接。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> clientfd,<span class="keyword">const</span> struct sockaddr *addr,<span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">// 成功则返回0，否则返回-1</span></span><br></pre></td></tr></table></figure><p>connect函数试图与套接字地址为addr的服务器建立一个因特网连接，其中addrlen是sizeof(sockaddr_in)。connect函数会阻塞，一直到连接成功建立或是发生错误。如果成功，clientfd描述符现在就准备好可以读写了，表示连接的套接字对如下：<br>(客户端IP:临时端口,addr.sin_addr:addr.sin_port)<br>临时端口唯一确定了客户端主机上的客户端进程。<br>对于socket，最好的方法是用getaddrinfo来为connect提供参数。</p><h3 id="bind、listen、accept函数"><a href="#bind、listen、accept函数" class="headerlink" title="bind、listen、accept函数"></a>bind、listen、accept函数</h3><p>这些函数被服务器用来和客户端建立连接。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">const</span> struct sockaddr *addr,<span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> listenfd,struct sockaddr *addr,<span class="keyword">int</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>bind函数告诉内核将addr中的服务器套接字地址和套接字描述符sockfd联系起来。参数addrlen就是sizeof(sockaddr_in)。对于socket和connect，最好的方法是用getaddrinfo来为bind提供参数。（注：绑定的是服务器进程自己的套接字地址、IP地址）<br>客户端时发起请求连接的主动实体，服务器时等待来自客户端的请求连接的被动实体。默认情况下，内核会认为socket函数创建的描述符对应于主动套接字（active socket），它默认存在于一个连接的客户端。服务器调用listen函数告诉内核描述符是被用于服务器而不是客户端使用。<br>服务器调用accept函数来等待来自客户端的连接请求。accept函数等待来自客户端的连接请求到达侦听描述符listenfd，然后在addr中填写客户端的套接字地址，并返回一个已连接描述符，这个描述符可被用来利用UnixI/O函数与客户端通信。  </p><h3 id="主机和服务的转换"><a href="#主机和服务的转换" class="headerlink" title="主机和服务的转换"></a>主机和服务的转换</h3><ol><li>getaddrinfo函数  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys.socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* host,<span class="keyword">const</span> <span class="keyword">char</span> *service,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> struct addrinfo *hints,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct addrinfo **result)</span></span>;</span><br><span class="line">                <span class="comment">//成功则返回 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeaddrinfo</span><span class="params">(struct addrinfo *result)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">gai_streroor</span><span class="params">(<span class="keyword">int</span> errcode)</span></span>;</span><br></pre></td></tr></table></figure>给定host和service（套接字地址的两个组成部分），getaddrinfo返回result，result一个指向addrinfo结构的链表，其中每个结构指向一个对应于host和service的套接字地址结构。<br>客户端调用getaddrinfo-&gt;遍历列表-&gt;尝试每个套接字地址-&gt;直到调用socket和connect成功，建立起连接。<br>可选参数hints是一个addrinfo结构，它提供对getaddrinfo返回的套接字地址列表的更好的控制。如果要传递hints参数，只能设置下列字段：ai_family、ai_socktype、ai_protocol和ai_flags字段。其他字段必须设置为0。实际中，我们可以用memset将整个结构清零，然后有选择地设置一些字段。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span>     ai_flags;</span><br><span class="line">    <span class="keyword">int</span>     ai_family;</span><br><span class="line">    <span class="keyword">int</span>     ai_socktype;</span><br><span class="line">    <span class="keyword">int</span>     ai_protocol;</span><br><span class="line">    <span class="keyword">char</span>    *ai_canonname;</span><br><span class="line">    <span class="keyword">size_t</span>  ai_addrlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">sockaddr</span> *<span class="title">ai_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">addrinfo</span> *<span class="title">ai_next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>getnameinfo函数<br>getnameinfo函数和getaddrinfo是相反的，将一个套接字地址结构转换成相应的主机和服务名字符串。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.j&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnameinfo</span><span class="params">(<span class="keyword">const</span> struct sockaddr *sa,<span class="keyword">socklen_t</span> salen,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">char</span> *host,<span class="keyword">size_t</span> hostlen,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">char</span> *service,<span class="keyword">size_t</span> servlen,<span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>参数sa指向大小为salen字节的套接字地址结构，host指向大小为hostlen字节的缓冲区，service指向大小为servlen字节的缓冲区。getnameinfo函数将套接字地址结构sa转换成对应的主机和服务名字字符串，并将它们复制到host和service缓冲区。</li></ol><h2 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h2><h3 id="Web基础"><a href="#Web基础" class="headerlink" title="Web基础"></a>Web基础</h3><p>Web客户端和服务器之间的交互用的是一个基于文本的应用级协议，叫做HTTP。Web服务和常规的文件检索服务（例如FTP）有什么区别呢？主要的区别是Web内容可以用一种叫做HTML的语言来编写。</p><h3 id="Web内容"><a href="#Web内容" class="headerlink" title="Web内容"></a>Web内容</h3><p>对于Web客户端和服务器而言，内容是一个MIME（Multipurpose Internet Mail Extensions，多用途的国际邮件扩充协议）类型相关的字节序列。常用的MIME类型如下：<br>text/html：HTML页面<br>text/plain：无格式文本<br>application/postscript：Postscript文档<br>image/gif：GIF格式编码的二进制图像<br>image/png：PNG格式编码的二进制图像<br>image/jpeg：JPEG格式编码的二进制图像<br>Web服务器以两种方式向客户端提供内容：  </p><ul><li>静态内容：取一个磁盘文件返回给客户端  </li><li>动态内容：运行一个可执行文件并将输出返回给客户端。  </li></ul><p>每条由Web服务器返回的内容都是和它管理的某个文件相关联的。这些文件中的每一个都有唯一的名字，叫做URL（通用资源定位符），例如：<br><a href="http://www.google.com/index.html">http://www.google.com:80/index.html</a><br>表示因特网主机<a href="http://www.google.com上一个称为/index.html%E7%9A%84HTML%E6%96%87%E4%BB%B6%EF%BC%8C%E5%AE%83%E6%98%AF%E7%94%B1%E4%B8%80%E4%B8%AA%E7%9B%91%E5%90%AC%E7%AB%AF%E5%8F%A380%E7%9A%84Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86%E7%9A%84%E3%80%82">www.google.com上一个称为/index.html的HTML文件，它是由一个监听端口80的Web服务器管理的。</a></p><h3 id="HTTP事务"><a href="#HTTP事务" class="headerlink" title="HTTP事务"></a>HTTP事务</h3>]]></content>
      
      
      <categories>
          
          <category> 深入理解计算机系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CH10系统级IO</title>
      <link href="2021/01/14/CH10%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/"/>
      <url>2021/01/14/CH10%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/</url>
      
        <content type="html"><![CDATA[<h1 id="系统级I-O"><a href="#系统级I-O" class="headerlink" title="系统级I/O"></a>系统级I/O</h1><h2 id="Unix-I-O"><a href="#Unix-I-O" class="headerlink" title="Unix I/O"></a>Unix I/O</h2><p>所有的Linux文件就是一个m字节的序列，所有的I/O设备（例如网络、磁盘、和终端）都被模型化为文件，而所有的输入输出都被当作相应文件的读和写来执行。这种设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为Unix I/O，这使得所有的输入和输出都能以统一且一致的方式执行。  </p><ul><li>打开文件（内核会返回一个非负整数，叫做描述符，内核记录有关这个打开文件的所有信息，应用程序只需要记住这个描述符）  </li><li>Linux shell创建的每个进程开始时都有三个打开的文件：标准输入（描述符为0）、标准输出（描述符为1）和标准错误（描述符为2）。头文件<code>&lt;stdlib.h&gt;</code>定义了常量STDIN_FILENO、STDOUT_FILENO和STDERR_FILENO，它们可以来代替显式的描述符值。  </li><li>改变当前的文件位置：对于每个打开的文件，内核保持着一个文件位置k，这是从问及那开头其实的字节偏移量。  </li><li>读写文件；读n个字节：k增加到k+n，给定一个大小为m字节的文件，当k&gt;=m时执行读操作会触发一个称为end-of-file（EOF）的条件。  </li><li>关闭文件</li></ul><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><ul><li>普通文件：包含任意数据。应用程序通常要区分文本文件（text file）和二进制文件（binary file），文本文件时只含有ASCII或Unicode字符的普通文件。二进制文件是所有其他文件。对内核而言，都一样。  </li><li>目录：包含一组连接（link）的文件，其中每个链接都将一个文件名映射到一个文件，这个文件可能时另一个目录。每个目录至少包含两个条目：“.”时到该目录自身的条目，以及“..”时到目录层次结构中父目录的链接。可以用mkdir创建一个目录，用ls查看其内容，用rmdir删除该目录。  </li><li>套接字（socket）是用来与另一个进程进行跨网络通信的文件。<br>其他文件类型包含命名通道、符号链接，以及字符和块设备，这些不在本书讨论范围内。<br>Linux将所有文件组织成一个目录层次结构，有名为“/”的根目录确定。<br>作为其上下文的一部分，每个进程都有一个当前工作目录来确定其在目录层次结构中的当前位置。你可以用cd来修改shell中的当前工作目录。</li></ul><h2 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcnt1.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">char</span> *filename,<span class="keyword">int</span> flags,<span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p>open函数将filename转换成一个文件描述符，并返回描述符数字。flags指明了进程打算如何访问这个文件：  </p><ul><li>O_RDONLY：只读  </li><li>O_WRONLY：只写  </li><li>O_RDWR：可读可写<br>mode参数指定了新文件的访问权限位。<br>最后，进程通过调用close函数关闭一个打开的文件。</li></ul><h2 id="读和写文件"><a href="#读和写文件" class="headerlink" title="读和写文件"></a>读和写文件</h2><p>应用程序分别调用read和write函数来执行输入和输出的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">void</span> *buf,<span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line"><span class="comment">// 返回：若成功则为读的字节数，若EOF则为0，若出错为-1</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">void</span> *buf,<span class="keyword">size_t</span>, n)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回：若成成功则为写的字节数，若出错则为-1</span></span></span><br><span class="line"><span class="function"><span class="comment">// ssize_t-long，size_t-unsigned long</span></span></span><br></pre></td></tr></table></figure><p>在某些情况下，read和write传送的字节比应用程序要求的要少。这些不足值不表示有错误。出现这样情况的原因有：  </p><ul><li>读时遇到EOF。  </li><li>从终端读文本行。如果打开文件是与终端相关联的（如键盘和显示器），那么每个read函数将一次传送一个文本行，返回的不足值等于文本行的大小。  </li><li>读和写网络套接词（socket）。如果打开文件对应于网络套接字，那么内部缓冲约束和较长的网络延迟会引起read和write返回不足值。<br>实际上，除了EOF，在读磁盘文件时不会遇到不足值，而在写磁盘文件时也不会遇到不足值。然而如果想创建健壮的（可靠的）诸如Web服务器这样的网络应用，就必须通过反复调用read和write处理不足值，直到所有需要的字节都传送完毕。</li></ul><h2 id="用RIO（Robust-I-O）包健壮地读写"><a href="#用RIO（Robust-I-O）包健壮地读写" class="headerlink" title="用RIO（Robust I/O）包健壮地读写"></a>用RIO（Robust I/O）包健壮地读写</h2><ul><li>无缓冲的输入输出函数。这些函数直接在内存和文件之间传送数据，没有应用级缓冲。它们对将二进制数据读写到网络和从网路读写二进制数据尤其有用。  </li><li>带缓冲的输入函数。这些函数允许高效地从文本读取文本行和二进制数据，这些文件的内容缓存在应用级缓冲区内，类似像printf这样标准I/O函数提供的缓冲区。  </li></ul><h3 id="RIO的无缓冲的输入输出函数"><a href="#RIO的无缓冲的输入输出函数" class="headerlink" title="RIO的无缓冲的输入输出函数"></a>RIO的无缓冲的输入输出函数</h3><p>通过调用rio_readn和rio_writen函数，应用程序可以在内存和文件之间直接传送数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">rio_readn</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">void</span> *usrbuf,<span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">rio_writen</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">void</span> *usrbuf,<span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">rio_readn</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">void</span> *usrbuf,<span class="keyword">size_t</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> nleft=n;</span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line">    <span class="keyword">char</span> *bufp=usrbuf;</span><br><span class="line">    <span class="keyword">while</span>(nleft&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((nread=<span class="built_in">read</span>(fd,bufp,nleft))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(errno==EINTR)<span class="comment">//遇到中断</span></span><br><span class="line">                nread=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nread==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        nleft-=nread;</span><br><span class="line">        bufp+=nread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (n-nleft);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于同一个文件描述符可以任意交错地调用rio_readn和rio_writen。</p><h3 id="RIO的带缓冲输入函数"><a href="#RIO的带缓冲输入函数" class="headerlink" title="RIO的带缓冲输入函数"></a>RIO的带缓冲输入函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rio_readinitb</span><span class="params">(<span class="keyword">rio_t</span> *rp,<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">rio_readlineb</span><span class="params">(<span class="keyword">rio_t</span> *rp,<span class="keyword">void</span> *usrbuf,<span class="keyword">size_t</span> maxlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">rio_readnb</span><span class="params">(<span class="keyword">rio_t</span> *,<span class="keyword">void</span> *usrbuf,<span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>每打开一个描述符，都会调用一次rio_readinitb函数。它将描述符fd和地址rp处在一个类型为rio_t的读缓冲区联系起来。<br>对于同一描述符，rio_readlineb和rio_readnb的调用可以交叉进行。</p><h2 id="读取文件元数据"><a href="#读取文件元数据" class="headerlink" title="读取文件元数据"></a>读取文件元数据</h2><p>应用程序能够调用stat和fstat函数，检索到关于文件的信息（有时也称为文件的元数据）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename,struct stat *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fd,struct stat *buf)</span></span>;</span><br></pre></td></tr></table></figure><p>stat函数以一个文件名作为输入，并填写如下所示的一个stat数据结构中的各个成员。fstat函数是相似的，只不过是以文件描述符而不是文件名作为输入。当我们在11.5节讨论Web服务器时，会需要stat数据结构中的st_mode和st_size成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span>&#123;</span></span><br><span class="line">    <span class="keyword">dev_t</span>   st_dev;</span><br><span class="line">    <span class="keyword">ino_t</span>   st_ino;</span><br><span class="line">    <span class="keyword">mode_t</span>  st_mode;</span><br><span class="line">    <span class="keyword">nlink_t</span> st_nlink;</span><br><span class="line">    <span class="keyword">uid_t</span>   st_uid;</span><br><span class="line">    <span class="keyword">gid_t</span>   st_gid;</span><br><span class="line">    <span class="keyword">dev_t</span>   st_rdev;</span><br><span class="line">    <span class="keyword">off_t</span>   st_size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> st_blksize;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> st_blocks;</span><br><span class="line">    <span class="keyword">time_t</span>  st_atime;</span><br><span class="line">    <span class="keyword">time_t</span>  st_mtime;</span><br><span class="line">    <span class="keyword">time_t</span>  st_ctime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读取目录内容"><a href="#读取目录内容" class="headerlink" title="读取目录内容"></a>读取目录内容</h2><p>函数opendir和readdir，closedir用来关闭流并释放其所有资源。</p><h2 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h2><p>内核用三个相关的数据结构来表示打开的文件：</p><ul><li>描述符表（每个进程都有独立的描述符表，每个描述符表项指向文件表中的一个表项）</li><li>文件表（打开文件的集合是由一张文件表来表示，所有进程共享这张表。每个文件表的表项组成包括当前的文件位置、引用计数，以及一个指向v-node表中对应表项的指针。关闭一个描述符会减少相应的文件表表项中的引用计数。内核不会删除这个文件表表项，直到它的引用次数为0。）</li><li>v-node表。所有进程共享，每个表项包含stat结构中的大多数信息，包括st_mode和st_size成员。<br>多个描述符也可以通过不同的文件表表项来引用同一个文件。例如，如果以同一个filename调用open函数两次，就会发生这种情况。</li></ul><h2 id="I-O重定向"><a href="#I-O重定向" class="headerlink" title="I/O重定向"></a>I/O重定向</h2><p>Linux shell提供了I/O重定向操作符，允许用户将磁盘文件和标准输入输出联系起来。例如，键入<br><code>linux&gt; ls &gt; foo.txt</code><br>使得shell加载和执行ls程序，将标准输出重定向到磁盘文件foo.txt。就如我们将在11.5节中看到的那样，当一个Web服务器代表客户端允许CGI程序时，它就执行一种类似类型的重定向。<br>一种重定位方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd,<span class="keyword">int</span> newfd)</span></span>;</span><br></pre></td></tr></table></figure><p>dup2函数复制描述符表项oldfd到描述符表项newfd，覆盖描述符表项newfd以前的内容。</p><h2 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h2><p>标准I/O库将一个打开的文件模型化为一个流。对于程序员而言，一个流就是一个指向FILE类型的结构的指针。每个ANSI C程序开始时都有3个打开的流stdin、stdout和stderr，分别对应于标准输入、标准输出和标准错误。<br>类型为FILE的流是对文件描述符和缓冲流的抽想。流缓冲区的目的和RIO读缓冲区一样：就是使开销较高的Linux I/O系统调用的数量尽可能得小。</p><h2 id="综合：我们该使用哪些I-O函数"><a href="#综合：我们该使用哪些I-O函数" class="headerlink" title="综合：我们该使用哪些I/O函数"></a>综合：我们该使用哪些I/O函数</h2>]]></content>
      
      
      <categories>
          
          <category> 深入理解计算机系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CH9虚拟内存</title>
      <link href="2021/01/14/CH9%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
      <url>2021/01/14/CH9%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟内存（Virtual-Memory）"><a href="#虚拟内存（Virtual-Memory）" class="headerlink" title="虚拟内存（Virtual Memory）"></a>虚拟内存（Virtual Memory）</h1><p>虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间。它有三个重要的能力：  </p><ol><li>它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在主存和磁盘之间来回传送数据，通过这种方式，它高效地使用了主存。  </li><li>他为每个进程提供了一致的地址空间，它高效地使用了主存。  </li><li>它保护了每个进程的地址空间不被其他进程破坏。  </li></ol><h2 id="物理和虚拟寻址"><a href="#物理和虚拟寻址" class="headerlink" title="物理和虚拟寻址"></a>物理和虚拟寻址</h2><p>使用虚拟寻址，CPU通过生成一个虚拟地址来访问主存（被组织成一个由M个连续字节大小的单元组成的数组，每个字节都有唯一的物理地址），这个虚拟地址在被送到内存之前，先转换成适当的物理地址。地址翻译需要CPU硬件和操作系统之间的紧密合作。CPU芯片上叫做内存管理单元（Memory Management Unit，MMU）的专用硬件，利用存放在主存中的查询表来动态翻译。</p><h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><p>虚拟地址空间：${0,1,2,…,N-1}$，$N=2^n$。<br>物理地址空间：${0,1,2,…,M-1}$，M不一定要素2的幂。</p><h2 id="虚拟内存作为缓存的工具"><a href="#虚拟内存作为缓存的工具" class="headerlink" title="虚拟内存作为缓存的工具"></a>虚拟内存作为缓存的工具</h2><p>磁盘上的数据被分割为块，作为主存和磁盘之间的传输单元。VM系统通过将虚拟内存分割为称为虚拟页的大小固定的块来处理这个问题，每个虚拟页大小为$P=2^p$字节。类似地，物理内存被分割为物理页，大小也为P字节（物理页被称为页帧）。<br>在任何时刻，虚拟页吗被分为三个不相交的子集：  </p><ul><li>为分配的：还未分配（或者创建）的页。  </li><li>缓存的：已缓存在物理内存中的已分配页。  </li><li>未缓存的：未缓存在物理内存中的已分配页。  </li></ul><h3 id="DRAM缓存的组织结构"><a href="#DRAM缓存的组织结构" class="headerlink" title="DRAM缓存的组织结构"></a>DRAM缓存的组织结构</h3><p>由于磁盘访问要比DRAM慢太多，所以DRAM缓存不命中比起SRAM缓存（L1、L2、L3）要昂贵得多。</p><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>不命中-&gt;系统判定这个虚拟页在磁盘哪个位置，并将虚拟页复制到DRAM中，替换牺牲页。<br>页表：虚拟页-&gt;物理页。<br>页表实际上是页表条目（Page Table Entry，PTE）的数组，虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个PTE，每个PTE都由一个有效位和一个n位地址字段组成。有效位表明该虚拟页是否被缓存在DRAM中。如果有效，地址字段是指向该虚拟页在DRAM中相应的物理页的起始位置；如果无效，那么一个空地址表明这个虚拟页还未分配，如果地址非空就是已分配但未被保存，地址指向虚拟页在磁盘上的起始位置。  </p><h3 id="页命中"><a href="#页命中" class="headerlink" title="页命中"></a>页命中</h3><p>地址翻译硬件将虚拟地址作为一个索引来定位PTE-&gt;如果设置了有效位，则利用PTE中的物理内存地址构造出这个字的物理地址。</p><h3 id="缺页"><a href="#缺页" class="headerlink" title="缺页"></a>缺页</h3><p>DRAM缓存不命中称为缺页（page fault）。<br>未命中则从磁盘复制到内存中的牺牲页中（牺牲页如果修改过则写回磁盘）。<br>在磁盘和内存之间传送页的活动叫做交换（swapping）或者页面调度（paging）。页从磁盘换入DRAM和从DRAM换出磁盘。</p><h3 id="分配页面"><a href="#分配页面" class="headerlink" title="分配页面"></a>分配页面</h3><p>例如，调用malloc，在磁盘上创建空间并且更新页表上该条目的（能够分配页面必然有剩余虚拟内存可分配）地址。</p><h3 id="又是局部性救了我们"><a href="#又是局部性救了我们" class="headerlink" title="又是局部性救了我们"></a>又是局部性救了我们</h3><p>如果工作集的大小超出了物理内存的大小，那么程序将处于一种不信的状态，叫做抖动（thrashing），这时页面将不断地换进换出。</p><h2 id="虚拟内存作为内存管理工具"><a href="#虚拟内存作为内存管理工具" class="headerlink" title="虚拟内存作为内存管理工具"></a>虚拟内存作为内存管理工具</h2><ul><li>简化链接：没搞太懂  </li><li>简化加载：没搞太懂  </li><li>简化共享：不同虚拟页映射到同一物理页来实现共享。  </li><li>简化内存分配  </li></ul><h2 id="虚拟内存作为内存保护的工具"><a href="#虚拟内存作为内存保护的工具" class="headerlink" title="虚拟内存作为内存保护的工具"></a>虚拟内存作为内存保护的工具</h2><p>通过在PTE上添加一些额外的许可位来控制对一个虚拟页面内容的访问十分简单。比如：</p><ul><li>SUP：是否进程必须运行在内核模式才能访问该页。  </li><li>READ：控制读访问  </li><li>WRITE：控制写访问  </li></ul><h2 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h2><p>如果违反了这些许可条件，那么CPU就会触发一般保护故障，将控制传递给内核中的异常处理程序。Linux shell一般将这种异常报告为“段错误（segmental fault）”。</p><h2 id="地址翻译-1"><a href="#地址翻译-1" class="headerlink" title="地址翻译"></a>地址翻译</h2><p>$N=2^n$：虚拟地址空间中的地址数量<br>$M=2^m$：物理地址空间中的地址数量<br>$P=2^p$：页的大小<br>页表基址寄存器（Page Table Register，PTBR）指向当前页表。n位的虚拟地址包含两部分：一个p位的虚拟页面偏移（Virtual Page Offset，VPO）和一个（n-p）位的虚拟页号（VirtualPage Number，VPN）。MMU利用页表基址寄存器和VPN找到对应的PTE，然后将页表条目中的物理页号（PPN，m-p位）和虚拟地址中的虚拟页面偏移串联期来就得到相应的物理地址。注：物理页面和虚拟页面的页面偏移是一样的。</p><h3 id="结合高速换粗和虚拟内存"><a href="#结合高速换粗和虚拟内存" class="headerlink" title="结合高速换粗和虚拟内存"></a>结合高速换粗和虚拟内存</h3><h3 id="利用TLB加速地址翻译"><a href="#利用TLB加速地址翻译" class="headerlink" title="利用TLB加速地址翻译"></a>利用TLB加速地址翻译</h3><p>每次产生一个虚拟地址，MMU就必须查阅一个PTE（代价很大），以便将虚拟地址翻译为物理地址。如果PTE碰巧在L1中，那么开销就下降很多。然而，许多系统都试图消除即使是这样的开销，它们在MMU中包括了一个关于PTE的小的缓存，称为翻译后备缓冲器（TranslationLookaside Buffer，TLB）。<br>TLB（TLB索引+TLB标记+PTE）是一个小的、虚拟寻址的缓存，其每一行都保存者一个由单个PTE组成的块，如果保存$T=2^t$个组，那么TLB索引由虚拟页号的t个最低位组成的，而TLB标记由VPN中剩余的位组成。TLB通常有高度的相联度。TLB命中的步骤：</p><ol><li>CPU产生一个虚拟地址。  </li><li>MMU从TLB中取出相应的PTE。  </li><li>MMU将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存。  </li><li>高速缓存/主存将所请求的数据字返回给CPU。  </li></ol><p>当TLB不命中时，MMU必须从L1缓存中取出相应的PTE，新取出的PTE存放在TLB中，可能会覆盖一个已经存在的条目。  </p><h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>如果一级页表的一个PTE是空的，那么相应的二级页表就根本不会存在。这代表一种巨大的节约。<br>对于k级别页表层次结构的地址翻译：<br>虚拟地址：$VPN_1|VPN_2|…|VPN_k|VPO$<br>一级页表,$VPN_1$-&gt;二级页表,$VPN_2$-&gt;…-&gt;k级页表$VPN_k$-&gt;$PPN$,$PPO$，$PPO==VPO$，物理页面偏移量==虚拟页面偏移量。  </p><h3 id="综合：端到端的地址翻译"><a href="#综合：端到端的地址翻译" class="headerlink" title="综合：端到端的地址翻译"></a>综合：端到端的地址翻译</h3><p>虚拟地址：VPN（虚拟页码）+VPO（虚拟页偏移）<br>VPN：TLBT（TLB标记）+TLBI（TLB索引）<br>MMU从虚拟地址中抽取VPN，并检查TLB，看它是否因为前面某个内存引用缓存了VPN的条目的一个副本。TLB从VPN中抽取TLB索引，和TLB标记，检查TLBI组中是否有匹配，若存在匹配项，则命中，然后将缓存的PPN返回给MMU。<br>如果TLB不命中，那么MMU就需要从主存中取出相应的PTE（页表条目，存放在物理内存中）。将PTE中的PPN和来自虚拟地址的VPO连接起来，这就形成了物理地址。</p><h2 id="案例研究：Intel-Core-i7-Linux内存系统"><a href="#案例研究：Intel-Core-i7-Linux内存系统" class="headerlink" title="案例研究：Intel Core i7/Linux内存系统"></a>案例研究：Intel Core i7/Linux内存系统</h2><p>处理器：四个核、一个大的所有核共享的L3高速缓存，以及一个DRR3内存控制器。每个核包含一个层次结构的TLB、一个层次结构的数据和指令高速缓存，以及一组快速到店链路，这种链路基于QuickPath技术，是为了让一个核与其他核核外部I/O桥直接通信。TLB是虚拟寻址的，是四路组相联的。L1、L2、L3高速缓存是物理寻址的，块大小为64字节。L1和L2是8路相联的，而L3是16路相联的。</p><h3 id="Core-i7-地址翻译"><a href="#Core-i7-地址翻译" class="headerlink" title="Core i7 地址翻译"></a>Core i7 地址翻译</h3><p>Core i7使用四级页表翻译。<br>物理页表要求4KB对齐。<br>页表条目PTE：<br>位  </p><ul><li>0：P（子页表是否在内存中存在）  </li><li>1：R/W（对于所有可访问页，只读或者读写访问权限）  </li><li>2：U/S（对于所有可访问页，用户或者超级用户（内核）模式访问权限）  </li><li>3：WT（子页表直写或者写回缓存策略）  </li><li>4：CD（能/不能缓存子页表）  </li><li>5：A（引用位，由MMU在读和写时设置，由软件清除）  </li><li>7：PS（页大小为4KB或4MB（只对第一层PTE定义））  </li><li>12-51：Base addr（子页表的物理基地址的最高40位）  </li><li>63：XD（能/不能从这个PTE可访问的所有页中取指令）<br>注：还有第四级页表条目格式：  </li><li>0：P（子页表是否在内存中存在，如果P为0，则剩余63位操作系统可用）  </li><li>1：R/W（对于所有可访问页，只读或者读写访问权限）  </li><li>2：U/S（对于所有可访问页，用户或者超级用户（内核）模式访问权限）  </li><li>3：WT（子页表直写或者写回缓存策略）  </li><li>4：CD（能/不能缓存子页表）  </li><li>5：A（引用位，由MMU在读和写时设置，由软件清除）  </li><li>6：D（修改位，由MMU在读和写时设置，由软件清除）  </li><li>7：0  </li><li>8：G（全局页，在任务切换时，不从TLB驱逐出去）  </li><li>12-51：Base addr（子页表的物理基地址的最高40位）  </li><li>63：XD（能/不能从这个子页中取指令）<br>引用位：每次访问，MMU都会设置A位，称为引用位，内核可以利用引用位来设计页替换算法。<br>修改位：告诉内核替换页之前是否必须写回牺牲页。  </li></ul><h3 id="9-7-2-Linux虚拟内存系统"><a href="#9-7-2-Linux虚拟内存系统" class="headerlink" title="9.7.2 Linux虚拟内存系统"></a>9.7.2 Linux虚拟内存系统</h3><ol><li>Linux虚拟内存区域<br>区域的概念；每个存在的虚拟页面都必然属于某个区域；这允许虚拟地址空间有间隙。<br>内核为系统进程维护一个单独的任务结构，这中的元素包含或者指向内核运行该进程所需要的所有信息（例如PID、指向用户栈的指针，可执行目标文件的名字，以及程序计数器）。  </li><li>Linux缺页异常处理<br>MMU视图翻译A时触发一个缺页，这个异常导致控制转移到内核的缺页处理程序，随后执行如下步骤：<br>1）虚拟地址A时合法的吗？（即A是否在某个区域结构定义的区域内）<br>2）试图进行内存访问是否合法？进程是否有读、写或者执行这个区域内页面的权限。<br>3）内核知道这个缺页是由于对合法的虚拟地址进行合法的操作造成的。然后，选择一个牺牲页面（如果修改过，写回），换入新的页面并更新页表，当缺页处理程序返回时，CPU重新启动引起缺页的指令。  </li></ol><h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p>Linux将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存的内容，这个过程称为内存映射。<br>1）Linux文件系统中的普通文件<br>2）匿名文件<br>3）交换文件  </p><h3 id="再看共享对象"><a href="#再看共享对象" class="headerlink" title="再看共享对象"></a>再看共享对象</h3><p>一个映射到共享对象的虚拟内存区域叫做共享区域，类似地，也有私有区域。<br>私有对象使用一种叫做写时复制的巧妙技术被映射到虚拟内存中。举例：两个进程共享了一个对象同一个物理副本。对于每个映射私有对象的进程，相应的页表条目标记为只读，并在区域结构被标记为私有写时复制。只要没有进程试图写它自己的私有区域，它们就可以继续共享物理内存中对象的一个单独副本，然而只要有一个进程试图写私有区域内的某个页面，那么这个写操作会触发一个保护故障。当故障处理程序注意到保护异常是由于进程试图写私有的写时复制区域中的一个页面而引起的，它就会在物理内存中创建这个页面的一个新副本，更新页表条目指向这个新的副本，然后恢复这个页面的写权限。</p><h3 id="再看fork函数"><a href="#再看fork函数" class="headerlink" title="再看fork函数"></a>再看fork函数</h3><h3 id="再看execve函数"><a href="#再看execve函数" class="headerlink" title="再看execve函数"></a>再看execve函数</h3><p>一个execve调用：<br><code>execve(&quot;a.out&quot;,NULL,NULL)</code><br>该函数加载并允许可执行目标程序a.out中的程序，用a.out程序有效替代了当前的程序。加载并允许a.out需要一下几个步骤：  </p><ul><li><p>删除已存在的用户区域</p></li><li><p>映射私有区域</p></li><li><p>映射共享区域</p></li><li><p>设置程序计数器（PC）</p></li></ul><h3 id="使用mmap函数的用户级内存映射"><a href="#使用mmap函数的用户级内存映射" class="headerlink" title="使用mmap函数的用户级内存映射"></a>使用mmap函数的用户级内存映射</h3><p>mmap函数要求内核创建一个新的虚拟内存区域，并将指定的一各连续的片（chunk）映射到这个新的<br>区域。</p><h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><p>虽然可以使用低级的mmap和munmap函数来创建和删除虚拟内存区域，但是C程序员还会觉得当运行时需要额外的虚拟内存时，用动态内存分配器（dynamic memory allocator）更方便，也有更好的可以移植性。<br>动态内存分配器维护者一个进程的虚拟内存区域，称为堆（heap）。<br>分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。  </p><ol><li>显示分配器（例如C语言的malloc函数）  </li><li>隐式分配器（也叫做垃圾收集器，要求分配器检测一个已分配块何时不再被程序所使用）  </li></ol><h3 id="malloc和free函数"><a href="#malloc和free函数" class="headerlink" title="malloc和free函数"></a>malloc和free函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p>malloc函数返回一个指针，指向为至少size字节的内存块，这个块会为可能包含在这个块内的任何数据对象型做对齐。在32位模式中，地址总是8的倍数，在64位模式中地址总是16的倍数。<br>如果malloc遇到问题（例如要求的内存块比可用的虚拟内存还大），就返回NULL，并设置errno。如果想要改变一个已分配块的大小，可以使用realloc函数。</p><h3 id="分配器的要求和目标"><a href="#分配器的要求和目标" class="headerlink" title="分配器的要求和目标"></a>分配器的要求和目标</h3><ol><li>处理任意请求序列。一个应用可以有任意的分配请求序列何释放请求序列  </li><li>立即响应请求  </li><li>只使用堆  </li><li>对齐块（对齐要求）<br>一个分配请求的最糟糕运行时间与空闲块的数量成线性关系，而一个释放请求的运行时间是一个常数。<br>一个系统中被所有进程分配的虚拟内存的全部数量是受磁盘上交换空间的数量限制的。</li></ol><h3 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h3><p>内部碎片何外部碎片。  </p><ol><li>内部碎片<br>实际中为了满足对齐条件，分配器可能增加块的大小。  </li><li>外部碎片<br>当空闲内存合起来满足一个分配请求，但是没有一个单独的空闲块足够来满足这个请求，那么如果不向内核请求额外的虚拟内存就无法满足这个请求。<br>分配器通常采用启发式策略来试图维持少量的大空闲块。  </li></ol><h3 id="实现问题"><a href="#实现问题" class="headerlink" title="实现问题"></a>实现问题</h3><h3 id="隐式空闲链表"><a href="#隐式空闲链表" class="headerlink" title="隐式空闲链表"></a>隐式空闲链表</h3><p>优点是简单，缺点是任何操作的开销都要对空闲链表进行搜索。</p><h3 id="放置已分配的块"><a href="#放置已分配的块" class="headerlink" title="放置已分配的块"></a>放置已分配的块</h3><p>三种放置策略：首次适配、下一次适配、最佳适配</p><h3 id="分割空闲块"><a href="#分割空闲块" class="headerlink" title="分割空闲块"></a>分割空闲块</h3><p>如果放置策略趋向于产生好的匹配，那么额外的内部碎片也是可以接受的。<br>如果匹配不太好，那么分配器通常会把这个空闲块分割为两部分。第一部分变成分配块，而剩下的变成一个新的空闲块。  </p><h3 id="获取额外的内存"><a href="#获取额外的内存" class="headerlink" title="获取额外的内存"></a>获取额外的内存</h3><h3 id="合并内存块"><a href="#合并内存块" class="headerlink" title="合并内存块"></a>合并内存块</h3><p>假设一个对4字（16字节）有效载荷的请求，但是只有两个相邻的有效载荷为3字的空闲块，这种现象叫做假碎片。为了解决假碎片问题，任何实际的分配器都必须合并相邻的空闲块，这个过程称为合并。这就出现了一个重要的策略决定，那就是何视执行合并。分配器可以选择立即合并（也就是在每次一个块被释放时，就合并所有相邻的块），或者它也可以选择推迟合并（也就是等到某个稍晚的时候再合并空闲块，例如可以等到某个分配请求失败，再扫描整个堆，合并所有空闲块）。立即合并简单明了，但会产生某种形式的抖动（频繁的合并和分割），快速分配器通常会选择某种形式的推迟合并。</p><h3 id="带边界标记的合并"><a href="#带边界标记的合并" class="headerlink" title="带边界标记的合并"></a>带边界标记的合并</h3><p>头部、脚部，两者一样，各占一字。<br>头部可以让前面的块确定后继块的范围，脚部可以让后面的块确定前面块的范围。为了节省空间，已分配块没有脚部。</p><h3 id="综合：实现一个简单的分配器"><a href="#综合：实现一个简单的分配器" class="headerlink" title="综合：实现一个简单的分配器"></a>综合：实现一个简单的分配器</h3><p>跳过，之后再看。</p><h3 id="显示空闲链表"><a href="#显示空闲链表" class="headerlink" title="显示空闲链表"></a>显示空闲链表</h3><p>可以将堆组织成一个双向空闲链表，每个空闲块中，都包含一个pred（前驱）、succ（后继）指针。<br>使用双向链表而不是隐式空闲链表，使首次适配的分配时间从块数量的线性时间降低到空闲块数量的线性时间。不过释放一个块的时间可以是线性的也可以是常数，这取决于我们所选择的空闲链表中块的排序策略。<br>一种方法是：LIFO（先进后出，将新释放的块放置在链表的开始处，这样子释放将是常数时间，如果使用了边界标记，合并也是常数时间）<br>另一种方法是按地址顺序维护链表，其中链表中每个块的地址都小于它的后继的地址。在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。但是这相对于LIFO排序有更高的内存利用率，接近最佳适配的利用率。</p><h3 id="分离的空闲链表"><a href="#分离的空闲链表" class="headerlink" title="分离的空闲链表"></a>分离的空闲链表</h3><p>一种流行的减少分配时间的方法是分离存储，维护多个空闲链表，其中每个链表中的块有大致相等的大小。一般的思路是将所有可能的块大小分成一些等价类，也叫做大小类。有很多种方式来定义大小类。例如根据2的幂：<br>{1},{2},{3，4},{5<del>8},…,{1025</del>2048},{2049<del>4096},{4097</del>$\infin$}  </p><ol><li>简单分离存储<br>使用简单分离存储，每个大小类的空闲链表包含大小相等的块，每个块的大小就算这个大小类中的最大元素的大小。<br>优点：释放和分配块，都是常数时间操作。而且每个片中都是大小相等的块，不分割，不合并。显著的缺点是：很容易造成内部碎片和外部碎片。  </li><li>分离适配<br>C标准库中的malloc包就是采用这种方法。这种方法既快速，对内存的使用也很有效率。搜索时间减少了，因为搜索被限制在堆的某个部分，而不是整个堆。<br>为了分配一个块，先确定请求的大小类，并且对适当的空闲链表做首次适配，查找一个合适的块，如果找到一个，那么就分割它，并将剩余的部分插入到适当的空闲链表中，如果找不到合适的块，那么就搜索下一个更大的大小类的空闲链表。如此重复知道找到一个合适的块。如果空闲链表中没有合适的块，那么就像操作系统请求额外堆内存，从这个新的堆内存中分配出一个块，将剩余部分放置在适当的大小类中。要释放一个块，我们执行合并，并将结果放置在相应的空闲链表中。  </li><li>伙伴系统<br>一种特殊的分离适配，为每个块大小$2^k$维护一个分离空闲链表。请求块大小，向上舍入到最近的2的幂，找到一可用的块大小为$2^j$，然后递归地分割这个块，直到j=k。当分割时每个剩下的半块被放置在相应的空闲链表中。<br>优点：快速搜索和合并，可能导致显著的内部碎片。不过如果，块大小预知时2的幂，伙伴系统分配器就很有吸引力了。  </li></ol><h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>垃圾收集器（garbage collector）是一种动态内存分配器，它自动释放程序不再需要的已分配块。这些块被称为垃圾。</p><h3 id="垃圾收集器的基本知识"><a href="#垃圾收集器的基本知识" class="headerlink" title="垃圾收集器的基本知识"></a>垃圾收集器的基本知识</h3><p>垃圾收集器将内存视为一张有向可达图，包含根节点（包含指向堆中的指针）和堆节点（对应于一个堆中的已分配块）。当存在一条从任意根结点出发并达到p的有向路径时，我们说p节点时可达的。不可达节点对应于垃圾。<br>向ML和Java这样的语言能够维护可达图的一种精确表示，也因此能够回收所有垃圾。例如C/C++这样的语言通常不能维持可达图的精确表示，这样的收集器也叫做保守的垃圾收集器，每个可达块都被正确标记为可达了，但是某些不可达节点可能被错误标记为可达了。<br>需要堆空间时：应用通常会调用malloc，如果malloc找不到一个合适的空闲块，那么它就调用垃圾收集器，希望能够回收一些垃圾到空闲链表。</p><h3 id="Mark-amp-Sweep垃圾收集器"><a href="#Mark-amp-Sweep垃圾收集器" class="headerlink" title="Mark&amp;Sweep垃圾收集器"></a>Mark&amp;Sweep垃圾收集器</h3><p>Mark&amp;Sweep垃圾收集器通常由标记（Mark）和清除（sweep）阶段组成。  标记：标记出根节点的所有可达和已分配的后继。<br>清除：释放每个未标记的已分配块。<br>块头部中空闲的低位中的一位通常用来表示这个快是否被标记了。</p><h3 id="C程序的保守Mark-amp-Sweep"><a href="#C程序的保守Mark-amp-Sweep" class="headerlink" title="C程序的保守Mark&amp;Sweep"></a>C程序的保守Mark&amp;Sweep</h3><p>C语言的Mark&amp;Sweep收集器必须是保守的，其根本原因是C语言不会用类型信息来标记内存位置。因此像int或者float这样的标量可以伪装成指针。</p><h2 id="C程序中的常见的与内存相关的错误"><a href="#C程序中的常见的与内存相关的错误" class="headerlink" title="C程序中的常见的与内存相关的错误"></a>C程序中的常见的与内存相关的错误</h2><h3 id="间接引用坏指针"><a href="#间接引用坏指针" class="headerlink" title="间接引用坏指针"></a>间接引用坏指针</h3><h3 id="读未初始化的内存"><a href="#读未初始化的内存" class="headerlink" title="读未初始化的内存"></a>读未初始化的内存</h3><h3 id="允许栈缓冲区溢出"><a href="#允许栈缓冲区溢出" class="headerlink" title="允许栈缓冲区溢出"></a>允许栈缓冲区溢出</h3><h3 id="假设指针和它们指向的对象是相同大小的"><a href="#假设指针和它们指向的对象是相同大小的" class="headerlink" title="假设指针和它们指向的对象是相同大小的"></a>假设指针和它们指向的对象是相同大小的</h3><h3 id="造成错位错误"><a href="#造成错位错误" class="headerlink" title="造成错位错误"></a>造成错位错误</h3><h3 id="引用指针而不是它所指向的对象"><a href="#引用指针而不是它所指向的对象" class="headerlink" title="引用指针而不是它所指向的对象"></a>引用指针而不是它所指向的对象</h3><h3 id="误解指针运算"><a href="#误解指针运算" class="headerlink" title="误解指针运算"></a>误解指针运算</h3><h3 id="引用不存在的变量"><a href="#引用不存在的变量" class="headerlink" title="引用不存在的变量"></a>引用不存在的变量</h3><h3 id="引用空闲堆块中的数据"><a href="#引用空闲堆块中的数据" class="headerlink" title="引用空闲堆块中的数据"></a>引用空闲堆块中的数据</h3><h3 id="引起内存泄漏"><a href="#引起内存泄漏" class="headerlink" title="引起内存泄漏"></a>引起内存泄漏</h3>]]></content>
      
      
      <categories>
          
          <category> 深入理解计算机系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CH8异常控制流</title>
      <link href="2021/01/14/CH8%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/"/>
      <url>2021/01/14/CH8%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="异常控制流"><a href="#异常控制流" class="headerlink" title="异常控制流"></a>异常控制流</h1><p>现代系统通过使控制流发生突变来应对这些情况（如程序向磁盘请求数据、子进程终止同制父进程等），一般而言我们把这些突变称为异常控制流（Exceptional Control Folw，ECF）。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常（Exception）就是控制流中的突变。<br>处理器检测到事件发生时，它会通过一张叫做异常表（exception table）<br>的跳转表，进行一个间接过程调用（异常），到一个专门设计用来处理这类事件得操作系统子程序（异常处理程序，exception handler）。当异常处理程序完成处理后，根据引起异常得事件类型，会发生以下3种情况中得一种：  </p><ol><li>处理程序将控制返回给当前指令$I_{curr}$，即当事件发生时正在执行得指令。  </li><li>处理程序将控制返回给$I_{next}$，如果没有发生异常将会执行下一条指令。  </li><li>处理程序终止被终端的程序。  </li></ol><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>系统中每种可能得异常都分配了唯一的非负整数的异常号（exception number）。其中一些号码是由处理器（CPU）的设计者分配的，其他号码是由操作系统内核的设计者分配的。前者的示例包括零除、缺页、内存访问为例、断点以及算术运算溢出。后者示例包括系统调用和来自外部I/O设备的信号。<br>异常-&gt;异常表基地址寄存器-&gt;异常表-&gt;相应的处理程序。</p><h3 id="异常的类别"><a href="#异常的类别" class="headerlink" title="异常的类别"></a>异常的类别</h3><p>分为四类：中断（interrupt）、陷阱（trap）、故障（fault）和终止（abort）。</p><table><thead><tr><th>类别</th><th align="center">原因</th><th>异步/同步</th><th align="right">返回行为</th></tr></thead><tbody><tr><td>中断</td><td align="center">来自I/O设备的信号</td><td>异步</td><td align="right">总是返回到下一条指令</td></tr><tr><td>陷阱</td><td align="center">有意的异常</td><td>同步</td><td align="right">总是返回到下一条指令</td></tr><tr><td>故障</td><td align="center">潜在可恢复的错误</td><td>同步</td><td align="right">可能返回到当前指令</td></tr><tr><td>终止</td><td align="center">不可恢复的错误</td><td>同步</td><td align="right">不会返回</td></tr></tbody></table><ol><li>中断<br>中断是异步发生的，来自处理器外部的I/O设备信号的结果。硬件中断不是由任何一条专门的指令造成的，从这个意义上说它是异步的。  </li><li>陷阱和系统调用<br>陷阱是有意的异常，陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用。为了允许用户程序对内核服务受控的访问，处理器提供了一条特殊的“syscall n”指令，当用户程序想要请求服务n时，可以执行这条指令，执行syscall指令会导致一个到异常处理程序的陷阱，这个处理程序解析参数，并调用适当的内核程序。  </li><li>故障<br>故障时由错误情况引起的，它可能够被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。<br>一个经典故障时缺页异常，当指令引用一个虚拟地址，而与地址相对应的物理页面不在内存中，因此必须从磁盘中取出来。  </li><li>终止<br>终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如DRAM或者SRAM位被损坏时发生了奇偶错误。终止处理程序从不将控制返回给应用程序。</li></ol><h3 id="Linux-x86-64系统中的异常"><a href="#Linux-x86-64系统中的异常" class="headerlink" title="Linux/x86-64系统中的异常"></a>Linux/x86-64系统中的异常</h3><p>在X86-64系统中，系统调用是通过一条称为syscall的陷阱指令来提供的。C程序用syscall函数可以直接调用任何系统调用，标准C库提供了一组方便的包装函数。这些包装函数将参数打包到一起，以适当的系统调用指令陷入内核，然后将系统调用的返回状态传递回调用程序。系统调用和它们相关的包装函数都成为系统级函数。</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>经典定义：一个执行中程序的实例。系统中每个进程都运行在某个进程的上下文（context）中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。</p><h3 id="逻辑控制流"><a href="#逻辑控制流" class="headerlink" title="逻辑控制流"></a>逻辑控制流</h3><p>程序在执行过程中的一系列的程序计数器（PC）的值。</p><h3 id="并发流"><a href="#并发流" class="headerlink" title="并发流"></a>并发流</h3><p>一个逻辑流在执行的时间上和另一个流重叠，称为并发流，这两个流称为并发地运行。<br>多任务：一个进程和其他进程轮流运行的概念称为多任务。<br>两个流并发地运行在不同处理器核或者计算机上，那么我们称它们为并行流，它们并行地运行并且并行地执行。</p><h3 id="私有地址空间"><a href="#私有地址空间" class="headerlink" title="私有地址空间"></a>私有地址空间</h3><p>进程为每个程序提供它自己的私有地址空间，一般来说是不能被其他进程读或写的。</p><h3 id="用户模式核内核模式"><a href="#用户模式核内核模式" class="headerlink" title="用户模式核内核模式"></a>用户模式核内核模式</h3><p>处理器通常是用某个控制寄存器中的一个模式位（mode bit）来限制应用可以执行的指令以及它可以访问的地址空间范围。<br>没有设置模式位时，进程就允许用户模式。<br>进程进入内核模式的唯一方法就算通过中断、故障或者陷入系统调用这样的异常。</p><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>内核使用一种称为上下文切换的较高层次的异常控制流来实现多任务。<br>内核为每个进程维持一个上下文，这就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈核各种内核数据结构。</p><h2 id="系统调用错误处理"><a href="#系统调用错误处理" class="headerlink" title="系统调用错误处理"></a>系统调用错误处理</h2><p>当Unix系统级函数遇到错误时，它们通常回返回-1，并设置全局整数变量errno来表示什么出错了。程序员应该总是检查错误，但不信的时，许多人都忽略了错误检查，因为它时代码变得臃肿，而且难以读懂。</p><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>Unix提供了大量从C程序中操作进程的系统调用。</p><h3 id="获取进程ID"><a href="#获取进程ID" class="headerlink" title="获取进程ID"></a>获取进程ID</h3><p>每个进程都有一个唯一正数进程ID（PID）。<code>getpid</code>函数返回调用进程的PID。<code>getppid</code>返回它的父进程的PID（创建调用进程的进程）。<br>返回类型为pid_t，在Linux系统上它在type.h里被定义为int。</p><h3 id="创建和终止进程"><a href="#创建和终止进程" class="headerlink" title="创建和终止进程"></a>创建和终止进程</h3><p>进程总是处于下面三种状态之一：</p><ul><li>运行：进程要么在CPU上执行，要么在等待被执行且最终会被内核调度。</li><li>停止：进程的执行被挂起（suspended），且不会被调度。</li><li>终止：进程永远的停止了。三个原因：收到一个信号，该信号的默认行为是终止进程；从主程序返回，调用exit函数。<br>父进程通过<code>fork</code>函数创建新的子进程。<br>父进程和子进程有相同但是独立的地址空间，它们共享文件。</li></ul><h3 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h3><p>当一个子进程由于某种原因终止时，内核不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程回收。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程，从此时开始，该进程就不存在了。一个终止了但还未被回收的进程称为僵尸进程。如固父进程终止了，内核会安排init进程成为它的孤儿进程的养父。</p><h3 id="让进程休眠"><a href="#让进程休眠" class="headerlink" title="让进程休眠"></a>让进程休眠</h3><p>sleep函数将一个进程挂起一段指定的时间。如固请求的时间量已经达到了，sleep返回0，否则返回还剩下的要休眠的秒数。</p><h3 id="加载并运行程序"><a href="#加载并运行程序" class="headerlink" title="加载并运行程序"></a>加载并运行程序</h3><p>execve函数加载并运行可执行目标文件filename，只要但出现错误，如找不到filename，execve才会返回到调用程序。execve调用一次并从不返回。<br>在execve加载了filename之后，它调用启动代码，启动代码设置栈，并将控制传递给新程序的主函数，该主函数有如下形式的原型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv,<span class="keyword">char</span> **envp)</span></span>;</span><br></pre></td></tr></table></figure><p>或等价的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[],<span class="keyword">char</span> *envp[])</span></span>;</span><br></pre></td></tr></table></figure><p>argc是命令参数的个数，argv是命令参数数组，<code>argv[0]-&gt;argv[argc-1]</code>，<code>argv[argc]=NULL</code>，envp变量指向一个以null结尾的指针数组，其中每个指针指向一个环境变量字符串，每个串都是形如<code>name=value</code>的名字-值对。<br>Linux提供了几个函数来操作环境数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure><p>getenv函数在环境数组中搜索字符串<code>&quot;name=value&quot;</code>。如果找到了就返回一个指向value的指针，否则就返回<code>NULL</code>。<br>还有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">setenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name,<span class="keyword">const</span> <span class="keyword">char</span> *newvalue,<span class="keyword">int</span> overwrite)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unsetenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure><p>如果环境数组中包含一个形如<code>&quot;name=oldvalue&quot;</code>的字符串，那么unsetenv就会删除它，而setenv就会用newvalue代替oldvalue，但是只有在overwrite非零时才会这样。如果name不存在，那么setenv就把<code>&quot;name=newvalue&quot;</code>添加到数组中。</p><ul><li>程序和进程<br>fork函数在新的子进程中运行相同的程序，而execve函数在当前进程的上下文加载并运行一个新的程序。它会覆盖当前进程的地址空间，但并没有创建一个新进程，新的程序仍然具有相同的PID，并且继承了execve函数时已打开的所有文件描述符。</li></ul><h3 id="利用fork和execve运行程序"><a href="#利用fork和execve运行程序" class="headerlink" title="利用fork和execve运行程序"></a>利用fork和execve运行程序</h3><p>跳过</p><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>Linux信号：一种更高层的软件形式的异常，它允许进程和内核中断其他进程。<br>低层的硬件异常是由内核处理程序处理的，正常情况这些对用户程序来说都是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。</p><h2 id="信号术语"><a href="#信号术语" class="headerlink" title="信号术语"></a>信号术语</h2><p>传送一个目的信号到进程由两个不同步骤组成：  </p><ul><li>发送信号：内核通过更新目的进程的上下文中的某个状态，发送（递送）一个信号给目的进程。发生信号可能有两个原因：内核检测到一个系统事件；一个进程调用了kill函数，显示地要求内核发送信号给目的进程。  </li><li>接收信号：目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收到了信号。进程可以忽略这个信号，终止或通过执行一个称为信号处理程序的应用层函数来捕获这个信号。<br>一个发错而没有被接收的信号叫做待处理信号，在任何时刻，一种类型至多只有一个待处理信号（如果有一个该类信号，其他会被丢弃）。</li></ul><h3 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h3><ol><li>进程组<br>每个进程都只属于一个进程组，由正整数进程组ID来唯一标识。<code>pid_t getpgrp(void)</code>返回当前进程的进程组ID。<br>子进程和父进程默认情况下属于同一个进程组，一个进程可以通过使用<code>setpgid</code>函数来改变自己或者其他进程的进程组：  </li><li>用/bin/kill程序发送信号    </li><li>从键盘发送信号<br>Unix shell使用作业（job）这个抽象概念来表示对一条命令行求值而创建的进程。在任何时刻至多只有一个前台作业和0个或多个后台作业。在键盘上输入Ctrl+C会导致内核发送一个SIGINT信号到前台进程组中的每一个进程。<br>默认情况下是终止前台作业；Ctrl+Z默认情况下挂起前台作业。  </li><li>用kill函数发送信号<br>进程调用kill函数发送信号给其他进程（包括它们自己）。  </li><li>用alarm函数发送信号<br>进程调用alarm函数发送SIGALRM信号给它自己。  </li></ol><h3 id="接收信号"><a href="#接收信号" class="headerlink" title="接收信号"></a>接收信号</h3><h3 id="阻塞和解除阻塞信号"><a href="#阻塞和解除阻塞信号" class="headerlink" title="阻塞和解除阻塞信号"></a>阻塞和解除阻塞信号</h3><p>隐式阻塞机制（内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号）、显式阻塞机制</p><h3 id="编写信号处理程序"><a href="#编写信号处理程序" class="headerlink" title="编写信号处理程序"></a>编写信号处理程序</h3><p>跳过</p><h3 id="同步流以避免讨厌的并发错误"><a href="#同步流以避免讨厌的并发错误" class="headerlink" title="同步流以避免讨厌的并发错误"></a>同步流以避免讨厌的并发错误</h3><h3 id="显式等待信号"><a href="#显式等待信号" class="headerlink" title="显式等待信号"></a>显式等待信号</h3><p>有时候主程序必须要显示地等待某个信号处理程序运行。</p><h2 id="非本地跳转"><a href="#非本地跳转" class="headerlink" title="非本地跳转"></a>非本地跳转</h2><p>非本地跳转（nonlocal jump），一种C语言提供的用户及异常控制流形式。它将控制直接由一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用-返回序列。nonlocal jump通过<code>setjump</code>和<code>longjump</code>来提供。</p>]]></content>
      
      
      <categories>
          
          <category> 深入理解计算机系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CH7链接</title>
      <link href="2021/01/14/CH7%E9%93%BE%E6%8E%A5/"/>
      <url>2021/01/14/CH7%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a><strong>链接</strong></h1><p>链接（linking）是将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可被加载（复制）到内存并执行。链接可以执行于编译时（compile time），也就是在源代码被翻译成机器代码时；也可以执行于加载时（load time），也就是在程序被加载器（loader）加载到内存系统执行时；甚至执行于运行时（run time），也就是在程序被加载器（loader）加载到内存并执行时；甚至于运行时，也就是由应用程序来执行。在早期的计算机系统中，链接是手动执行的。在现代系统中，链接时由叫做连接器（linker）程序自动执行的。  </p><h2 id="编译器驱动程序"><a href="#编译器驱动程序" class="headerlink" title="编译器驱动程序"></a><strong>编译器驱动程序</strong></h2><p>sum.c、main.c<br>预处理器将main.c翻译成一个ASCII码的中间文件main.i，然后编译器将main.i翻译成ASCII汇编语言文件main.s，然后驱动程序运行汇编器，将main.s翻译成一个可重定位目标文件main.o。<br>sum.c-&gt;sum.i-&gt;sum.s-&gt;sum.o<br>运行链接器程序ld将main.o、sum.o以及一些必要的系统目标文件组合起来，创建一个可执行目标文件prog。</p><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a><strong>静态链接</strong></h2><p>为了构造可执行文件，链接器必须完成两个主要任务：符号解析、重定位。  </p><h2 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a><strong>目标文件</strong></h2><p>三种形式：可重定位目标文件（包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，生成一个可执行目标文件）、可执行目标文件（包含二进制代码和数据，可以直接被复制到内存并执行）、共享目标文件（一种特殊类型的可重定位目标文件，可以在加载或者运行时加载进内存并链接）。</p><h2 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a><strong>可重定位目标文件</strong></h2><h2 id="符号和符号表"><a href="#符号和符号表" class="headerlink" title="符号和符号表"></a><strong>符号和符号表</strong></h2><p>每个可重定位目标模块m有一个符号表，包含：  </p><ul><li>由m模块定义并能被其他模块引用的全局符号。  </li><li>由其他模块定义并能被模块m引用的全局符号。  </li><li>只被模块m定义和引用的局部符号。  </li></ul><h2 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a><strong>符号解析</strong></h2>]]></content>
      
      
      <categories>
          
          <category> 深入理解计算机系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CH6存储器层次结构</title>
      <link href="2021/01/14/CH6%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/"/>
      <url>2021/01/14/CH6%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a><strong>存储器层次结构</strong></h1><h2 id="存储技术"><a href="#存储技术" class="headerlink" title="存储技术"></a><strong>存储技术</strong></h2><h3 id="随机访问存储器（Random-Access-Memory-RAM）"><a href="#随机访问存储器（Random-Access-Memory-RAM）" class="headerlink" title="随机访问存储器（Random-Access Memory,RAM）"></a><strong>随机访问存储器（Random-Access Memory,RAM）</strong></h3><p>分为静态和动态两类（SRAM、DRAM）。SRAM比DRAM更快但更贵。  </p><ol><li>SRAM：用作高速缓存存储器  </li><li>DRAM：用于主存及图形系统的帧缓存区<br>内存系统必须周期性地通过读出，然后重写来刷新内存的每一位。有些系统会使用纠错码。  </li><li>传统的DRAM<br>每个DRAM芯片被连接到某个称为内存控制器的电路，这个电路用来传送$\omega$位到每个DRAM芯片或者一次从每个DRAM芯片传出$\omega$位。  </li><li>内存模块<br>DRAM芯片封装在内存模块中，可以多个DRAM芯片同时读取和写入一个字节（举例8个DRAM芯片），合并后即为一个64位字，然后返回给内存控制器。  </li><li>增强的DRAM  </li></ol><ul><li>快页模式DRAM（Fast Page Model DRAM,FPM DRAM）</li><li>扩展数据输出DRAM（Extended Data Out DRAM，EDO DRAM）</li><li>同步DRAM（Synchronous DRAM，SDRAM）</li><li>双倍数据速率同步DRAM（Double Data-Rate Synchronous）</li><li>视频RAM（Video RAM，VRAM）</li></ul><ol start="6"><li>非易失性存储器（nonvolatile memory）<br>DRAM和SRAM在断电的情况都会丧失它们的信息。只读存储器（read-only Memory）中有的类型可以读也可以写，但整齐称为ROM。<br>PROM(Programmable ROM，可编程ROM)只能被编程一次，还有很多。。。<br>还有可擦写可编程ROM(Erasable Programmable ROM，EPROM)、闪存(flash memory)。存储在ROM设备中的程序通常被称为固件（firmware）。</li><li>访问主存<br>总线(bus)，数据流通过总线在处理器和DRAM主存之间来来回回。</li></ol><h3 id="磁盘存储"><a href="#磁盘存储" class="headerlink" title="磁盘存储"></a><strong>磁盘存储</strong></h3><ol><li>磁盘构造<br>主轴、盘片、磁道、扇区、柱面等概念。</li><li>磁盘容量</li><li>磁盘操作  </li></ol><ul><li>寻道时间</li><li>旋转时间</li><li>传送时间</li></ul><ol start="4"><li>逻辑磁盘块<br>为了对操作系统隐藏磁盘的复杂性，现代磁盘将为它们的构造呈现一个简单的视图，一个B个扇区大小的逻辑块的序列。磁盘块封装中有一个效得硬件/固件设备，称为磁盘控制器，维护着逻辑块号和实际（物理）磁盘山去之间的映射关系。</li><li>连接I/O设备<br>慢于系统总线和内存总线。</li><li>访问磁盘<br>I/O端口、直接内存访问（Direct Memory Access，DMA）、DMA传送（DMA transfer）</li></ol><h3 id="固态硬盘（Solid-State-Disk，SSD）"><a href="#固态硬盘（Solid-State-Disk，SSD）" class="headerlink" title="固态硬盘（Solid State Disk，SSD）"></a><strong>固态硬盘（Solid State Disk，SSD）</strong></h3><p>这是一种基于闪存的存储技术。</p><h2 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a><strong>局部性</strong></h2><p>通常表现为时间局部性（在一个具有良好的时间局部性程序中，被引用过一次的内存位置很可能在不远的将来再被多次引用）和空间局部性（在一个具有良好空间局部性的程序中，如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用附件的一个内存位置）。</p><h2 id="存储器层次结构（memery-hierarchy）"><a href="#存储器层次结构（memery-hierarchy）" class="headerlink" title="存储器层次结构（memery hierarchy）"></a><strong>存储器层次结构（memery hierarchy）</strong></h2><ol start="0"><li>寄存器（CPU寄存器保存着从高速缓存存储器去除的字）  </li><li>L1高速缓存（SRAM）（L1&lt;-L2，保存取出的缓存行）  </li><li>L2高速缓存（SRAM）（L2&lt;-L3，保存取出的缓存行）  </li><li>L3高速缓存（SRAM）（L3&lt;-主存，保存取出的缓存行）  </li><li>主存（DRAM）（主存&lt;-本地磁盘，保存着取出的磁盘块）  </li><li>本地二级存储（本地磁盘）（保存从远程网络服务器取出的文件）  </li><li>远程二级存储（分布式文件系统、Web服务器）  </li></ol><h3 id="存储器层次结构中的缓存"><a href="#存储器层次结构中的缓存" class="headerlink" title="存储器层次结构中的缓存"></a><strong>存储器层次结构中的缓存</strong></h3><p>高速缓存（cache）是一个小而快的存储设备，它作为存储在更大、也更慢的设备中的数据对象的缓冲区域。使用高速缓存的过程称为<strong>缓存（caching）</strong>。  </p><ol><li>缓存命中：当程序需要第$k+1$层的一个数据对象d时，优先在第$k$层查找d，如果d刚好存储在第$k$层，那么直接读取，这就是我们说的缓存命中。  </li><li>缓存不命中：如果第$k$层没有缓存数据对象d，那么就是我们说的缓存不命中。当发生缓存不命中时，第$k$层的缓存从第k+1层缓存取出包含d的那个块，如果第k层缓存已经满了，可能就会覆盖现存的一个块（牺牲块）。  </li><li>缓存不命中的种类：强制性不命中、冲突不命中、容量不命中。  </li><li>缓存管理：编译器管理寄存器文件；L1、L2和L3层的缓存完全有内置在缓存中的硬件逻辑来管理；在一个有虚拟内存的系统中，DRAM主存作为存储在磁盘上的数据块的缓存，是由操作系统软件和CPU上的地址翻译硬件共同管理的。  </li></ol><h3 id="存储器层次结构概念小结"><a href="#存储器层次结构概念小结" class="headerlink" title="存储器层次结构概念小结"></a><strong>存储器层次结构概念小结</strong></h3><p>概括来说，基于缓存的存储器层次结构行之有效，是因为较慢的存储设备比较快的存储设备更便宜，还因为程序倾向于展示局部性（可以补偿不命中的代价）</p><h2 id="高速缓存存储器"><a href="#高速缓存存储器" class="headerlink" title="高速缓存存储器"></a><strong>高速缓存存储器</strong></h2><p>原来存储器层次结构只有三层：寄存器、主存、磁盘；随着CPU和主存之间逐渐增大的差距，系统设<br>计者被迫在CPU寄存器文件和主存之间插入了一个小的SRAM高速缓存存储器，称为L1高速缓存，后来又插入了L2、L3。</p><h3 id="通用的高速缓存存储器组织结构"><a href="#通用的高速缓存存储器组织结构" class="headerlink" title="通用的高速缓存存储器组织结构"></a><strong>通用的高速缓存存储器组织结构</strong></h3><p>高速缓存的结构可以用元组（S，E，B，m）来描述。S：$S=2^s$个高速缓存组；E：每个组包含E个高速缓存行；B：每个行由$B=2^b$字节的数据块组成的，一个有效位指明这个行是否包含有意义的信息，还有t个标记位来唯一的标识这个块。$t+s+b=m$，t位标记块，s位组索引，b位时块偏移。容量$C=S\times E\times B$。</p><h3 id="直接映射高速缓存"><a href="#直接映射高速缓存" class="headerlink" title="直接映射高速缓存"></a><strong>直接映射高速缓存</strong></h3><p>每个组只有一行  </p><ol><li>直接映射高速缓存中的组选择  </li><li>直接映射高速缓存中的行匹配  </li><li>直接映射高速缓存中的字选择  </li><li>直接映射高速缓存不命中时的行替换  </li><li>综合：运行中的直接映射高速缓存  </li></ol><h3 id="组相联高速缓存"><a href="#组相联高速缓存" class="headerlink" title="组相联高速缓存"></a><strong>组相联高速缓存</strong></h3><ol><li>组相联高速缓存中的组选择  </li><li>组相联高速缓存中的行匹配和字选择：搜索组中的每一行来匹配标记，命中后块偏移从这个块中选择字  </li><li>组相联高速缓存中的不命中的行替换：若无空行，则采用替换策略，有LFU（Least-Frequently-Used，最不常使用）、LRU（Least-Recently-USed，最近最少使用）等。  </li></ol><h3 id="全相联高速缓存"><a href="#全相联高速缓存" class="headerlink" title="全相联高速缓存"></a><strong>全相联高速缓存</strong></h3><p>$E=C/B$，S=1，仅有一个组。</p><ol><li>组选择  </li><li>行匹配和字选择<br>因为高速缓存电路必须并行地搜索许多相匹配的标记，构造一个又大又快的相联高速缓存很困难，而且昂贵。因此全相联高速缓存只适合做小的高速缓存，例如虚拟内存系统中翻译备用缓冲器（TLB），它缓存页表项。</li></ol><h3 id="有关写的问题"><a href="#有关写的问题" class="headerlink" title="有关写的问题"></a><strong>有关写的问题</strong></h3><p>如果命中，更新了副本之后，如何更新在低一层中的副本。  </p><ul><li>直写：最简单的方法，立即写回到下一级。  </li><li>写回：等待替换算法要驱逐这个更新过的块的时候，才把它紧接着写到低一层（需要在每个高速缓存行中额外保留一个修改位来标识该行是否被修改过）。<br>如果不命中：  </li><li>写分配：加载相应的低一层中的块到高速缓存行中，然后更新这个高速缓存块  </li><li>非写分配：避开高速缓存，直接写到低一层</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深入理解计算机系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络编程</title>
      <link href="2021/01/13/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>2021/01/13/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>本文主要总结C++网络编程中关于套接字编程的相关函数。  </p><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="创建一个套接字：socket"><a href="#创建一个套接字：socket" class="headerlink" title="创建一个套接字：socket()"></a>创建一个套接字：<code>socket()</code></h2><p><code>int socket(int family, int type, int protocol);</code><br>其中family指明协议族，IPV4是<code>AF_INET</code>，IPv6<code>AF_INET6</code>；type指明套接字类型，TCP为<code>SOCK_STREAM</code>，UDP是<code>SOCK_DGRAM</code>。protocol参数设为某个协议的类型常值，或者设为0。</p><h2 id="建立连接：connect"><a href="#建立连接：connect" class="headerlink" title="建立连接：connect()"></a>建立连接：<code>connect()</code></h2><p><code>int connect(int sockfd, const struct sockaddr *serveraddr, socklen_t addrlen);</code><br>sockfd是socket函数返回的套接字描述符，第二个参数是指向一个套接字地址的指针和该结构大小。连接成功返回0，否则-1。</p><p>实际使用中，我们一般传入sockaddr_in指针，进行类型转换为sockaddr，sockaddr_in结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></span><br><span class="line"><span class="keyword">short</span> <span class="keyword">int</span> sin_family;<span class="comment">//协议族</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> sin_port;<span class="comment">//存储端口号，只能用网络字顺序</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span><span class="comment">//存储IP地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绑定端口：bind"><a href="#绑定端口：bind" class="headerlink" title="绑定端口：bind()"></a>绑定端口：<code>bind()</code></h2><p><code>int bind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen);</code><br>将一个本地协议地址和套接字描述符绑定起来。  </p><p>一般来说，端口我们可以自己指定或者使用0让内核自己选择一个临时端口；IP地址可以选择统配地址让内核等套接字已连接再选择一个本地地址。  </p><h2 id="监听：listen"><a href="#监听：listen" class="headerlink" title="监听：listen()"></a>监听：<code>listen()</code></h2><p>一般来说，服务器会打开一个监听套接字，用来等待来自client的连接请求：<br><code>int listen(int sockfd,int backlog);</code><br>sockfd是socket函数创建的套接字，然后backlog是为这个监听套接字维护的队列长度，队列包括已连接队列（established状态）和未连接队列（syn_recv状态）。  </p><h2 id="生成已连接套接字：accept"><a href="#生成已连接套接字：accept" class="headerlink" title="生成已连接套接字：accept()"></a>生成已连接套接字：<code>accept()</code></h2><p><code>int accept(int sockfd, struct sockaddr *cliaddr, socklen_t * addrlen);</code><br>该函数会从监听套接字sockfd的已连接队列中取出一个连接，返回一个已连接套接字描述符，并且返回另一方套接字地址和地址结字节数。  </p><h2 id="关闭套接字：close"><a href="#关闭套接字：close" class="headerlink" title="关闭套接字：close()"></a>关闭套接字：<code>close()</code></h2><p><code>int close(int sockfd);</code><br>该函数可以关闭一个套接字描述符，不过如果该套接字使用引用计数，如果被多个进程拥有，则只会计数-1，当计数为0时候才会真正的关闭。  </p><h2 id="设置套接字参数：getsockopt-和setsockopt"><a href="#设置套接字参数：getsockopt-和setsockopt" class="headerlink" title="设置套接字参数：getsockopt()和setsockopt()"></a>设置套接字参数：<code>getsockopt()</code>和<code>setsockopt()</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen);</span><br><span class="line">int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);</span><br></pre></td></tr></table></figure><p>上述两个函数分别用来获得套接字的参数和设置参数，一般情况下先获得已有参数，然后将想要加入的参数和以后参数做或运算，然后再设置参数即可。函数的各个参数具体使用建议参考《UNIX网络编程 卷1：套接字联网API》。  </p><h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><h2 id="创建套接字：socket"><a href="#创建套接字：socket" class="headerlink" title="创建套接字：socket()"></a>创建套接字：<code>socket()</code></h2><p>创建套接字的方法上一章已经说过了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure><p>不加赘述了。  </p><h2 id="接收数据：recvfrom"><a href="#接收数据：recvfrom" class="headerlink" title="接收数据：recvfrom()"></a>接收数据：<code>recvfrom()</code></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags, struct sockaddr *from, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"><span class="comment">// 成功返回0，否则-1</span></span><br></pre></td></tr></table></figure><p>参数sockfd是套接字描述符，buff是指向读缓冲区的指针，btybes是最大读入的字节数（避免缓冲区溢出）。 最后两个参数数数据发送方的套接字地址和结构字节数。  </p><h2 id="发送数据：sendto"><a href="#发送数据：sendto" class="headerlink" title="发送数据：sendto()"></a>发送数据：<code>sendto()</code></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags, struct sockaddr *to, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"><span class="comment">// 成功返回0，否则-1</span></span><br></pre></td></tr></table></figure><p>发送数据，buff为写缓冲区，btybe是待写入的字节数，后面是发送的目的地套接字地址和地址结构的字节数。</p><h1 id="读写函数"><a href="#读写函数" class="headerlink" title="读写函数"></a>读写函数</h1><h2 id="recv-和send"><a href="#recv-和send" class="headerlink" title="recv()和send()"></a><code>recv()</code>和<code>send()</code></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>前面3参数很好理解，flags是一个额外的参数，具体可看《UNIX网络编程 卷一：套接字联网API》。  </p><h2 id="readv-和writev"><a href="#readv-和writev" class="headerlink" title="readv()和writev()"></a><code>readv()</code>和<code>writev()</code></h2><p>readv和writev允许单个系统调用读入到或写出自一个或多个缓冲区。这些操作被称为分散度和集中写。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readv</span><span class="params">(<span class="keyword">int</span> sockfd, cosnt struct iovec *iov, <span class="keyword">int</span> iovcnt)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">writev</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt)</span></span>;</span><br></pre></td></tr></table></figure><p>这两个函数的第2个参数都是指向某个iovec结构数组的一个指针，其中iovec结构再头文件&lt;sys/uio.h&gt;中定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>&#123;</span></span><br><span class="line"><span class="keyword">void</span> *iov_base;<span class="comment">//内存起始地址</span></span><br><span class="line">   <span class="keyword">size_t</span> iov_len;<span class="comment">//内存大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个函数可以用于任何描述符，而不仅仅限于套接字。另外writev是一个原子操作，意味着对于一个基于记录的协议而言，一次writev调用只产生单个UDP数据报。</p><h1 id="获取地址"><a href="#获取地址" class="headerlink" title="获取地址"></a>获取地址</h1><h2 id="gethostbyname"><a href="#gethostbyname" class="headerlink" title="gethostbyname()"></a><code>gethostbyname()</code></h2><p>gethostbyname()函数主要作用：用域名或者主机名获取地址，操作系统提供的库函数。以下的讨论基于linux环境。<br>域名系统（Domain Name System, DNS）主要用于主机名字与IP地址之间的映射。每个组织机构往往运行一个或多个名字服务器（name server），我们编写的客户端和服务器等应用程序通过调用解析器（resolver）的函数库中的函数接触DNS服务器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct hostent *<span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure><p>如果成功则返回一个hostent指针，否则返回NULL。当发生错误时，它不设置errno变量，设置全局整数变量h_errno。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span>  *h_name;            <span class="comment">/*主机规范名*/</span></span><br><span class="line"><span class="keyword">char</span> **h_aliases;         <span class="comment">/*主机别名列表*/</span></span><br><span class="line">   <span class="keyword">int</span>h_addrtype;        <span class="comment">/*地址类型，只能是IPv4，本函数无法解决IPv6*/</span></span><br><span class="line">   <span class="keyword">int</span> h_length;          <span class="comment">/*IP地址字节数*/</span></span><br><span class="line">   <span class="keyword">char</span> **h_addr_list;</span><br><span class="line">   <span class="comment">/*主机的IP地址，是网络字节序，需要通过inet_ntop函数转换*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="gethostbyaddr"><a href="#gethostbyaddr" class="headerlink" title="gethostbyaddr()"></a><code>gethostbyaddr()</code></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct hostent *<span class="title">gethostbyaddr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *addr, <span class="keyword">socklen_t</span> len, <span class="keyword">int</span> type)</span></span>;</span><br></pre></td></tr></table></figure><p>根据地址和地址类型来获得主机名。返回类型和gethostbyname一样。注意addr是网络字节序。</p>]]></content>
      
      
      <categories>
          
          <category> Linux C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最长上升子序列</title>
      <link href="2021/01/13/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>2021/01/13/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h1><h2 id="题目300"><a href="#题目300" class="headerlink" title="题目300"></a>题目300</h2><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">链接</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><h3 id="暴力方法"><a href="#暴力方法" class="headerlink" title="暴力方法"></a>暴力方法</h3><p>数组dp记录如下信息：<br>dp[i]：序列nums[0-&gt;i]中以nums[i]为末尾的最长子序列的长度<br>那么递推式如下：<br>$dp[i]=max_{0\leq j&lt;i,nums[j]&lt;nums[i]}dp[j]+1$。<br>code如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size())</span></span>;<span class="comment">//dp[i]表示前i+1个元素末尾为第i个元素的最长上升子序列长度，一定有性质：if i&lt;j then dp[i]&lt;dp[j]</span></span><br><span class="line">        <span class="comment">// dp[i]=max(dp[j])+1,七张0&lt;=j&lt;i，且num[j]&lt;num[i]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            dp[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;nums[i])&#123;</span><br><span class="line">                    dp[i]=<span class="built_in">max</span>(dp[i],dp[j+<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(),dp.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(nlogn)$</p><h3 id="贪心-二分查找"><a href="#贪心-二分查找" class="headerlink" title="贪心+二分查找"></a>贪心+二分查找</h3><p><a href="https://leetcode-cn.com/problemslongest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/">该算法参考</a><br>考虑一个简单的贪心，如果我们需要让上升子序列近可能的长，则我们需要让序列上升得尽可能得慢，因此我们希望每次在上升子序列最后加上那个的数字尽可能小。<br>基于以上贪心策略，我们维护一个数组$dp[i]$，表示长度为i的最长上升子序列的末尾元素的最小值，用len记录目前最长上升子序列的长度，起始时$len$为1，$d[1]=nums[0]$。<br>同时我们可以很容易发现$dp[i]$是关于$i$单调递增的。<br>我们依次遍历数组$nums$中的每一个元素，并更新数组$dp$和$len$的值。如果$nums[i]&gt;dp[len]$则更新$len=len+1$，否则在$dp[1…len]$中找到满足$dp[i-1]&lt;nums[j]&lt;dp[i]$的下标$i$，并更新$dp[i]=nums[j]$。根据$dp$数组的单调性，我们可以使用二分查找优化时间复杂度。<br>以输入序列$[10,9,2,5,3,7,101,18]$为例:</p><ul><li>第一步插入10，$dp=[10]$；  </li><li>第二步插入9，$dp=[9]$；  </li><li>第三步插入2,$dp=[2]$；  </li><li>第四步插入5，$dp=[2,5]$；  </li><li>第五步插入3，$dp=[2,3]$；  </li><li>第六步插入7，$dp=[2,3,7]$；  </li><li>第七步插入101，$dp=[2,3,7,101]$；  </li><li>第八步插入18，$dp=[2,3,7,18]$。<br>最终得到最大递增子序列长度为3。<br>代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;dp,<span class="keyword">int</span> len,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">1</span>,r=len,mid;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[l]&gt;=num)<span class="keyword">return</span> l<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dp[r]&lt;num)<span class="keyword">return</span> r;</span><br><span class="line">            mid=(r-l)/<span class="number">2</span>+l;</span><br><span class="line">            <span class="keyword">if</span>(dp[mid]&gt;=num)r=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size()+<span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[len]&lt;nums[i])&#123;</span><br><span class="line">                dp[++len]=nums[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> index=<span class="built_in">upper_bound</span>(dp,len,nums[i]);</span><br><span class="line">            dp[index+<span class="number">1</span>]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="题目17-08"><a href="#题目17-08" class="headerlink" title="题目17.08"></a>题目17.08</h2><p><a href="https://leetcode-cn.com/problems/circus-tower-lcci/">链接</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>有个马戏团正在设计叠罗汉的表演节目，一个人要站在另一人的肩膀上。出于实际和美观的考虑，在上面的人要比下面的人矮一点且轻一点。已知马戏团每个人的身高和体重，请编写代码计算叠罗汉最多能叠几个人。</p><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>考虑按照每个人的高度重新升序排列，那么实际上只需要找到排序后数组的满足体重升序的最长子序列即为结果。但是我们要注意到有如下例子（假如我们按照高度升序，高度相同体重升序排列）：<br>height：1 2 3 3 5 6 7<br>weight：1 2 3 4 5 6 7<br>对weight求最长子序列应该是，$[1,2,3,4,5,6,7]$，长度为7，而实际上长度应该是6，因为{3,3}和{3,4}的高度相同。所以我们可以说高度相同的人应该至多只有一人在最长升序子序列中，我们对高度相同的人按照体重做降序排列，即可避免此问题，因为排序后的序列中高度相同的人，按体重降序排列，如果有超过两个人同时在序列中，则于序列按照升序排列不符合。<br>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp;a,pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.first==b.first? a.second&gt;b.second:a.first&lt;b.first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;dp,<span class="keyword">int</span> len,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">1</span>,r=len,mid;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[l]&gt;=num)<span class="keyword">return</span> l<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dp[r]&lt;num)<span class="keyword">return</span> r;</span><br><span class="line">            mid=(r-l)/<span class="number">2</span>+l;</span><br><span class="line">            <span class="keyword">if</span>(dp[mid]&gt;=num)r=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size()+<span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[len]&lt;nums[i])&#123;</span><br><span class="line">                dp[++len]=nums[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> index=<span class="built_in">upper_bound</span>(dp,len,nums[i]);</span><br><span class="line">            dp[index+<span class="number">1</span>]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bestSeqAtIndex</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height, vector&lt;<span class="keyword">int</span>&gt;&amp; weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height.<span class="built_in">size</span>()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; <span class="built_in">num</span>(height.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;height.<span class="built_in">size</span>();i++)num[i]=&#123;height[i],weight[i]&#125;;</span><br><span class="line">        <span class="built_in">sort</span>(num.<span class="built_in">begin</span>(),num.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(num.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.<span class="built_in">size</span>();i++)temp[i]=num[i].second;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">lengthOfLIS</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>蓄水池抽样</title>
      <link href="2021/01/13/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7/"/>
      <url>2021/01/13/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="蓄水池抽样算法"><a href="#蓄水池抽样算法" class="headerlink" title="蓄水池抽样算法"></a><strong>蓄水池抽样算法</strong></h1><h2 id="题目382链表随机节点"><a href="#题目382链表随机节点" class="headerlink" title="题目382链表随机节点"></a><strong>题目382链表随机节点</strong></h2><p><a href="https://leetcode-cn.com/problems/linked-list-random-node/">题目链接</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h3><p>给定一个单链表，随机选择链表的一个节点，并返回相应的节点值。保证每个节点被选的概率一样。<br>进阶:如果链表十分大且长度未知，如何解决这个问题？你能否使用常数级空间复杂度实现？  </p><h3 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a><strong>代码模板</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(ListNode* head) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="蓄水池抽样算法-1"><a href="#蓄水池抽样算法-1" class="headerlink" title="蓄水池抽样算法"></a><strong>蓄水池抽样算法</strong></h3><p>经常出现在大数据流中的随机抽样问题，即当内存无法加载全部数据时，如何从包含未知大小的数据流中随机选取k个数据，并且要保证每个数据被抽取到的概率相等。  </p><ul><li><strong>当k=1时，即此题的情况</strong><br>也就是说，我们每次只能读一个数据。<br>假设数据流含有N个数，我们知道如果要保证所有的数被抽到的概率相等，那么每个数抽到的概率应该为1/N。<br>那么如何保证呢？<br>先说方案：<br>每次只保留一个数，当遇到第i个数时，以1/i的概率保留它，(1-i)/i的概率保留原来的数。<br>举例说明：  </li><li>遇到1，概率为1，保留第一个数。</li><li>遇到2，概率1/2，这个时候1和2各1/2的概率被保留</li><li>遇到3，3被保留的概率为1/3，2/3的概率1被保留，（之前剩下的数假设1被保留，此时1被保留的概率为 2/3*1/2=1/3）</li><li>遇到4，4被保留的概率为1/4，3/4的概率1被保留，（之前剩下的数假设1被保留，此时1被保留的概率为 3/4*1/3=1/4）<br>以此类推，每个数据被保留的概率为1/N（可以使用数学归纳法证明）<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(ListNode* head) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;head = head;</span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ListNode* phead = <span class="keyword">this</span>-&gt;head;</span><br><span class="line">        <span class="keyword">int</span> val = phead-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (phead)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">rand</span>() % count++ == <span class="number">0</span>)</span><br><span class="line">                val = phead-&gt;val;</span><br><span class="line">            phead = phead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><strong>当k=m时</strong><br>也就是说，我们每次能读m个数据。<br>和上面相同的道理，只不过概率在每次乘以了m而已<br>当k&gt;1时<br>对于k&gt;1的情况，我们可以采取类似的策略：</li></ol><ul><li>假设数据流中含有N个数据，要保证每条数据被抽取到的概率相等，那么每条数据被抽取的概率必然是$\frac kN$  </li><li>对于前$k$个数$n_1,n_2,…,n_k$，我们我们保留下来，则$p(n_1)=p(n_2)=…=p(n_k)=1$（下面的连等我们采用$p(n_{1-k})$的形式）</li><li>对于第$k+1$个数$n_{k+1}$，以$\frac{k}{k+1}$的概率保留它（这里指本次保留下来），那么前$k$个数中的$n_r(r\in1-k)$被保留下来的概率可以表示为：<br>$p(n_r被保留)=p(上一轮n_r被保留)\times (p(n_{k+1}被丢弃)+p(n_{k+1}没有被丢弃)\times p(n_r没有被替换))$，即$p_{1-k}=\frac{1}{k+1}+\frac{k}{k+1}\times \frac{k-1}{k}=\frac{k}{k+1}$  </li><li>对于第$k+2$个数$n_{k+2}$，以$\frac{k}{k+2}$的概率保留它（这里只指本次保留下来），那么前k+1个数中被保留下来的数中的$n_r(r\in1-k+1)$被保留的概率为：<br>$p_{1-k}=\frac{k}{k+1}\times\frac{2}{k+2}+\frac{k}{k+2}\times\frac{k}{k+1}\times\frac{k-1}{k}=\frac{k}{k+2}$</li><li>……</li><li>对于第$i(i&gt;k)$个数$\frac{k}{i}$的概率保留第$i$个数，并以$\frac{1}{k}$的概率与前面已选择的$k$个数中的任意一个替换。<br>对于前$k$个数，全部保留，对于第$i(i&gt;k)$个数，以$\frac{k}{i}$的概率保留第$i$个数，并以$\frac{1}{k}$的概率与前面已选择的$k$个数中的一个进行替换。</li></ul><h2 id="题目398-随机数索引"><a href="#题目398-随机数索引" class="headerlink" title="题目398 随机数索引"></a><strong>题目398 随机数索引</strong></h2><p><a href="https://leetcode-cn.com/problems/random-pick-index/">题目链接</a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;&amp; nums;</span><br><span class="line">    <span class="built_in">Solution</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums):<span class="built_in">nums</span>(nums)&#123;</span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pick</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">1</span>,res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==target)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">rand</span>()%(k++)==<span class="number">0</span>)res=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="2021/01/13/%E6%95%B0%E7%BB%84/"/>
      <url>2021/01/13/%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h1><h2 id="题目1051-高度检查器"><a href="#题目1051-高度检查器" class="headerlink" title="题目1051 高度检查器"></a><strong>题目1051 高度检查器</strong></h2><p><a href="">链接</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h3><p>学校在拍年度纪念照时，一般要求学生按照<strong>非递减</strong>的高度顺序排列。<br>请你返回能让所有学生以<strong>非递减</strong>高度排列的最小必要移动人数。<br>注意，当一组学生被选中时，他们之间可以以任何可能的方式重新排序，而未被选中的学生应该保持不动。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h3><ul><li>输入：<code>height=[1,1,4,2,1,3]</code></li><li>输出：<code>3</code></li></ul><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h3><ol><li>$1\leqslant height.length \leqslant 100$</li><li>$1\leqslant height[i] \leqslant 100$</li></ol><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a><strong>方法1</strong></h3><p>将数组非降序排序，然后比较排序前后数值不同的位置个数即可。<br>时间复杂度：O(nlogn)<br>空间复杂度：O(n)</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">heightChecker</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; heights)</span></span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; temp=heights;</span><br><span class="line">        <span class="built_in">sort</span>(temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">if</span>(temp[i]!=heights[i])res++;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a><strong>方法2</strong></h3><p>考虑到$1\leqslant height[i]\leqslant 100$，使用计数排序效率更高。<br>创建一个规模为101的数组<code>count</code>，<code>count[i](1&lt;=i&lt;=100)</code>表示高度<code>i</code>出现次数。遍历数组<code>height</code>然后获得<code>count</code>，然后利用双指针来计算不同的个数。<br>时间复杂度：O(n+100)<br>空间复杂度：O(100)</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a><strong>代码</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">heightChecker</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; heights)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count[<span class="number">101</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> h:heights)count[h]++;</span><br><span class="line">        <span class="keyword">int</span> p1=<span class="number">1</span>,p2=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1&lt;=<span class="number">100</span>&amp;&amp;p2&lt;heights.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!count[p1])p1++;</span><br><span class="line">            <span class="keyword">if</span>(p1&gt;<span class="number">100</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(p1!=heights[p2])res++;</span><br><span class="line">            count[p1]--;</span><br><span class="line">            p2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="题目08-03-魔术索引"><a href="#题目08-03-魔术索引" class="headerlink" title="题目08.03.魔术索引"></a><strong>题目08.03.魔术索引</strong></h2>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数和相加</title>
      <link href="2021/01/13/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
      <url>2021/01/13/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数组值相加问题"><a href="#数组值相加问题" class="headerlink" title="数组值相加问题"></a>数组值相加问题</h1><p>遇到形如$num_1[i]+num_2[j]+…+num_n[l]$=某个目标值target的问题，都考虑对数组进行一个划分：$num_1,num_2,…,num_t$和$num_{t+1}…num_{n}$的形式，把前者的一个哈希表中，然后对后者遍历求和得到sum，然后在哈希表中搜索target-sum就可以降低复杂度了。</p><h2 id="四数相加"><a href="#四数相加" class="headerlink" title="四数相加||"></a>四数相加||</h2><p><a href="https://leetcode-cn.com/problems/4sum-ii/">链接</a></p><h3 id="题目表述"><a href="#题目表述" class="headerlink" title="题目表述"></a>题目表述</h3><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。<br>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。</p><h3 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h3><p>分成A、B和C、D，时间复杂度由$O(n^4)$降低为$O(n^2)$。<br>code：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A, vector&lt;<span class="keyword">int</span>&gt;&amp; B, vector&lt;<span class="keyword">int</span>&gt;&amp; C, vector&lt;<span class="keyword">int</span>&gt;&amp; D)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N=A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a:A)<span class="keyword">for</span>(<span class="keyword">int</span> b:B)map[a+b]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c:C)<span class="keyword">for</span>(<span class="keyword">int</span> d:D)res+=map[-c-d];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排列组合</title>
      <link href="2021/01/13/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
      <url>2021/01/13/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h1><h2 id="nextpermutation和prev-permutation"><a href="#nextpermutation和prev-permutation" class="headerlink" title="nextpermutation和prev_permutation"></a>nextpermutation和prev_permutation</h2><p>STL提供了两个用来计算排列组合关系的算法，分别是next_permutation和prev_permutation。首先我们必须了解什么是“下一个”排列组合，什么是“前一个”排列组合。考虑三个字符组成的序列{a,b,c}。<br>这个序列有6个可能的组合：abc、acb、bac、bca、cab、cba。这些排列组合根据less-than操作符做字典顺序的排序。<br>next_permuation会取得[first,last)所示之序列的下一个排列组合，如果没有下一个排列组合，便返回false，否则返回true。  </p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>这样想，加如要寻找下一个排列，则这两个排列一定有尽可能长的前缀相同，所以我们可以从后往前看这个序列，如果后面的若干个数字有下一个排列，则问题得到了解决。<br>什么情况有下一个排列？非降序！比方说124653，3、53、653都不存在下一个排列，因为是降序的，而4653是存在下一个排列的，那么我们只需要返回”12”+next(“4653”)即可，一直4653的第一个元素以后都是降序的，我们只需要从后往前找到第一个大于首元素的即可（一定存在，因为第二个必然比第一个大），此例子中为5，那么下一个排列开头变为了5，然后只要找到643的最小排列，考虑到把4放入原来5的位置并不改变降序性质，故其实只需要逆置后面即可。<br>算法逻辑：从后往前搜索找到第一组arr[i-1] &lt; arr[i]，然后从后往前搜索找到arr[j] &gt; a[i-1]，然后替换arr[i-1]和arr[j],然后对a[i]-&gt;a[end]逆置。本例结果为125346。<br>找上一个排列的算法流程基本相同，并且本算法可用于有重复元素的序列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">next_permutation</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> item=nums.<span class="built_in">end</span>();</span><br><span class="line">    item--;</span><br><span class="line">    <span class="keyword">for</span>(;item!=nums.<span class="built_in">begin</span>();item--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*item&gt;*(item<span class="number">-1</span>))<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(item==nums.<span class="built_in">begin</span>())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    item--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> j=nums.<span class="built_in">end</span>()<span class="number">-1</span>;j!=item;j--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*item&lt;*j)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=*j;</span><br><span class="line">            *j=*item;</span><br><span class="line">            *item=temp;</span><br><span class="line">            <span class="built_in">reverse</span>(item+<span class="number">1</span>,nums.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>脑筋急转弯</title>
      <link href="2021/01/13/%E8%84%91%E7%AD%8B%E6%80%A5%E8%BD%AC%E5%BC%AF/"/>
      <url>2021/01/13/%E8%84%91%E7%AD%8B%E6%80%A5%E8%BD%AC%E5%BC%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="脑筋急转弯"><a href="#脑筋急转弯" class="headerlink" title="脑筋急转弯"></a>脑筋急转弯</h1><h2 id="题目777-在LR字符串中交换相邻字符"><a href="#题目777-在LR字符串中交换相邻字符" class="headerlink" title="题目777 在LR字符串中交换相邻字符"></a>题目777 在LR字符串中交换相邻字符</h2><p><a href="https://leetcode-cn.com/problems/swap-adjacent-in-lr-string/">链接</a></p><h2 id="题目1227-飞机座位分配概率"><a href="#题目1227-飞机座位分配概率" class="headerlink" title="题目1227 飞机座位分配概率"></a>题目1227 飞机座位分配概率</h2><p><a href="https://leetcode-cn.com/problems/airplane-seat-assignment-probability/">链接</a></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>按次序上飞机的乘客编号分别为1-n。</p><ul><li>情况1<br>乘客1选中了自己的位置（概率为1/n），那么后面每个人都可以坐上自己的位置，n号坐在自己位置的概率为1/n  </li><li>情况2<br>乘客1选中了n号位置（概率为1/n），那么n号将无法坐在自己的座位上。  </li><li>情况3<br>乘客1选中了i（0 &lt; i &lt; n）号位置（概率为1/n），那么从2到i-1号都能坐上自己的位置，i号将随机选择一个位置坐下，<br>那么关于n坐在自己的位置上的概率问题规模缩减到了（n-i+1）,最终概率为1/n*P(n-i+1)  </li></ul><p>综上所述<br>概率P(n)=1/n+1/n*(P(n-2+1)+P(n-3+1)+…+P(2))  n&gt;3<br>考虑到P(1)=1，<br>所以P(n)=1/n*(P(n-1)+P(n-2)+…+P(1))，<br>而P(1)=1，故P(2)=1/2*(P(1))=1/2，P(3)=1/3*(P(1)+P(2))=1/2，<br>数学归纳法证明P(n)=1/2 when n&gt;=2：  </p><ul><li>1<br>P(2)=1/2已知</li><li>2<br>假设P(i)=1/2，任取2&lt;=i&lt;=k, k&gt;=2</li><li>3<br>那么P(k+1)=(P(1)+…+P(k))/(k+1)=(1+1/2+…+1/2)/(k+1)=(1+(k+1)/2)/(k+1)=1/2  </li></ul><p>故最终结果为P(n)=(n==1)? 1:1/2</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快速幂</title>
      <link href="2021/01/13/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
      <url>2021/01/13/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a><strong>快速幂</strong></h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a><strong>描述</strong></h2><p>假设我们要设计一个函数<code>pow(double a,int n)</code>计算a^n。  </p><h2 id="暴力算法"><a href="#暴力算法" class="headerlink" title="暴力算法"></a><strong>暴力算法</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>&gt;)<span class="keyword">return</span> <span class="number">1.0</span>/<span class="built_in">pow</span>(a,-n);</span><br><span class="line">    <span class="keyword">double</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)res*=a;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，时间复杂度为O(n)。</p><h2 id="快速幂算法"><a href="#快速幂算法" class="headerlink" title="快速幂算法"></a><strong>快速幂算法</strong></h2><p>我们考虑如下情况，计算3^5，之前的暴力算法需要计算五次，那么我们这样计算：$3^5=3^{2\times2+}={3^2}^2\times3$，我们可以发现只需要计算3次，<br>更加通用的表示如下 $a^n=(a^2)^{\lfloor n/2\rfloor}\times 2(n-\lfloor n/2\rfloor)\times a$<br>那么我们可以递归地设计函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1.0</span>/<span class="built_in">pow</span>(a,-n);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n%<span class="number">2</span>==<span class="number">0</span>? <span class="built_in">pow</span>(a*a,n/<span class="number">2</span>):<span class="built_in">pow</span>(a*a,n/<span class="number">2</span>)*a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以啊发现时间复杂度降低为O(logn)。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a><strong>优化</strong></h3><p>可以非递归实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1.0</span>/<span class="built_in">pow</span>(a,-n);</span><br><span class="line">    <span class="keyword">double</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            a=a*a;</span><br><span class="line">            n/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res*=a;</span><br><span class="line">            a=a*a;</span><br><span class="line">            n/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还可以进一步优化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1.0</span>/<span class="built_in">pow</span>(a,-n);</span><br><span class="line">    <span class="keyword">double</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)res*=a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        n/=<span class="number">2</span>; <span class="comment">// or n=n&gt;&gt;2;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>递归</title>
      <link href="2021/01/13/%E9%80%92%E5%BD%92/"/>
      <url>2021/01/13/%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="题目687"><a href="#题目687" class="headerlink" title="题目687"></a>题目687</h2><p>将二叉搜索树变平衡<br><a href="https://leetcode-cn.com/problems/longest-univalue-path/">https://leetcode-cn.com/problems/longest-univalue-path/</a><br>###<br>一条路径中间为包含一个根结点，路径长其实就是该结点左右子树中同元素向下路径的结点数之和<br>设计一个函数dfs(root)，返回root-&gt;val的最长向下路径结点数<br>返回左子树最长路径结点数l<br>返回右子树最长路径结点数r<br>通过判断左右结点是否和root-&gt;val相等计算以root为根结点的最长路径，并更新结果(用类成员保存)<br>计算以root为起点的最长向下路径结点数  </p><h2 id="题目794"><a href="#题目794" class="headerlink" title="题目794"></a>题目794</h2><p>有效的井字游戏<br><a href="https://leetcode-cn.com/problems/valid-tic-tac-toe-state/">https://leetcode-cn.com/problems/valid-tic-tac-toe-state/</a></p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>打乱数组</title>
      <link href="2021/01/13/%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/"/>
      <url>2021/01/13/%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="打乱数组"><a href="#打乱数组" class="headerlink" title="打乱数组"></a><strong>打乱数组</strong></h1><h2 id="题目384打乱数组"><a href="#题目384打乱数组" class="headerlink" title="题目384打乱数组"></a><strong>题目384打乱数组</strong></h2><p><a href="https://leetcode-cn.com/problems/shuffle-an-array/">题目链接</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><em><strong>题目描述</strong></em></h3><p>给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。<br>实现 Solution class: </p><ul><li><code>Solution(int[] nums)</code> 使用整数数组 nums 初始化对象</li><li><code>int[] reset()</code> 重设数组到它的初始状态并返回</li><li><code>int[] shuffle()</code> 返回数组随机打乱后的结果</li></ul><h3 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a><strong>代码模板</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">shuffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a><strong>分析</strong></h3><ul><li>设$P_{i,k}$表示第i个数被分到第k个位置的概率，其中$1&lt;=i,k&lt;=n$，$n$为数组规模</li><li>假设前面n个数已经按要求排列好了，即$P_{i,k}=\frac{1}{n}$，那么对于第{n+1}个数应该有$P_{n+1,k}=\frac{1}{n+1}$，并且此次迭代将使得前面n个数有$P_{i,k}=\frac{1}{n}$更新为$P_{i,k}=\frac{1}{n+1}$。</li><li>考虑这样操作：<br>以$\frac{1}{n+1}$的概率和$1-n+1$这$n+1$个数交换（可以和自己交换），那么第$n+1$个数满足条件，而对于前n个数中任意一个数$j$，它被交换到$n+1$位置的概率为$\frac{1}{n+1}$，它在前$n$个位置中第$k$个位置的概率$P_{i,k}^{new}=P(第i个数在n+1个数排列之前被放置在k位置)\times P(第i个数未与第n+1个数交换)=P_{i,k}^{old}\times\frac{n}{n+1}=\frac{1}{n}\times\frac{n}{n+1}=\frac{1}{n+1}$，所以上述操作满足条件。</li></ul><h4 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a><strong>代码如下</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="built_in">Solution</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums):<span class="built_in">nums</span>(nums)&#123;</span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">shuffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res=nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> index=<span class="built_in">rand</span>()%(i+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">swap</span>(res[index],res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a,<span class="keyword">int</span>&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=a;</span><br><span class="line">        a=b;</span><br><span class="line">        b=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h3><ul><li>时间复杂度O(n)，需要遍历一遍数组。</li><li>空间复杂度O(n)，需要开一个新数组。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>差分数组</title>
      <link href="2021/01/13/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"/>
      <url>2021/01/13/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="题目1674使数组互补的最少操作次数"><a href="#题目1674使数组互补的最少操作次数" class="headerlink" title="题目1674使数组互补的最少操作次数"></a>题目1674使数组互补的最少操作次数</h1><p><a href="https://leetcode-cn.com/problems/minimum-moves-to-make-array-complementary/">链接</a></p><h2 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h2><p>保存一个数组记录目标值为$2-&gt;2limit$的总操作数，然后遍历找到最小值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minMoves</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp;&amp; nums, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sum</span><span class="params">(<span class="number">2</span>*limit+<span class="number">1</span>,<span class="number">0</span>)</span></span>;<span class="comment">//0-limit*2</span></span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> Max,Min;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            j=n-i<span class="number">-1</span>;</span><br><span class="line">            cout &lt;&lt; nums[i] &lt;&lt; nums[j] &lt;&lt; limit &lt;&lt; endl;</span><br><span class="line">            Max=<span class="built_in">max</span>(nums[i]+limit,limit+nums[j]);</span><br><span class="line">            Min=<span class="built_in">min</span>(nums[i]+<span class="number">1</span>,<span class="number">1</span>+nums[j]);</span><br><span class="line">            <span class="comment">// [Min,Max]这个范围是可以只操作一次达到得</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>;k&lt;=limit*<span class="number">2</span>;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(k==nums[i]+nums[j])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(k&lt;=Max&amp;&amp;k&gt;=Min)sum[k]++;</span><br><span class="line">                <span class="keyword">else</span> sum[k]+=<span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>;k&lt;=limit*<span class="number">2</span>;k++)&#123;</span><br><span class="line">            res=<span class="built_in">min</span>(sum[k],res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n*limit)$</p><h2 id="差分数组的利用"><a href="#差分数组的利用" class="headerlink" title="差分数组的利用"></a>差分数组的利用</h2><p>在暴力破解中，针对每组数，我们需要修改整个记录数组sum，修改形式其实是对五个连续区间$[2,Min-1],[Min,Sum-1],[Sum],[Sum+1,Max],[Max+1,2*limit]$进行一些修改，我们发现这些其实是对连续区间进行统一的修改，这是我们可以考虑使用差分数组diff，diff[i]维护sum[i]-sum[i-1]的信息，那么当我们需要对区间$[i,j]$整体加上一个k时，只需要</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">diff[i]+=k;</span><br><span class="line">diff[j+<span class="number">1</span>]=k;</span><br></pre></td></tr></table></figure><p>整个复杂度降低到了一个常数级别。<br>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minMoves</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp;&amp; nums, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">diff</span><span class="params">(<span class="number">2</span>*limit+<span class="number">2</span>,<span class="number">0</span>)</span></span>;<span class="comment">//0-limit*2+1</span></span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> Max,Min,Sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            j=n-i<span class="number">-1</span>;</span><br><span class="line">            Max=<span class="built_in">max</span>(nums[i]+limit,limit+nums[j]);</span><br><span class="line">            Min=<span class="built_in">min</span>(nums[i]+<span class="number">1</span>,<span class="number">1</span>+nums[j]);</span><br><span class="line">            <span class="comment">// [Min,Max]这个范围是可以只操作一次达到得</span></span><br><span class="line">            diff[<span class="number">2</span>]+=<span class="number">2</span>;</span><br><span class="line">            diff[Min]-=<span class="number">2</span>;</span><br><span class="line">            diff[Min]+=<span class="number">1</span>;</span><br><span class="line">            diff[Sum]-=<span class="number">1</span>;</span><br><span class="line">            diff[Sum+<span class="number">1</span>]+=<span class="number">1</span>;</span><br><span class="line">            diff[Max+<span class="number">1</span>]-=<span class="number">1</span>;</span><br><span class="line">            diff[Max+<span class="number">1</span>]+=<span class="number">2</span>;</span><br><span class="line">            diff[<span class="number">2</span>*limit+<span class="number">1</span>]+=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=INT_MAX,temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>;k&lt;=limit*<span class="number">2</span>;k++)&#123;</span><br><span class="line">            temp+=diff[k];</span><br><span class="line">            res=<span class="built_in">min</span>(temp,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为$O(max(limit,n))$。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最小不兼容性</title>
      <link href="2021/01/13/%E6%9C%80%E5%B0%8F%E4%B8%8D%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
      <url>2021/01/13/%E6%9C%80%E5%B0%8F%E4%B8%8D%E5%85%BC%E5%AE%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="题目1681-最小不兼容性"><a href="#题目1681-最小不兼容性" class="headerlink" title="题目1681 最小不兼容性"></a>题目1681 最小不兼容性</h1><p>[链接]<a href="https://leetcode-cn.com/problems/minimum-incompatibility/">https://leetcode-cn.com/problems/minimum-incompatibility/</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数数组 nums和一个整数 k 。你需要将这个数组划分到 k 个相同大小的子集中，使得同一个子集里面没有两个相同的元素。<br>一个子集的 不兼容性 是该子集里面最大值和最小值的差。<br>请你返回将数组分成 k 个子集后，各子集 不兼容性 的 和 的 最小值 ，如果无法分成分成 k 个子集，返回-1。<br>子集的定义是数组中一些数字的集合，对数字顺序没有要求。  </p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,1,4], k &#x3D; 2</span><br><span class="line">输出：4</span><br><span class="line">解释：最优的分配是 [1,2] 和 [1,4] 。</span><br><span class="line">不兼容性和为 (2-1) + (4-1) &#x3D; 4 。</span><br><span class="line">注意到 [1,1] 和 [2,4] 可以得到更小的和，但是第一个集合有 2 个相同的元素，所以不可行。</span><br></pre></td></tr></table></figure><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [6,3,8,1,3,1,2,2], k &#x3D; 4</span><br><span class="line">输出：6</span><br><span class="line">解释：最优的子集分配为 [1,2]，[2,3]，[6,8] 和 [1,3] 。</span><br><span class="line">不兼容性和为 (2-1) + (3-2) + (8-6) + (3-1) &#x3D; 6 。</span><br></pre></td></tr></table></figure><h3 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [5,3,3,6,3,3], k &#x3D; 3</span><br><span class="line">输出：-1</span><br><span class="line">解释：没办法将这些数字分配到 3 个子集且满足每个子集里没有相同数字。</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先我们看到这道题一开始想到的是贪心，每次把接近的值放在同一个容器中，但是这样子难以同时保证最小化不兼容性并且同一个数在不同容器中。然后我们想是否能使用动态规划来解决问题呢？<br>如果我们试图使用动态规划来求解该问题，我们需要先找到最优子结构和递推公式。<br>我们这样分析最优解的结构，最优解是讲$n$个数分配到k个容器中然后使得k个容器的不兼容性之和最小，那么是否可以这样子，$n$个数分配到$k$个容器的最优解是$n-\frac{n}{k}$个数分配到$k-1$个容器的最优解和剩下$frac{n}{k}$个数分配到一个容器的不兼容性之和的所有可行组合中的最小值。这么说可能比较抽象，更加形式化一点：<br>我们定义原数组为$nums$，定义用int类型值$bit$作为位向量（数组规模最大为16，故int够用），位向量用来表征原数组的一个子集（$bit&amp;(1&lt;&lt;n)$表示$nums[i]$在集合中）。那么我们定义函数$dp(bit,k)$表示位向量为bit的集合分配到k个容器中的最小不兼容性。<br>那么我们这样定义地推式：$dp(bit,k)=min_{sub合法}{dp(bit&amp;sub,k-1),dp(sub,1)}$。<br>sub是含有$n/k$个数字1的位向量，并且满足sub的每个1位bit也同样为1（这样保证是sub是bit的子集）。$bit&amp;sub$相当于bit对sub做了差集，表示剩余数。<br>为了提高效率，我们先预处理所有的k为1的情况。<br>我们现在分别需要设计如下的代码块：</p><ol><li>计算位为1的数量  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num)&#123;</span><br><span class="line">        num&amp;=num<span class="number">-1</span>;<span class="comment">//每次可以把num最低位置0</span></span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>预处理所有规模为n/k的子集的不兼容性  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// value[i]表示集合位向量为i情况下的不兼容性</span></span><br><span class="line"><span class="comment">// 如果count(i)不等于n/k，value[i]=-1;</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">value</span><span class="params">(<span class="number">1</span>&lt;&lt;n,<span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,Max=<span class="number">1</span>&lt;&lt;n;i&lt;Max;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">count</span>(i)==size)&#123;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; set;</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                <span class="keyword">if</span>(set.<span class="built_in">find</span>(nums[j])!=set.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    flag=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> set.<span class="built_in">insert</span>(nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">int</span> Max=INT_MIN,Min=INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                    Max=<span class="built_in">max</span>(Max,nums[j]);</span><br><span class="line">                    Min=<span class="built_in">min</span>(Min,nums[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            value[i]=Max-Min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//与处理完毕</span></span><br></pre></td></tr></table></figure></li><li>遍历bit所有符合条件的子集sub<br>我们要直到sub满足两个条件：<br>1： <code>if(sub&amp;(1&lt;&lt;i))</code>，<code>bit&amp;((1&lt;&lt;i))=true</code>。<br>2：<code>count(sub)==n/k</code>或者说<code>value[sub]==-1</code>。<br>那么我们只需要遍历所有满足第一个条件的sub，然后保留其中所有满足第二个条件sub。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> sub=bit;sub;sub=(sub<span class="number">-1</span>)&amp;bit)&#123;</span><br><span class="line">    <span class="keyword">if</span>(value[sub]!=<span class="number">-1</span>&amp;&amp;dp[bit^sub][k<span class="number">-1</span>]!=<span class="number">-1</span>)&#123;</span><br><span class="line">        pass</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明：bit^sub表示bit对sub做差集，dp[bit^sub][k-1]==-1说明该集合无法分配为k-1个合法集合。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>为什么以上方法可以遍历所有符合条件的sub呢？<br><code>sub=(sub-1)</code>表示从大往小搜索，而<code>sub=(sub-1)&amp;bit</code>把所有bit的零位在sub也置零，保证新的sub是bit的子集。<br>例子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bit&#x3D;0b10110</span><br><span class="line">sub&#x3D;0b10110</span><br><span class="line">sub&#x3D;0b10100</span><br><span class="line">sub&#x3D;0b10010</span><br><span class="line">sub&#x3D;0b10000</span><br><span class="line">sub&#x3D;0b00110</span><br><span class="line">sub&#x3D;0b00100</span><br><span class="line">sub&#x3D;0b00010</span><br><span class="line">sub&#x3D;0b00000</span><br><span class="line">sub共8个。</span><br></pre></td></tr></table></figure></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">&quot;Ofast,no-stack-protector&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC target(<span class="meta-string">&quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">&quot;unroll-loops&quot;</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            n&amp;=n<span class="number">-1</span>;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">special_1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="comment">// k==1的特殊情况</span></span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; set;</span><br><span class="line">        <span class="keyword">int</span> Max=INT_MIN,Min=INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.<span class="built_in">find</span>(nums[i])!=set.<span class="built_in">end</span>())<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            set.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            Max=<span class="built_in">max</span>(Max,nums[i]);</span><br><span class="line">            Min=<span class="built_in">min</span>(Min,nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Max-Min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">special_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// k==n的情况，直接返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumIncompatibility</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> size=n/k;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">1</span>)<span class="keyword">return</span> <span class="built_in">special_1</span>(nums);</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">1</span>)<span class="keyword">return</span> <span class="built_in">special_2</span>();</span><br><span class="line">        <span class="comment">// 预处理所有规模为n/k的子集的不兼容性</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">value</span><span class="params">(<span class="number">1</span>&lt;&lt;n,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,Max=<span class="number">1</span>&lt;&lt;n;i&lt;Max;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">count</span>(i)==size)&#123;</span><br><span class="line">                unordered_set&lt;<span class="keyword">int</span>&gt; set;</span><br><span class="line">                <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                        <span class="keyword">if</span>(set.<span class="built_in">find</span>(nums[j])!=set.<span class="built_in">end</span>())&#123;</span><br><span class="line">                            flag=<span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> set.<span class="built_in">insert</span>(nums[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                    <span class="keyword">int</span> Max=INT_MIN,Min=INT_MAX;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                            Max=<span class="built_in">max</span>(Max,nums[j]);</span><br><span class="line">                            Min=<span class="built_in">min</span>(Min,nums[j]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    value[i]=Max-Min;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//与处理完毕</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">1</span>&lt;&lt;n,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 动态规划</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> bit=<span class="number">1</span>;bit&lt;(<span class="number">1</span>&lt;&lt;n);++bit)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">count</span>(bit)%size==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> sub=bit;sub;sub=(sub<span class="number">-1</span>)&amp;bit)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(value[sub]!=<span class="number">-1</span>&amp;&amp;dp[bit^sub]!=<span class="number">-1</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(dp[bit]==<span class="number">-1</span>)&#123;</span><br><span class="line">                            dp[bit]=dp[bit^sub]+value[sub];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            dp[bit]=<span class="built_in">min</span>(dp[bit^sub]+value[sub],dp[bit]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>402移掉k位数</title>
      <link href="2021/01/13/402%E7%A7%BB%E6%8E%89k%E4%BD%8D%E6%95%B0/"/>
      <url>2021/01/13/402%E7%A7%BB%E6%8E%89k%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目402-移掉k位数"><a href="#题目402-移掉k位数" class="headerlink" title="题目402 移掉k位数"></a><strong>题目402 移掉k位数</strong></h1><p><a href="https://leetcode-cn.com/problems/remove-k-digits/">链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><p>给定一个以字符串表示的非负整数num，移除这个数中的 k 位数字，使得剩下的数字最小。<br>注意:  </p><ul><li>num 的长度小于 10002 且 ≥ k。  </li><li>num 不会包含任何前导零。</li></ul><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a><strong>贪心算法</strong></h2><p>对于两个相同长度的序列最左边不同的数字决定了大小。<br>例如 $1axxx$ 和 $1bxxx$，如果$a&gt;b$则$A&gt;B$。<br>基于此，我们可以知道，若要使得剩下的数字最小，要爆炸靠前的数字尽可能小，举例来说：<br>原数字为12323<br>去掉1 2323<br>去掉2 1323<br>去掉3 1223<br>去掉3 1232<br>我们发现去掉3的情况下是最小的，经过归纳分析，我们提出如下策略：<br>给定一个长度为$n$的数字序列$[D_0D_1D_2D_3…D_{n-1}]$，从左往右找到第一个位置$i(i&gt;0)$使得$D_i&lt;D_{i-1}$，并删除$D_{i-1}$；如果不存在，说明整个数字序列单调不降，删除最后一个数字即可。<br>基于此我们可以对整个数字序列执行k次这个操作，最后的实现复杂度最差会达到$O(nk)$<br><strong>优化：</strong><br>考虑如下例子：<br>输入：[1,2,3,4,5,2,6,4]，k=4<br>stack:  </p><ol><li>1   ,k=4  </li><li>1 2  ,k=4  </li><li>1 2 3 ,k=4  </li><li>1 2 3 4 ,k=4  </li><li>1 2 3 4 5 ,k=4  </li><li>1 2 3 4,k=3  </li><li>1 2 3,k=2  </li><li>1 2 ,k=1  </li><li> 1 2 2 ,k=1  </li><li>1 2 2 6 ,k=1   </li><li>1 2 2 ,k=0  </li><li>1 2 2 4, k=0<br>考虑从左向右增量的构造最后的答案。我们可以用一个栈维护当前的答案序列，栈中的元素代表截止到当前位置，删除不超过$k$次个数字后，所能得到的最小整数。根据之前的讨论：在使用$k$个删除次数之前，栈中的序列从栈底到栈顶单调不降。<br>因此，对于每个数字，如果当前该数字小于栈顶元素，我们就不断弹出栈顶元素，直到</li></ol><ul><li>栈为空</li><li>或者新的栈顶元素不大于当前数字</li><li>或者我们已经删除了k位数字<br>上述步骤结束后我们还需要针对一些情况做额外的处理：  </li><li>如果我们删除了$m$个数字且$m&lt;k$，这种情况下我们需要从序列尾部删除额外的$k-m$个数字。</li><li>如果我们最终的数字序列存在前导零，我们要删除前导零。</li><li>如果最终数字序列为空，我们应该返回0。  </li></ul><p>最终，从栈底到栈顶的答案序列即为最小值。<br>考虑到栈的特点是先进后厨，如果通过栈实现，则需要将栈内元素依次弹出然后进行翻转才能得到最小数，为了避免翻转操作，可以使用双端队列替代栈的实现。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
