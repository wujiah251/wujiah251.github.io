title: C++常见关键字
author: Jiahao Wu
tags: []
categories:
  - C++
date: 2021-02-16 20:06:00
---
# static

## 全局静态变量：

内存中的位置：静态存储区，在整个程序运行期间一直存在。  
初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；
作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。

## 局部静态变量：

在局部变量之前加上关键字static，局部变量就成为一个局部静态变量，它的生命周期变成了整个源文件。  
内存中的位置：静态存储区。  
初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；  
作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；  


## 类的静态成员

```C++
class A
{
private:
	static int val=0;
　　static int func(int x);
};
```

在cpp中必须对类静态成员变量进行初始化，初始化时使用作用域运算符来标明他所属类，其属于该类的所有成员共有，只有一个拷贝。  

类静态成员函数实现的时候不需要static的修饰，因为static是声明性关键字；类的静态函数是该类的范畴内的全局函数，不能访问类的私有成员，只能访问类的静态成员，不需要类的实例即可调用；实际上，他就是增加了类的访问权限的全局函数。类的静态成员函数可以继承或者覆盖，但是不能是虚函数。  

## 只在cpp内有效的全局变量：

在cpp文件的全局范围内声明：  
```C++
static int val = 0;
```
这个变量的含义是该cpp内有效，但是其他的cpp文件不能访问这个变量；如果有两个cpp文件声明了同名的全局静态变量，那么他们实际上是独立的两个变量；

## 只在cpp内有效的全局函数：

函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；  
warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰。  

# const

const名叫常量限定符，用来限定特定变量，以通知编译器该变量是不可修改的。习惯性的使用const，可以避免在函数中对某些不应修改的变量造成可能的改动。  

## 关于数组

C++中数组的值实际上就是一个地址而且这个值不能修改，比如
```
int a[]={1,2,3};
```
数组变量一旦定义，就不可以在修改其地址，const可以在int之前修饰也可以在之后，都表示限定了数组内的元素值。  

## 关于指针

const关于指针有两种用法，指针常量和常量指针：
```
int a=1;
const int *p1=&a;
int const *p2=&a;
```
第一个const修饰了int，这是一个常量指针，不能修改指针指向的对象；  
第二个cosnt修饰了\*，表示这个是一个指针常量，指针值不能修改。  

## 用于函数

```C++
const Rational operator*(const Rational& lhs, const Rational& rhs)
{
return Rational(lhs.numerator() * rhs.numerator(),
lhs.denominator() * rhs.denominator());
}
//返回值用const修饰可以防止允许这样的操作发生:
Rational a,b;
Radional c;
(a*b) = c;
```
避免返回结果作为左值的情况。

# extern

它的作用是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块活其他模块中使用，记住它是一个声明不是定义!也就是说B模块(编译单元)要是引用模块(编译单元)A中定义的全局变量或函数时，它只要包含A模块的头文件即可,在编译阶段，模块B虽然找不到该函数或变量，但它不会报错，它会在连接时从模块A生成的目标代码中找到此函数。  

# volatile

C/C++中volatile关键字和const对应，用来修饰变量，通常用于建立语言级别的memory barrier。用它申明的类型变量表示可以被某些编译器未知的因素更改，比如操作系统、硬件、其他线程等。遇到这个关键字申明的变量，编译器对访问该变量的时候不再优化，从而可以获得稳定的地址访问。  
我们以下面的代码为例子：  
```C++
volatile int i=10;
int a = i;
...
// 其他代码，并未明确告诉编译器，对 i 进行过操作
int b = i;
```
volatile指出i是随时可能发生变化的，每次使用它的时候必须从i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放再b中。而优化的做法是，由于编译器发现两次从i读数据的代码之间的代码没有对i进行过操作，它会自动把读的数据放在b中，而不是重新从i里面读取。