title: CH8异常控制流
author: Jiahao Wu
categories: 深入理解计算机系统
date: 2021-01-14 15:38:24
tags:
---
# 异常控制流


现代系统通过使控制流发生突变来应对这些情况（如程序向磁盘请求数据、子进程终止同制父进程等），一般而言我们把这些突变称为异常控制流（Exceptional Control Folw，ECF）。


## 异常


异常（Exception）就是控制流中的突变。  
处理器检测到事件发生时，它会通过一张叫做异常表（exception table）
的跳转表，进行一个间接过程调用（异常），到一个专门设计用来处理这类事件得操作系统子程序（异常处理程序，exception handler）。当异常处理程序完成处理后，根据引起异常得事件类型，会发生以下3种情况中得一种：  
1. 处理程序将控制返回给当前指令$I_{curr}$，即当事件发生时正在执行得指令。  
2. 处理程序将控制返回给$I_{next}$，如果没有发生异常将会执行下一条指令。  
3. 处理程序终止被终端的程序。  

### 异常处理

系统中每种可能得异常都分配了唯一的非负整数的异常号（exception number）。其中一些号码是由处理器（CPU）的设计者分配的，其他号码是由操作系统内核的设计者分配的。前者的示例包括零除、缺页、内存访问为例、断点以及算术运算溢出。后者示例包括系统调用和来自外部I/O设备的信号。  
异常->异常表基地址寄存器->异常表->相应的处理程序。

### 异常的类别

分为四类：中断（interrupt）、陷阱（trap）、故障（fault）和终止（abort）。

|类别| 原因 |  异步/同步 |返回行为|
|-----|:-------:|-----|--------------:|
|中断|来自I/O设备的信号|异步|总是返回到下一条指令|
|陷阱|有意的异常|同步|总是返回到下一条指令|
|故障|潜在可恢复的错误|同步|可能返回到当前指令|
|终止|不可恢复的错误|同步|不会返回|

1. 中断  
中断是异步发生的，来自处理器外部的I/O设备信号的结果。硬件中断不是由任何一条专门的指令造成的，从这个意义上说它是异步的。  
2. 陷阱和系统调用  
陷阱是有意的异常，陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用。为了允许用户程序对内核服务受控的访问，处理器提供了一条特殊的“syscall n”指令，当用户程序想要请求服务n时，可以执行这条指令，执行syscall指令会导致一个到异常处理程序的陷阱，这个处理程序解析参数，并调用适当的内核程序。  
3. 故障  
故障时由错误情况引起的，它可能够被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。  
一个经典故障时缺页异常，当指令引用一个虚拟地址，而与地址相对应的物理页面不在内存中，因此必须从磁盘中取出来。  
4. 终止  
终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如DRAM或者SRAM位被损坏时发生了奇偶错误。终止处理程序从不将控制返回给应用程序。

### Linux/x86-64系统中的异常

在X86-64系统中，系统调用是通过一条称为syscall的陷阱指令来提供的。C程序用syscall函数可以直接调用任何系统调用，标准C库提供了一组方便的包装函数。这些包装函数将参数打包到一起，以适当的系统调用指令陷入内核，然后将系统调用的返回状态传递回调用程序。系统调用和它们相关的包装函数都成为系统级函数。

## 进程

经典定义：一个执行中程序的实例。系统中每个进程都运行在某个进程的上下文（context）中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。

### 逻辑控制流

程序在执行过程中的一系列的程序计数器（PC）的值。

### 并发流

一个逻辑流在执行的时间上和另一个流重叠，称为并发流，这两个流称为并发地运行。   
多任务：一个进程和其他进程轮流运行的概念称为多任务。  
两个流并发地运行在不同处理器核或者计算机上，那么我们称它们为并行流，它们并行地运行并且并行地执行。

### 私有地址空间

进程为每个程序提供它自己的私有地址空间，一般来说是不能被其他进程读或写的。

### 用户模式核内核模式

处理器通常是用某个控制寄存器中的一个模式位（mode bit）来限制应用可以执行的指令以及它可以访问的地址空间范围。
没有设置模式位时，进程就允许用户模式。  
进程进入内核模式的唯一方法就算通过中断、故障或者陷入系统调用这样的异常。

### 上下文切换

内核使用一种称为上下文切换的较高层次的异常控制流来实现多任务。  
内核为每个进程维持一个上下文，这就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈核各种内核数据结构。

## 系统调用错误处理

当Unix系统级函数遇到错误时，它们通常回返回-1，并设置全局整数变量errno来表示什么出错了。程序员应该总是检查错误，但不信的时，许多人都忽略了错误检查，因为它时代码变得臃肿，而且难以读懂。

## 进程控制

Unix提供了大量从C程序中操作进程的系统调用。

### 获取进程ID

每个进程都有一个唯一正数进程ID（PID）。```getpid```函数返回调用进程的PID。```getppid```返回它的父进程的PID（创建调用进程的进程）。
返回类型为pid_t，在Linux系统上它在type.h里被定义为int。

### 创建和终止进程

进程总是处于下面三种状态之一：
- 运行：进程要么在CPU上执行，要么在等待被执行且最终会被内核调度。
- 停止：进程的执行被挂起（suspended），且不会被调度。
- 终止：进程永远的停止了。三个原因：收到一个信号，该信号的默认行为是终止进程；从主程序返回，调用exit函数。  
父进程通过```fork```函数创建新的子进程。
父进程和子进程有相同但是独立的地址空间，它们共享文件。

### 回收子进程

当一个子进程由于某种原因终止时，内核不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程回收。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程，从此时开始，该进程就不存在了。一个终止了但还未被回收的进程称为僵尸进程。如固父进程终止了，内核会安排init进程成为它的孤儿进程的养父。

### 让进程休眠

sleep函数将一个进程挂起一段指定的时间。如固请求的时间量已经达到了，sleep返回0，否则返回还剩下的要休眠的秒数。

### 加载并运行程序

execve函数加载并运行可执行目标文件filename，只要但出现错误，如找不到filename，execve才会返回到调用程序。execve调用一次并从不返回。  
在execve加载了filename之后，它调用启动代码，启动代码设置栈，并将控制传递给新程序的主函数，该主函数有如下形式的原型
```C++
int main(int argc,char **argv,char **envp);
```
或等价的
```C++
int main(int argc,char *argv[],char *envp[]);
```
argc是命令参数的个数，argv是命令参数数组，``argv[0]->argv[argc-1]``，``argv[argc]=NULL``，envp变量指向一个以null结尾的指针数组，其中每个指针指向一个环境变量字符串，每个串都是形如``name=value``的名字-值对。  
Linux提供了几个函数来操作环境数组：
```C++
#include<stdlib.h>
char *getenv(const char *name);
```
getenv函数在环境数组中搜索字符串```"name=value"```。如果找到了就返回一个指向value的指针，否则就返回``NULL``。
还有：
```C++
#include<stdlib.h>
char *setenv(const char *name,const char *newvalue,int overwrite);
void unsetenv(const char *name);
```
如果环境数组中包含一个形如``"name=oldvalue"``的字符串，那么unsetenv就会删除它，而setenv就会用newvalue代替oldvalue，但是只有在overwrite非零时才会这样。如果name不存在，那么setenv就把``"name=newvalue"``添加到数组中。
- 程序和进程  
fork函数在新的子进程中运行相同的程序，而execve函数在当前进程的上下文加载并运行一个新的程序。它会覆盖当前进程的地址空间，但并没有创建一个新进程，新的程序仍然具有相同的PID，并且继承了execve函数时已打开的所有文件描述符。

### 利用fork和execve运行程序

跳过

## 信号

Linux信号：一种更高层的软件形式的异常，它允许进程和内核中断其他进程。  
低层的硬件异常是由内核处理程序处理的，正常情况这些对用户程序来说都是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。

## 信号术语

传送一个目的信号到进程由两个不同步骤组成：  
- 发送信号：内核通过更新目的进程的上下文中的某个状态，发送（递送）一个信号给目的进程。发生信号可能有两个原因：内核检测到一个系统事件；一个进程调用了kill函数，显示地要求内核发送信号给目的进程。  
- 接收信号：目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收到了信号。进程可以忽略这个信号，终止或通过执行一个称为信号处理程序的应用层函数来捕获这个信号。  
一个发错而没有被接收的信号叫做待处理信号，在任何时刻，一种类型至多只有一个待处理信号（如果有一个该类信号，其他会被丢弃）。

### 发送信号

1. 进程组  
每个进程都只属于一个进程组，由正整数进程组ID来唯一标识。``pid_t getpgrp(void)``返回当前进程的进程组ID。  
子进程和父进程默认情况下属于同一个进程组，一个进程可以通过使用``setpgid``函数来改变自己或者其他进程的进程组：  
2. 用/bin/kill程序发送信号    
3. 从键盘发送信号  
Unix shell使用作业（job）这个抽象概念来表示对一条命令行求值而创建的进程。在任何时刻至多只有一个前台作业和0个或多个后台作业。在键盘上输入Ctrl+C会导致内核发送一个SIGINT信号到前台进程组中的每一个进程。  
默认情况下是终止前台作业；Ctrl+Z默认情况下挂起前台作业。  
4. 用kill函数发送信号    
进程调用kill函数发送信号给其他进程（包括它们自己）。  
5. 用alarm函数发送信号  
进程调用alarm函数发送SIGALRM信号给它自己。  

### 接收信号

### 阻塞和解除阻塞信号

隐式阻塞机制（内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号）、显式阻塞机制

### 编写信号处理程序

跳过

### 同步流以避免讨厌的并发错误

### 显式等待信号

有时候主程序必须要显示地等待某个信号处理程序运行。

## 非本地跳转

非本地跳转（nonlocal jump），一种C语言提供的用户及异常控制流形式。它将控制直接由一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用-返回序列。nonlocal jump通过``setjump``和``longjump``来提供。