title: HTTP与HTTPS
author: Jiahao Wu
tags: []
categories:
  - 计算机网络
date: 2021-02-09 19:39:00
---
# TCP/IP协议族

为了传输方便，在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分割，并在各个报文上打上标记序号及端口号转发给网络层。  
在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。这样一来，发往玩过的通信请求就准备齐全了。  
接收端的服务器在链路层接收到数据，按序往上层发送，一直刀应用层。  
发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层之间传输数据时，没经过一层时都会把对应的首部消去。  

## 负责传输的IP协议

IP协议的作用是把各种数据包传送给对方。保证确实传送刀对方那里，则需要满足各类条件。其中两个重要的条件是IP地址和MAC地址。

### MAC地址

IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本不会更改。  

### ARP协议

IP间的通信依赖MAC地址。在网络上，通信的双方在同一局域网（LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的MAC地址来搜索下一个中转目标。这时，会采用ARP协议。ARP协议是一种用以解析地址的协议，根据通信双方的IP地址就可以反查出对应的MAC地址。  

### TCP协议

按层次分，TCP位于传输层，提供可靠的字节流服务。所谓字节流服务是指，为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理。而可靠数据服务是指，能够把数据准确可靠地传输给对方。一言以蔽之，TCP协议为了更容易传送大数据才把数据分割，而且TCP协议能够确认数据最终是否送达对方。  

### 负责域名解析的DNS服务

DNS服务是和HTTP协议一样位于应用层的协议。它提供域名到IP地址的解析服务。  

### 各种协议与HTTP协议的关系

如果我们想浏览http://xxx.com/ Web页面，过程如下：  
想DNS服务器请求xxx.com的IP地址，DNS服务器返回xxx.com对应的IP地址20X.189.105.112；  
HTTP协议：生成针对目标Web服务器的HTTP请求报文；  
TCP协议：将报文分割成报文段，把每个报文可靠地传输给对方。  
IP协议：搜索地方的地址，一边中转一边传送；  
TCP协议：从对方那里接收到报文段，按序号重组请求报文；  
HTTP协议：对Web服务器请求的内容处理；  
请求的结果按照TCP/IP通信协议向用户进行回传。  

# 统一资源标识符

URI是Uniform Resource Identifier的缩写。URI用字符串标识某一互联网资源，而URL标识资源的地址。URL是URI的子集。  

## URI格式

例子：``http://user:pass@www.example.jp:80/dir/index.htm?uid=1#ch1``
``http://``：协议方案名；  
``user:pass``：登录信息（认证）；  
``www.example.jp``：服务器地址；  
``80``：服务器端口号；  
``dir/index.htm``：带层次的文件路径；  
``uid=1``：查询字符串，可用于传入参数；  
``ch1``：片段标识符。  

# HTTP报文

## 请求报文格式

```
// 请求行：请求方法+URI+协议版本
POST /form/entry HTTP/1.1
// 首部行
Host: hackr.jp
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 16

// 内容实体
name=ueno&age=37
```

## 响应报文格式

```HTTP
// 状态行：协议版本+状态码+状态码原因短语
HTTP/1.1 200 OK
// 首部行
Date: Tue, 10 Jul 2012 06:50:15 GMT
Content-Length: 362
Content-Type: text/html

// 内容实体
<html>
...
```


## 请求方法

**GET**：获取资源；  
**POST**：传输实体的主体；  
**PUT**：传输文件；  
**HEAD**：获得报文首部，用于确认URI的有效性和资源更新的日期时间等；  
**DELETE**：删除文件，是与PUT相反的方法。DELETE方法按请求URI删除指定的资源；  
**OPTIONS**：询问支持的方法，用来查询针对请求URI指定的资源支持的方法。  
**TRACE**：追踪路径；  
**CONNECT**：要求用隧道协议连接代理，实现用隧道协议进行TCP通信，主要使用SSL（Secure Sockets Layer）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。  

## Cookie技术  

由于HTTP协议是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。  
Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。  
Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。  
当客户端再次往该服务器发送该请求时，客户端会自动在请求报文中加如Cookie值后发送出去。  
服务器端发现客户端发送过来的Cookie后，回去检查究竟是从哪个客户端发送来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。  

## 状态码

<table>
  <tr>
    <th></th>
    <th>类别</th>
    <th>原因短语</th>
  </tr>
  <tr>
    <td>1XX</td>
    <td>Informational（信息性状态码）</td>
    <td>接收的请求正在处理</td>
  </tr>
  <tr>
    <td>2XX</td>
    <td>Sucess（成功状态码）</td>
    <td>请求正常处理完毕</td>
  </tr>
  <tr>
    <td>3XX</td>
    <td>Redirection（重定向状态码）</td>
    <td>需要附加操作以完成请求</td>
  </tr>
  <tr>
    <td>4XX</td>
    <td>Client Error（客户端错误状态码）</td>
    <td>服务器无法处理请求</td>
  </tr>
  <tr>
    <td>5XX</td>
    <td>Server Error</td>
    <td>服务器处理请求出错</td>
  </tr>
</table>

### 2XX成功

#### 200 OK

表示从客户端发来的请求在服务器端被正常处理了。

#### 204 No Content

该状态码表示服务器接收的请求已经处理，但是返回的响应报文不包含实体的主体部分。  

#### 206 Partial Content

表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定的范围的实体内容。  

### 3XX重定向

#### 301 Moved Permanently

永久性重定向。该状态码表示请求的资源已经分配了新的URI。

#### 302 Found

临时重定向。状态码表示请求的资源已经被分配了新的URI，希望用于（本次）使用新的URI访问。  


#### 303 See Other


该状态码表示由于请求对应的资源存在另一个URI，应该使用GET方法定向获取请求的资源。  

#### 304 Not Modified

该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304状态码返回时，不包含任何响应的主体部分。304虽然被划分在3XX类别中，但是和重定向没有关系。  

#### 307 Temporary Redirect

临时重定向，和302 Found有着相同的含义。  

### 4XX客户端错误

#### 400 Bad Request

该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。  

#### 401 Unauthorized

该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。另外若之前已进行过1次请求，则表示用户认证失败。返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询（challenge）用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。  

#### 403 Forbbiden

该状态码表明对请求资源的访问被服务器拒绝了。  

#### 404 Not Found

该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。这个状态码非常常见。

### 5XX 服务器错误

#### 500 Internet Server Error

该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的 bug 或某些临时的故障。  

#### 503 Service Unavailable

该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

# HTTPS

## HTTP缺点

- 通信使用明文，内容可能会被窃听；  
- 不验证通信方的身份，因此有可能遭遇伪装；  
- 无法证明报文的完整性，所以有可能已遭篡改。  

## 加密方式

### 通信的加密

一种加密方式就是将通信加密。HTTP协议中没有加密机制，但可以通过和SSL（Secure Socket Layer，安全套接层）或TLS的组合使用，加密HTTP的通信内容。  

用SSL建立安全通信线路之后，就可以在这条线路上进行HTTP通信了。与SSL组合使用的HTTP被称为HTTPS（HTTP Secure，超文本传输安全协议）。  

### 内容的加密

还有一种将参与通信的内容本身加密的方式。由于HTTP协议中没有加密机制，那么就对HTTP报文进行加密处理后再发送请求。  

## HTTPS是身披SSL外壳的HTTP


SSL是独立于HTTP的协议，所以不光是HTTP协议，其他运行在应用层的SMTP和Tenet等协议均可配合SSL协议使用。可以说SSL是当今世界上应用最为广泛的网络安全技术。

## 相互交换密钥的公开密钥加密技术

SSL采用一个种叫做公开密钥加密的加密处理方式。


- 共享密钥加密：  
加密和解密使用同一个密钥的方式称为共享密钥加密，也被称为对称密钥加密。  
但是问题是如何安全地将密钥发给对方？如果中间被攻击者获得，这种加密方式也会失去意义。  
- 使用两把密钥的公开密钥加密：  
公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，一把叫做公开密钥。  
使用公开密钥加密的方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。  
- HTTPS采用混合加密机制：  
由于非对称的加密方式较慢，所以可以混合使用上述两种加密方式，先利用非对称加密方式将共享密钥发送给对方，然后之后利用共享密钥加密报文。

## HTTPS握手过程

握手主要分为三步：  
1. 客户端发起连接，创建一个条TCP连接（三次握手）；  
2. 验证服务端Server是真实的Server；  
3. 发送给Server一个主密钥，然后双方持有该主密钥生成SSL会话所需要的所有对称密钥。  
假设服务端为Alice，客户端为Bob，那么一旦建立TCP连接，Bob就向Alice发送一个hello报文，Alice则用她的证书进行响应，证书中包含她的公钥。因为该证书已被CA证实过，Bob准确无误地知道该公钥属于Alice。然后Bob产生一个主密钥用Alice的公钥加密该主密钥然后发送给Alice，Alice用她的私钥解密出该公钥，之后双方用此密钥进行加密通信。


# HTTP协议和HTTPS协议区别如下

1. HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是经过TLS加密后的，HTTPS具有更高的安全性；  
2. HTTPS在TCP三次握手阶段之后，还需要进行SSL 的handshake，协商加密使用的对称加密密钥；  
3. HTTPS协议需要服务端申请证书，浏览器端安装对应的根证书；  
4. HTTP协议端口是80，HTTPS协议端口是443。