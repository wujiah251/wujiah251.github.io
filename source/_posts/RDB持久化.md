title: RDB持久化
author: 乡村程序员
tags: []
categories: Redis
date: 2021-04-27 22:24:00

---
本文是《Redis设计与实现》中关于RDB持久化的内容的笔记。
 <!-- more -->

# RDB持久化

RDB持久化既可以手动完成也可以根据服务器的配置选项定期完成。

## RDB文件的创建与载入

有两个命令可以用于生成RDB文件，一个是SAVE，另一个是BGSAVE。

SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求：

和SAVE命令直接阻塞服务器进程的做法不同，BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程继续处理命令请求。

和创建不同的是，RDB文件的载入是在服务器启动时自动完成的，没有专门用来载入的命令。

因为AOF的更新频率通常比RDB文件的更新频率高，所以：

- 如果服务器开启了AOF持久化功能，服务器优先使用AOF文件来还原数据库状态。
- 只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。

### SAVE命令执行时的服务器状态

当服务器执行SAVE命令时，Redis服务器会阻塞，客户端发出的所有请求都会被阻塞。

### BGSAVE命令执行时的服务器状态

BGSAVE执行时，Redis服务器仍然可以继续处理客户端请求，但是SAVE、BGSAVE、BGREWRITEAOF三个命令会被拒绝。前两者是为了避免竞争条件，后者是机遇性能的考虑，毕竟这两个子进程都是执行大量的磁盘读写操作。

### RDB文件载入时的服务器状态

服务器在载入RDB期间，会一直处于阻塞状态，直到载入工作完成为止。

## 自动间隔性保存

因为BGSAVE命令可以在不阻塞服务器进程的情况下执行，所以Redis允许用户通过设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令。用户可以通过save选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行BGSAVE命令。

## 设置保存条件

当Redis服务器启动时，用户可以通过指定配置文件或者传入启动参数的方式设置save选项，如果用户没有主动设置save选项，那么服务器会为save选项设置默认条件：

```
save 900 1
save 300 10
save 60 10000
```

接着，服务器会根据save选项所设置的保存条件，设置服务器状态redisServer结构的saveparams属性：

```c
struct redisServer{
	// ...
	struct saveparam *saveparams;
	// ...
}
```

saveparams属性是一个数组，数组中每个元素都是一个saveparam结构，每个saveparam结构都保存了一个save选项设置的保存条件：

```c
struct saveparam{
	// 秒数
	time_t seconds;
	// 修改数
	int changes;
}
```

### dirty计数器和lastsave属性

服务器还维持着一个dirty计数器，以及一个lastsave属性：

- dirty计数器记录距离上一次成功执行SAVE命令或者BGSAVE命令之后，服务器对数据库状态进行了多少次修改。
- lastsave属性是一个UNIX时间戳，记录了服务器上一次成功执行SAVE命令或者BGSAVE命令的时间。

```c
struct redisServer{
	// ...
	long long dirty;
	time_t lastsave;
	// ...
}
```

### 检查保存条件是否满足

Redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的保存条件是否已经满足，如果满足的话，就执行BGSAVE命令。

程序会遍历saveparams数组中的所有保存条件，只要有任意一个条件被满足，那么服务器就会执行BGSAVE命令。

### RDB文件结构

下图展示了一个完整的RDB文件所包含的各个部分：

![image-20210427231327280](../images/RDB%E6%8C%81%E4%B9%85%E5%8C%96/image-20210427231327280.png)

REDIS部分的长度为5字节，保存着“REDIS”五个字符。通过这五个字符，程序可以在读入的时候判断所载入的文件是否是RDB文件。

db_version长度为4字节，它的值是一个字符串表示的整数，这个整数记录了RDB文件的版本号。

databases部分包含了零个或任意多个数据库，以及各个数据库中的键值对数据：

- 如果服务器的数据库状态为空，那么这个部分也为空，长度为0字节。
- 如果服务器的数据库状态为非空，那么这个部分也为非空，根据数据库所保存键值对的数量、类型和内容不同，这个部分的长度也会有所不同。

EOF常量的长度为1字节，这个常量标志着RDB文件正文内容的结束，当读入程序遇到这个值的时候，它知道所有数据库的所有键值对都已经载入完毕了。

check_sum是一个8字节长的无符号整数，保存着一个校验和，这个校验和事程序通过对REDIS、db_version、databases、EOF四个部分的内容进行计算得出的。服务器在载入RDB文件时，会将载入数据所计算出的校验和与check_sum所记录校验和进行对比，以此来检查RDB文件是否有出错或者损坏的情况出现。

### databases部分

如果服务器的0号数据库和3号数据库非空的话，那么服务器将创建一个如图所示的RDB数据库：

![image-20210427231349502](../images/RDB%E6%8C%81%E4%B9%85%E5%8C%96/image-20210427231349502.png)

每个非空数据库在RDB文件中都可以保存为SELECTDB、db_number、key_value_pairs三个部分，如图所示：

![image-20210427231406992](../images/RDB%E6%8C%81%E4%B9%85%E5%8C%96/image-20210427231406992.png)

SELECTDB常量的长度为1字节，当读入程序遇到这个值的时候，它知道接下来要读入的将是一个数据库号码。

db_number保存着一个数据库号码，根据号码的大小不同，这个部分的长度可以是1字节、2字节或者5字节。当程序读入db_number部分之后，服务器会调用select命令，根据读入的数据库号码进行数据库切换，使得之后读入的键值对可以载入到正确的数据库中。

key_value_pairs部分保存了数据库中的所有键值对数据，如果键值对带有过期时间，那么过期时间也会和键值对保存在一起。根据键值对的数量、类型、内容以及是否有过期时间等条件的不同，key_value_pairs部分的长度也会有所不同。

### key_value_pairs部分

不带过期时间的键值对在RDB文件中由TYPE、key、value三部分组成，如图所示：

![image-20210427231426094](../images/RDB%E6%8C%81%E4%B9%85%E5%8C%96/image-20210427231426094.png)

TYPE 记录了value的类型，长度为1字节，值可以是以下常量的其中一个：

![image-20210427231446483](../images/RDB%E6%8C%81%E4%B9%85%E5%8C%96/image-20210427231446483.png)

当服务器读入RDB文件中的键值对数据时，程序会根据TYPE的值来决定如何读入和解释value的数据。

带有过期时间的键值对在RDB文件中的结构如图所示：

![image-20210427231509645](../images/RDB%E6%8C%81%E4%B9%85%E5%8C%96/image-20210427231509645.png)

### value的编码

RDB文件中每个value部分都保存了一个值对象，每个值对象的类型都由与之对应的TYPE记录，根据类型的不同，value部分的结构、长度也会有所不同。

## 分析RDB文件

可以这样分析RDB文件：

```shell
$ od -c dump.rdb //使用ASCII编码打印RDB文件
$ od -cx dump.rdb //同时以ASCII编码和16进制格式打印RDB文件 
```

## 重点回顾

- RDB文件用于保存和还原Redis服务器所有数据结构中的所有键值对数据。
- SAVE命令由服务器进程直接执行保存操作，所以该命令会阻塞服务器。
- BGSAVE命令由子进程执行保存操作，所以该命令不会阻塞服务器。
- 服务器状态中会保存所有用save选项设置的保存条件，当任意一个保存条件被满足时，服务器会自动执行BGSAVE命令。
- 对于不同类型的键值对，RDB文件会使用不同方式来保存它们。