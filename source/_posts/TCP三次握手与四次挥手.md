title: TCP三次握手与四次挥手
author: Jiahao Wu
categories:
  - 计算机网络
tags:
  - 协议
date: 2021-02-18 11:54:00
---
# TCP头部分析

TCP头部中有几个字段需要重点介绍下：
1. 序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记；  
2. 确认序号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1；  
3. 标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：
 - URG：紧急指针（urgent pointer）有效；  
 - ACK：确认序号有效；  
 - PSH：接收方应该尽快将这个报文交给应用层；  
 - RST：重置连接；  
 - SYN：发起一个新连接；  
 - FIN：释放一个连接。  

需要注意的是：  
（A）不要将确认序号Ack与标志位中的ACK搞混了;  
（B）确认方Ack=发起方Req+1，两端配对。


# TCP握手协议

TCP协议通过三次握手来创建一个连接：  
1. 客户端发送一个SYN包（syn=1，seq=i）到服务器，并进入syn_send状态等待；  
这个SYN包不包含应用层数据，首部的标志位SYN被置为1，所以称为SYN包，客户随机选择一个序号seq=client_i；  
2. 服务器在收到SYN包后，会为该连接分配TCP缓存和变量，并发送允许连接的报文段。这个允许连接的报文段也不包含应用层数据，包含以下信息：``SYN=1``，``seq=server_i``，``ack=client_i+1``。``server_i``是服务器随机选取的报文段序号，``ack=client_i+1``表示确认``client_i+1``以前的报文段都已经收到，这个报文段我们称为SYNACK报文段；  
3. 客户端收到SYNACK报文段后，客户也要给该连接分配缓存和变量。客户的主机则向服务器发送另一个报文段；这最后一个报文段对服务器的允许连接的报文段进行了确认（``SYN=0``、``seq=client_i+1``、``ack=server_i+1``），``SYN``被置为0是因为连接已经建立了。第三个阶段的报文段已经可以携带客户到服务器的数据了。

# TCP挥手协议

TCP通过四次挥手来释放一个连接：  
1. 客户端向服务器发送一个特殊的TCP报文段，其中FIN置为0；  
2. 服务器收到上述报文段后，回发一个确认报文段ACK；  
3. 然后服务器发送它自己的终止报文段，其FIN比特被置为1，这个时候在TCP眼中连接已经关闭了；  
4. 最后，该客户对这个服务器的终止报文段进行确认（ACK），发送之后定时等待关闭连接。  


# 为什么要三次握手四次挥手

用一个易于理解的视角来看为什么要3次握手：  
客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。  
第一次握手，客户端发送网络包，服务端收到了，服务端得到结论：客户端发送能力正常，服务端接受能力正常；  
第二次握手，服务端发送网络包，客户端收到，客户端得到结论：服务端接收、发送能力正常，客户端发送、接受能力正常；  
第三次握手，客户端发送网络包，服务端收到，服务端得到结论：客户端接受能力正常，服务端发送能力正常。  
经过3次握手，客户端、服务端相互之间确认了对方和自己的接收、发收能力正常。  

用半关闭来解释为什么需要4次挥手：  
**半关闭**：在TCP通信中客户端向服务端发送一条FIN包，当服务端收到FIN信息时就知道接下来客户端就不会再发送数据了，这在TCP协议中被称为半关闭。但是此时，服务端还能向客户端发送网络包，客户端也依然能接收。  
一个FIN包意味着一方关闭连接，但是另一方可能数据还没有传完，需要传完才会关闭连接。所以需要在中间维持半关闭状态，等到需要关闭连接时，再发送一次FIN包。相当于客户端、服务端各自需要关闭属于自己的一半连接，每次都需要FIN-ACK两次挥手，总共就有4次挥手。  






