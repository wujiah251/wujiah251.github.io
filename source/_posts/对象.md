title: 对象
author: 乡村程序员
tags: []
categories:

  - Redis
mathjax: true
date: 2021-04-24 00:41:00
---
# 对象

## 对象的类型与编码

Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象）。  

Redis中的每个对象都由一个redisObject结构表示，该结构中和保存数据有关的三个属性分别是type属性、encoding属性和ptr属性：  

```c
typedef struct redisObject{
  //类型
  unsigned type:4;
  // 编码
  unsigned encoding:4;
  // 指向底层实现数据结构的指针
  void *ptr;
}
```

### 类型

type属性记录了对象的类型，这个属性的值可以是表中列出的常量的其中一个。  

![image-20210424232016862](../images/%E5%AF%B9%E8%B1%A1/image-20210424232016862.png)

对于redis数据库保存的键值对来说，键总是一个字符串对象，而值可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种。  

注意的是：我们对一个数据库键执行TYPE命令时，命令返回的结果为数据库键对应的值对象的类型，而不是键对象的类型。  

### 编码和底层实现

对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。  

encoding属性记录了对象所使用的编码，也即是说这个对象使用了什么数据结构作为对象的底层实现，这个属性的值可以是下表列出的常量的其中一个。  

![image-20210424232122061](../images/%E5%AF%B9%E8%B1%A1/image-20210424232122061.png)

每种类型都至少使用了两种不同的编码，可以看下表。  

![image-20210424232135278](../images/%E5%AF%B9%E8%B1%A1/image-20210424232135278.png)

通过encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，极大地提高了Redis的灵活性和效率，因为Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率。  

举个例子，在列表对象包含的元素比较少时，Redis使用压缩列表作为列表对象的底层实现：  

- 因为压缩列表比双端链表更节约内存，并且在元素数量较少的时，在内存中以连续块方式保存的压缩列表比起双端队列更容易被载入到缓存中来。  
- 随着列表对象包含的元素越来越多，使用压缩列表来保存元素的优势逐渐消失时，对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端队列上了。  

其他类型的对象也会通过使用多种不同的编码来进行类似的优化。  

## 字符串对象

字符串对象可以是int、raw或者embstr。

如果一个字符串对象保存的是整数值，并且这个整数可以用long类型来表示，那么字符串对象会将整个整数值保存在字符串对象结构的ptr属性里面。（将void*转换成long），并将字符串对象的编码设置为int。  

如果字符串对象保存的是一个字符串值，并且这个字符串长度大于等于39字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw。

如果字符串对象保存的是要给字符串值，并且这个字符串值得长度小于等于39字节，那么字符串对象将使用embstr编码得方式来保存这个字符串字面值。  

embstr编码是专门用于保存短字符串的一种优化编码方式，这种编码和raw编码一样，都使用redisObject结构和sdshdr结构，而embstr编码则通过调用一次内存分配函数来分配一块连续的空间，空间中一次包含redisObject和sdshdr两个结构。  

embstr编码的字符串对象在执行命令时，产生的效果和raw编码的字符串对象执行命令时产生的效果是相同的，但使用embstr编码字符串对象来保存短字符串值有以下好处：  

- embstr编码将创建字符串对象所需的内存分配次数从raw编码的两次降低为一次。
- 释放embstr编码的字符串对象只需要调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次内存释放函数。
- 因为embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起raw编码的字符串对象能够更好的利用缓存带来的优势。

最后说一下啊，可以用long double类型表示的浮点数在Redis中也是作为字符串值来保存的。如果我们要保存一个浮点数到字符串对象里面，那么程序会先将这个浮点数转换成字符串值，然后再保存转换所得的字符串值。

### 编码的转换

int编码的字符串对象和embstr编码的字符串对象在满足条件的情况下，会被转换为为raw编码的字符串对象。  

比如我们set了一个键number，值为10086。它的编码方式这时是int，但是如果我们``append number "something"`` 会导致number先转换成raw类型，然后再执行append操作。  

下面列举了一些字符串命令：

![image-20210424235844316](../images/%E5%AF%B9%E8%B1%A1/image-20210424235844316.png)

## 列表对象

列表的编码可以为ziplist或者linkedlist。

ziplist编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点保存了一个列表元素。举个例子，如果我们执行一下RPUSH命令，那么服务器将创建一个列表对象作为numbers键的值：

```shell
redis> RPUSH numbers 1 "three" 5
(integer) 3
```

这两种编码的区别，下面两张图可以很清晰的表现出来：

![image-20210425000413538](../images/%E5%AF%B9%E8%B1%A1/image-20210425000413538.png)

![image-20210425000424675](../images/%E5%AF%B9%E8%B1%A1/image-20210425000424675.png)

### 编码转换

当列表对象可以同时满足以下两个条件时，列表对象使用ziplist编码：

- 列表对象保存的所有字符串元素的长度都小于64字节；

- 列表对象保存的元素数量小于512个；不能满足这两个条件的列表对象需要使用linkedlist编码。

注意：这两个条件的上限值都是可以修改的，具体请看配置文件中关于list-max-ziplist-value选项和list-max-ziplist-entries选项的说明。

下面列出了一部分的列表命令：

![image-20210425000839273](../images/%E5%AF%B9%E8%B1%A1/image-20210425000839273.png)

## 哈希对象

