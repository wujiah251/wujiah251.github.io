title: 对象
author: 乡村程序员
tags:
  - Redis
categories:
  - Redis
  - 数据结构与对象
mathjax: true
date: 2021-04-24 00:41:00
---
本文是《Redis设计与实现》中关于对象的内容的笔记。
 <!-- more -->
# 对象

## 对象的类型与编码

Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象）。  

Redis中的每个对象都由一个redisObject结构表示，该结构中和保存数据有关的三个属性分别是type属性、encoding属性和ptr属性：  

```c
typedef struct redisObject{
  //类型
  unsigned type:4;
  // 编码
  unsigned encoding:4;
  // 指向底层实现数据结构的指针
  void *ptr;
}
```

### 类型

type属性记录了对象的类型，这个属性的值可以是表中列出的常量的其中一个。  

![image-20210424232016862](../images/%E5%AF%B9%E8%B1%A1/image-20210424232016862.png)

对于redis数据库保存的键值对来说，键总是一个字符串对象，而值可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种。  

注意的是：我们对一个数据库键执行TYPE命令时，命令返回的结果为数据库键对应的值对象的类型，而不是键对象的类型。  

### 编码和底层实现

对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。  

encoding属性记录了对象所使用的编码，也即是说这个对象使用了什么数据结构作为对象的底层实现，这个属性的值可以是下表列出的常量的其中一个。  

![image-20210424232122061](../images/%E5%AF%B9%E8%B1%A1/image-20210424232122061.png)

每种类型都至少使用了两种不同的编码，可以看下表。  

![image-20210424232135278](../images/%E5%AF%B9%E8%B1%A1/image-20210424232135278.png)

通过encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，极大地提高了Redis的灵活性和效率，因为Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率。  

举个例子，在列表对象包含的元素比较少时，Redis使用压缩列表作为列表对象的底层实现：  

- 因为压缩列表比双端链表更节约内存，并且在元素数量较少的时，在内存中以连续块方式保存的压缩列表比起双端队列更容易被载入到缓存中来。  
- 随着列表对象包含的元素越来越多，使用压缩列表来保存元素的优势逐渐消失时，对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端队列上了。  

其他类型的对象也会通过使用多种不同的编码来进行类似的优化。  

## 字符串对象

字符串对象可以是int、raw或者embstr。

如果一个字符串对象保存的是整数值，并且这个整数可以用long类型来表示，那么字符串对象会将整个整数值保存在字符串对象结构的ptr属性里面。（将void*转换成long），并将字符串对象的编码设置为int。  

如果字符串对象保存的是一个字符串值，并且这个字符串长度大于等于39字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw。

如果字符串对象保存的是要给字符串值，并且这个字符串值得长度小于等于39字节，那么字符串对象将使用embstr编码得方式来保存这个字符串字面值。  

embstr编码是专门用于保存短字符串的一种优化编码方式，这种编码和raw编码一样，都使用redisObject结构和sdshdr结构，而embstr编码则通过调用一次内存分配函数来分配一块连续的空间，空间中一次包含redisObject和sdshdr两个结构。  

embstr编码的字符串对象在执行命令时，产生的效果和raw编码的字符串对象执行命令时产生的效果是相同的，但使用embstr编码字符串对象来保存短字符串值有以下好处：  

- embstr编码将创建字符串对象所需的内存分配次数从raw编码的两次降低为一次。
- 释放embstr编码的字符串对象只需要调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次内存释放函数。
- 因为embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起raw编码的字符串对象能够更好的利用缓存带来的优势。

最后说一下啊，可以用long double类型表示的浮点数在Redis中也是作为字符串值来保存的。如果我们要保存一个浮点数到字符串对象里面，那么程序会先将这个浮点数转换成字符串值，然后再保存转换所得的字符串值。

### 编码的转换

int编码的字符串对象和embstr编码的字符串对象在满足条件的情况下，会被转换为为raw编码的字符串对象。  

比如我们set了一个键number，值为10086。它的编码方式这时是int，但是如果我们``append number "something"`` 会导致number先转换成raw类型，然后再执行append操作。  

下面列举了一些字符串命令：

![image-20210424235844316](../images/%E5%AF%B9%E8%B1%A1/image-20210424235844316.png)

## 列表对象

列表的编码可以为ziplist或者linkedlist。

ziplist编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点保存了一个列表元素。举个例子，如果我们执行一下RPUSH命令，那么服务器将创建一个列表对象作为numbers键的值：

```shell
redis> RPUSH numbers 1 "three" 5
(integer) 3
```

这两种编码的区别，下面两张图可以很清晰的表现出来：

![image-20210425000413538](../images/%E5%AF%B9%E8%B1%A1/image-20210425000413538.png)

![image-20210425000424675](../images/%E5%AF%B9%E8%B1%A1/image-20210425000424675.png)

### 编码转换

当列表对象可以同时满足以下两个条件时，列表对象使用ziplist编码：

- 列表对象保存的所有字符串元素的长度都小于64字节；

- 列表对象保存的元素数量小于512个；不能满足这两个条件的列表对象需要使用linkedlist编码。

注意：这两个条件的上限值都是可以修改的，具体请看配置文件中关于list-max-ziplist-value选项和list-max-ziplist-entries选项的说明。

下面列出了一部分的列表命令：

![image-20210425000839273](../images/%E5%AF%B9%E8%B1%A1/image-20210425000839273.png)

## 哈希对象

哈希对象的编码可以是ziplist或者hashtable。

ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩队列节点推入到压缩列表表尾，然后再将保存了值得压缩列表节点推入到压缩列表表尾。因此：

- 保存了统一键值对得两个节点总是紧挨在一起，保存键得节点在前，保存值的节点在后。

- 先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。

![image-20210425150536031](../images/%E5%AF%B9%E8%B1%A1/image-20210425150536031.png)

另一方面，hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都是用一个字典键值对来保存：

- 字典的每个键都是一个字符串对象，对象中保存了键值对的键；
- 字典中每个值都是一个字符串对象，对象中保存了键值对的值。

![image-20210425150550462](../images/%E5%AF%B9%E8%B1%A1/image-20210425150550462.png)

### 编码转换

当哈希对象可以同时满足以下两个条件是，哈希对象使用ziplist编码：

- 哈希对象保存的所有键和值的字符串长度都小于64字节；
- 哈希对象保存的键值对数量小于512个；不能满足这两个条件的哈希对象需要使用hashtable编码。

### 哈希命令的实现

![image-20210425150641574](../images/%E5%AF%B9%E8%B1%A1/image-20210425150641574.png)

## 集合对象

集合对象的编码可以是intset或者hashtable。

intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面。

### 编码的转换

当集合对象可以同时满足以下两个条件时，对象使用intset编码：

- 集合对象保存的所有元素都是整数值；
- 集合对象保存的元素数量不超过512个。

不能满足这两个条件的集合对象使用hashtable编码。

### 集合命令的实现

![image-20210425165006536](../images/%E5%AF%B9%E8%B1%A1/image-20210425165006536.png)

![image-20210425165021809](../images/%E5%AF%B9%E8%B1%A1/image-20210425165021809.png)

### 有序集合对象

有序集合的编码可以是ziplist或者skiplist。

ziplist编码的有序集合对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存成员（member），而第二个元素则保存分值。

压缩列表内的集合元素按照分值从小到大进行排序。

skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表：

```c
typedef struct zset{
	zskiplist *zsl;
	dict *dict;
}zset;
```

zset结构中的zsl跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素：跳跃表节点的object属性保存了元素的成员，而跳跃表节点的score属性则保存了元素的分值。通过这个跳跃表，程序可以对有序集合进行范围操作，比如ZRANK、ZRANGE等命令就是基于跳跃表API来实现的。

有序集合每个元素的成员是一个字符串对象，而每个元素的分值都是一个double类型浮点数。值得一提，虽然zset结构同时使用跳跃表和字典来保存有序集合，但是这两种数据结构通过指针来共享相同元素的成员和分值。

同时使用字典和跳跃表的优点：

- 跳跃表可以用来高效地执行范围操作。
- 字典可以实现O(1)根据，成员查找分值。

### 编码转换

当有序集合对象可以同时满足以下两个条件时，对象使用ziplist编码：

- 有序集合保存的元素数量小于128个；

- 有序集合保存的所有元素成员长度超过都小于64字节。

## 类型检查与命令多态

Redis中用于操作键的命令基本上可以分为两种类型。其中一种命令可以对任何类型的键执行，比如说DEL命令、EXPIRE命令、RENAME命令、TYPE命令、OBJECT命令等。

而另一种命令只能对特定类型的键执行，比如说：

![image-20210425222741769](../images/%E5%AF%B9%E8%B1%A1/image-20210425222741769.png)

举个例子，我们可以用SET命令创建一个字符串键，然后用GET命令和APPEND命令操作这个键，但如果我们试图对这个字符串键执行只有列表键才能执行的LLEN命令，那么Redis将向我们返回一个类型错误：

```shell
redis> set msg "hello world"
OK
redis> get msg
"hello world"
redis> append msg " again!"
redis> get msg
"hello world again!"
redis> LLEN msg
(error) WRONGTYPE Operation against a key holding the wrong kind of values
```

### 类型检查的实现

从上面发生的类型错误代码示例可以看出，为了确保只有指定类型的键可以执行某些特定的命令，在执行一个类型特定的命令之前，Redis会先检查输入键的类型是否正确，然后再决定是否执行给定的命令。

类型特定命令所进行的检查是通过redisObject结构的type属性来实现的。

### 多态命令的实现

Redis会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。

## 内存回收

因为C语言并不具备自动回收内存功能，所以Redis在自己的对象系统中构建了一个引用计数技术实现内存回收机制，通过这一机制，程序员可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。

## 对象共享

除了用于实现引用计数内存回收机制之外，对象的引用计数属性还带有对象共享的作用。举个例子，假设键A创建了一个包含整数值100的字符串对象作为值对象，如图所示。

如果这时键B也创建一个同样包含整数值100的字符串对象作为值对象，那么服务器有两种做法：

- 为键B新创建一个包含整数值100的字符穿对象；
- 让键A和键B共享同一个字符串对象；

以上两种方法很明显第二种更见节省内存。

![image-20210425231121597](../images/%E5%AF%B9%E8%B1%A1/image-20210425231121597.png)

但是由于考虑需要检查对象是否一致来决定是否共享，所以实际上Redis只对包含整数值的字符串对象进行共享。

## 对象的空转时长

除了前面介绍过的type、encoding、ptr和refcount四个属性之外，redisObject结构包含的最后一个属性为lru属性，该属性记录了对象最后一次被命令程序访问的时间：

```c
typedef struct redisObject{
	// ...
	unsigned lru:22;
	// ...
}
```

`object idletime `可以打印出给定键的空转时长，这一空转时长就是当前时间减去lru计算出来的。

出来可以被 `object idletime `命令打印出来之外，键的空转时长还有另外一项作用：如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，那么服务器占用的内存数超过了maxmemory选项所设置的上限，空转时长较高的那部分键会优先被服务器释放掉，从而回收内存。