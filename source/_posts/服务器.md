title: 服务器
tags:
  - Redis
categories:
  - Redis
  - 单机数据库的实现
author: 乡村程序员
date: 2021-05-01 21:11:00
---

本文是《Redis设计与实现》中关于服务器的内容的笔记。
 <!-- more -->

# 服务器



# 命令的请求过程

### 命令请求发送

### 读取命令请求

客户端和服务器之间的连接套接字变成可读的时候，服务器调用命令请求处理器来执行以下操作：

1. 读取套接字中的协议格式的命令请求，并将其保存到客户端状态的输入缓冲区里面。
2. 对输入缓冲区中的命令请求进行分析，提取出命令请求中的包含的命令参数，以及命令的个数，然后分别将参数和参数个数保存到客户端状态的argv属性和argc属性里面。
3. 调用命令执行器，执行客户端指定的命令。

### 命令执行器（1）：查找命令实现

命令查找器要做的第一件事就是根据客户端状态的argv[0]参数，在命令表中查找参数所指定的命令，并将找到的命令保存到客户端状态的cmd属性里面。

命令表是一个字典，键是命令名字，比如set、get等等；值则是一个个redisCommand结构，每个redisCommand结构记录了一个Redis命令的实现信息。

```c
struct redisCommand {
    // 命令名字
    char *name;
    // 实现函数
    redisCommandProc *proc;
    // 参数个数
    int arity;
    // 字符串表示的 FLAG，这个值记录了命令的属性，比如是写还是读
    char *sflags; 
    // 实际 FLAG，对sflags标识进行分析得出的二进制标识，由程序自动生成
    int flags;    
    // 从命令中判断命令的键参数。在 Redis 集群转向时使用。
    redisGetKeysProc *getkeys_proc;
    /* What keys should be loaded in background when calling this command? */
    // 指定哪些参数是 key
    int firstkey; /* The first argument that's a key (0 = no keys) */
    int lastkey;  /* The last argument that's a key */
    int keystep;  /* The step between first and last key */
    // 统计信息
    // microseconds 记录了命令执行耗费的总毫微秒数
    // calls 是命令被执行的总次数
    long long microseconds, calls;
};
```

### 命令执行器（2）：执行预备操作

在真正执行命令之前，程序还需要进行一些预备操作，从而确保命令可以正确执行：

- 检查客户端状态的cmd指针是否指向NULL；
- 根据客户端cmd属性指向的redisCommand的arity属性，检查命令请求所给定的参数个数是否正确，当参数个数不正确时，不再执行后续步骤，直接向客户端返回一个错误；
- 检查客户端是否通过了身份验证；
- 如果服务器打开了maxmemory功能，那么在执行命令之前，先检查服务器的内存占用情况，并在有需要时进行内存回收，从而使得接下来的命令可以顺利执行。

还有很多预备操作，这里不一一列举。

### 命令执行器（3）调用命令的实现函数

当服务器决定要执行命令的时候，它只需要执行以下语句就可以了：

```c
client->cmd->proc(client)
```

被调用的命令实现函数会执行指定的操作，并产生相应的命令恢复，这些回复会被保存在客户端状态的输出缓冲区里面，之后实现函数还会为客户端的套接字关联命令回复处理器，这个处理器负责将回复返回给客户端。

### 命令执行器（4）：执行后续操作

在执行晚实现函数之后，服务器还会做一些后续操作：

- 如果服务器开启了慢查询日志功能，那么慢查询日志模块，会检查是否需要为刚刚执行完的命令请求添加一条新的慢查询日志。
- 根据刚刚执行命令所耗费的时长，更新被执行命令的redisComand结构的milliseconds属性，并将命令的redisCommand结构的calls计数器的值增一。
- 根据是否开启了AOF持久化，将命令请求写入AOF缓冲区（也可能还包括重写缓冲区）。
- 如果有其他从服务器正在复制当前这个服务器，那么服务器会将刚刚执行的命令传播给所有从服务器。

### 将命令回复发送给客户端

当客户端套接字编程可写状态时，服务器会执行命令回复处理器，将输出缓冲区中的命令回复发送给客户端。

### 客户端接收并打印命令回复

当客户端收到协议格式的命令回复之后，它会将这些回复转换成人类可读的格式，并将打印给用户观看。

## serverCron函数

Redis服务器中的serverCron函数默认每隔100毫秒执行一次，这个函数负责管理服务器的资源，并保持服务器自身的良好运转。

### 更新服务器时间缓存

```c
struct redisServer{
	// ...
	// 保存了秒级精度的系统当前UNIX时间戳
	time_t unixtime
	long long mstime;
	// 保存了毫秒精度的系统当前时间UNIX时间戳
}
```

因为serverCron函数默认会以100毫秒一次的频率更新unixtime属性和mstime属性，所以这两个属性记录的时间的精确度并不高：

- 服务器只会在打印日志、更新服务器的LRU时钟、决定是否执行持久化任务、计算服务器上线时间这类对精确度要求不高的功能上使用unixtime和mstime属性。
- 对于键设置过期时间、添加慢查询日志这种需要高精度的时间功能来说，服务器还是会再次执行系统调用，从而获得最准确的系统当前时间。

### 更新LRU时钟

当服务器要计算一个数据库键的空转时间，程序会用服务器的lrulock（服务器时间缓存的一种）属性记录的时间减去对象的lru属性记录的时间，得出的计算结果就是这个对象的空转时间。

serverCron函数默认以10秒一次的频率更新lrulock属性的值。

### 更新服务器每秒执行命令次数

serverCron函数中的trackOperationsPerSecond函数会以每100毫秒一次的频率执行，这个函数的功能是以抽样计算的方式，估算并将记录服务器在最近一次秒钟处理的命令请求数量，这个值可以通过INFO status命令的instantaneous_ops_per_sec域查看。

### 更新服务器内存峰值记录

服务器状态中的stat_peak_memory属性记录了服务器内存的峰值大小：

```c
struct redisServer{
	// ...
	// 已使用内存峰值
	size_t stat_peak_memory;
	// ...
}
```

serverCron函数每次执行，都会查看服务器当前使用的内存数量，并更新stat_peak_memory。

### 处理SIGTERM信号

在启动服务器时，Redis会为服务器进程的SIGTERM信号关联处理器sigtermHandler函数，这个信号处理器负责在服务器接到SIGTERM信号时，打开服务器状态的shutdown_asap标识。

每次serverCron函数运行时，都会对服务器状态的shutdown_asap属性进行检查，并根据属性的值决定是否关闭服务器。

### 管理客户端资源

serverCron函数每次执行都会调用clientCron函数、clientCron函数会对一定数量的客户端进行以下两个检查：

- 如果客户端与服务器之间的连接已经超时，那么程序释放这个客户端。
- 如果客户端在上一次执行命令请求之后，输入缓冲区的大小超过了一定的长度，那么程序会释放客户端当前的输入缓冲区，并重新创建一个默认大小的输入缓冲区，从而防止客户端的输入缓冲区耗费了过多的内存。

### 管理数据库资源

serverCron函数每次执行都会调用databaseCron函数，这个函数会对服务器中的一部分数据库进行检查，删除其中的过期键，并且有需要时，对字典进行收缩操作。

### 执行被延迟的BGREWRITEAOF

在服务器执行BGSAVE命令的期间，如果客户端向服务器发来的BGREWIRTEAOF命令，那么服务器会将BGREWIRTAOF命令的执行时间延迟到BGSAVE命令执行完毕之后。

### 检查持久化操作的运行状态

服务器状态持久化使用rdb_child_pid属性和aof_child_pid属性记录执行BGSAVE命令和BGREWRITEAOF命令的子进程的ID，这两个属性也可以用于检查BGSAVE命令或者BGREWRITEAOF命令是否正在执行。



## 初始化服务器

### 初始化服务器状态结构

初始化服务器的第一步是创建一个redisServer类型的实例变量，server作为服务器的状态，并为结构中的各个属性设置默认值。

初始化server变量的工作由initServerConfig函数完成。主要工作包括：

- 设置服务器的运行ID。
- 设置服务器的默认允许频率。
- 设置服务器的默认配置文件路径。
- 设置服务器的允许架构。
- 设置服务器的默认端口号。
- 设置服务器的默认RDB持久化条件和AOF持久化条件。
- 初始化服务器的LRU时钟。
- 创建文件表。

### 载入配置选项

```shell
$ redis-server --port 10086
$ redis-server redis.conf
```

我们可以通过指定配置文件的方式修改了服务器的数据库数量，以及RDB持久化模块的压缩功能。

### 初始化服务器的数据结构

在之前执行initServerConfig函数初始化server状态时，程序只创建了命令表一个数据结构，不过除了命令表之外，服务器状态还包含了其他数据结构，比如：

- server.clients链表；
- server.db数据；
- 用于保存订阅信息的server.pubsub_channels字典；

当初初始服务器进行到这一步，服务器将调用initServer函数，为以上的数据结构分配内存，并且这个函数还负责设置信号处理器、创建共享对象等重要工作。

### 还原数据库状态

如果服务器启用了AOF持久化功能，服务器需要载入RDB文件或者AOF文件，并根据文件记录的内容来还原服务器的数据库状态。







































