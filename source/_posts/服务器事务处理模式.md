title: 服务器事务处理模式
author: Jiahao Wu
date: 2021-02-13 22:18:46
tags:
---
服务器通常要处理3种类型的事件：IO事件、信号、定时事件。而有两种高效处理时间的方式，分别是Reactor模式与Proactor模式。  

# Reactor

Reactor模式要求主线程只负责事件监听描述符上是否事件发生，有事件发生后通知工作线程，除此以外，主线程不做任何工作，读写数据、接收新的连接、处理客户请求都在工作线程上完成。  
使用同步IO（``epoll_wait()``为例子）实现的Reactor模式的工作流程如下：  

1. 主线程往epoll内核事件表注册socket上的读就绪时间；  
2. 主线程调用``epoll_wait()``等待socket上有数据可读；  
3. 当socket上数据可读时，``epolll_wait()``通知主线程。主线程将socket可读事件放入请求队列；  
4. 睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写事件。  
5. 主线程调用``epoll_wait()``等待socket可写；  
6. 当socket可写时，epoll_wait()通知主线程。主线程将socket可写事件放入请求队列；  
7. 睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。  

# Proactor

与Reactor模式不通，Proactor模式将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。  

使用异步IO（``aio_read()``和``aio_write()``为例）实现的Proactor模式工作流程如下：  

1. 主线程调用``aio_read()``函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时候如何通知应用程序（信号机制）；  
2. 主线程继续处理其他逻辑；  
3. 应用程序预先定义好信号处理函数并选择一个工作线程来处理客户请求；工作线程处理完客户请求之后，调用``aio_write()``想内核注册socket上的写完成事件，并告诉内核缓冲区的位置，以及写操作完成时应如何通知应用程序（信号）；  
4. 主线程继续处理其他逻辑；  
5. 当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知程序数据以及传送完毕；  
6. 应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如是否决定关闭socket。  

使用同步IO也可以实现的Proactor模式。原理是这样的：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一“完成事件”，那么工作线程直接获得了读写结果，接下来要做的只是对读写结果的处理。工作流程如下：  

1. 主线程调用``epoll_ctl()``向epoll内核事件表中注册描述符；  
2. 主线程调用``epoll_wait()``等待socket上有数据可读；  
3. 当socket上有数据可读时，epoll_wait()通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将多有数据封装成一个请求对象并插入请求队列中；  
4. 睡眠在请求队列中的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket上的写就绪事件；  
5. 主线程调用``epoll_wait()``等待socket可写；  
6. 当sockt可写时，``epoll_wait()``通知主线程。主线程往socket上写入服务器处理客户请求的结果。  

这里同步模拟和异步模拟Proactor的区别在于，同步模拟是主线程自己进行I/O操作，需要等待读完数据，而异步I/O是通过aio_read()异步读取，主线程不需要等待I/O完成。

其实通过上述描述我们还可以发现同步IO和异步IO的一个区别。同步IO注册的是就绪事件（``epoll_wait()``），而异步IO是注册完成事件（``aio_read()``、``aio_write()``）。  


