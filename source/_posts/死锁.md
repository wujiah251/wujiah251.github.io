title: 死锁
author: Jiahao Wu
tags: []
categories:
  - 操作系统
date: 2021-02-04 18:37:00
---
# 资源

## 可抢占资源和不可抢占资源

- 可抢占资源：可以从拥有它的进程中抢占而不会产生任何副作用  
可抢占资源不易产生死锁，因为这种潜在风险可以由进程之间资源的重新分配来化解。  
- 不可抢占资源：无法把它从占有它的进程处抢占过来。  

## 资源获取

一种允许用户管理资源的方式是为每个资源配置一个信号量，我们看下面两个例子：
```C++
typedef int semaphore;
	semaphore resource_1;
	semaphore resource_2;
	
   void process_A(){
		down(&resource_1);
		down(&resource_2);
		use_both_resources();
		up(&resource_2);
		up(&resource_1);
   }
   void process_B(void){
		down(&resource_1);
		down(&resource_2);
		use_both_resources();
		up(&resource_2);
		up(&resource_1);
   }
```
上面这个例子，不会发生死锁，而下面这个例子有可能出现死锁：
```C++
typedef int semaphore;
	semaphore resource_1;
	semaphore resource_2;
	
   void process_A(){
		down(&resource_1);
		down(&resource_2);
		use_both_resources();
		up(&resource_2);
		up(&resource_1);
   }
   void process_B(void){
		down(&resource_2);
		down(&resource_1);
		use_both_resources();
		up(&resource_1);
		up(&resource_2);
   }
```


# 死锁概述

死锁的规范定义：**如果一个进程集合中的每个进程集合都在等待只能由该进程集合中的其他进程才能引发的事件，那么该进程集合就是死锁的**。  

## 资源死锁的条件

1. 互斥条件：每个资源要么已经分配给一个进程，要么可用；  
2. 占有和等待条件：已经得到某个资源的进程可以再请求新的资源；  
3. 不可抢占条件：一个资源已经分配给某个进程，那么只能由这个进程释放这个资源；  
4. 环路等待条件：死锁发生时，系统中一定有两个或两个以上进程组成了一条环路，这个环路上每个进程都在等待下一个进程释放资源。  

所以如果想避免死锁发生，我们可以从破坏这四个条件入手。  

# 死锁检测和死锁恢复

## 每种类型一个资源的死锁检测

用普通的检测有向图是否有环路的算法即可检测死锁。

## 每种类型多个资源的死锁检测

假设两个矩阵C、R，C(i,j)代表当前第i个进程对第j种资源占有个数，R(i,j)代表第i个进程还需要多少个j类资源。然后假设两个向量E、A，E(i)代表资源类型1的个数，A(i)代表资源类型i总共可用个数。那么我们可以用如下算法检测死锁：  
死锁检测算法如下：
1）寻找一个没有标记的进程Pi，对于R矩阵而言第i行向量小于等于A；  
2）如果找到了这样一个进程，那么将C矩阵的第i行向量加到A中，标记该进程，并转到第一步（可以理解为这个进程可以被分配资源然后完成再释放资源）；  
3）如果没有找到这样的进程，算法终止。  
算法结束时，没有被标记的进程都是死锁进程（如果有的话）。

## 从死锁中恢复

1. 利用抢占恢复：这通常需要人工干预。  
2. 利用回滚恢复：周期性对进程进行检查，并将检查点检查也就是进程的状态写入一个文件以备以后重启（类似于日志）。一旦检测到死锁，那么就很容易发现需要哪些资源。为了进行恢复，要从一个较早的检查点开始，这样所有需要资源的进程会回滚到一个时间点，在此时间点之前该进程获得了一些其他的资源。在检查点之后的所有工作都会丢失。  
3. 通过杀死进程恢复：注意不要杀死环外的进程。  

# 死锁避免

## 安全状态和不完全状态

如果没有死锁发生，且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称状态是安全的。  

安全状态下，系统能保证不发生死锁。不安全状态则没有这个保证。  

## 单个资源的银行家算法

算法：判断对请求的满足是否会导致进入不安全状态。如果是，就拒绝请求，如果满足请求后仍是安全的，就予以分配。  

## 多个资源的银行家算法

和单个资源类似，用前面所说的多个资源的死锁检测来判断是否安全。  
但是值得一提的是银行家算法并不实用，一方面很难一开始就知道这个进程所需要的最大资源数目，另一方面系统中进程的数目不是固定的，这可能导致原本可用的资源也变得不可用起来。  

# 死锁预防

## 破坏互斥条件

如果一个资源不会被一个进程独占，那么死锁肯定不会发生。  

## 破坏占有和等待条件

只要在一开始将所有需要的资源都读入即可，但是判断需要多少资源时间麻烦事。  

## 破坏不可抢占条件

但是并不是所有资源的都可以修改为可抢占。  

## 破坏环路等待条件

对资源编号，要求进程按照顺序来请求资源。  

# 其他问题

## 饥饿

饥饿是指系统不能保证某个进程的等待时间上界，从而使该进程长时间等待，当等待时间给进程推进和响应带来明显影响时，称发生了进程饥饿。当饥饿到一定程度的进程所赋予的任务即使完成也不再具有实际意义时称该进程被饿死。











































