title: 进程和线程
author: Jiahao Wu
categories: 操作系统
date: 2021-02-02 19:04:11
tags:
---
# 进程

在多道程序设计系统中，CPU由一个进程快速切换至另一个进程，使每个进程各运行几十或几百毫秒。但是实际上一个CPU同时只能运行一个进程，但1s内它可能运行了多个进程，这样就产生了并行的错觉。为了对多个并行活动进行跟踪，操作系统设计者发展了一个概念模型-进程（运行程序时的抽象），使得并行更容易处理。  

## 进程模型

进程就是一个正在执行程序的实例，包括程序计数器，寄存器和变量的当前值。  

## 创建进程

UNIX系统中，只有一个系统调用可以创建新的进程：``fork``。这个系统调用会创建一个与调用进程相同的副本，这两个进程会拥有相同的存储映像、同样的环境字符串和同样的打开文件。这就是全部情形通常，子进程接着执行``execeve``以修改器存储映像并允许一个新的程序。  

## 进程的终止

1. 正常退出（自愿的）：通知操作系统它的工作已经完成，在UNIX中该调用``exit``；  
2. 出错退出（自愿的）：进程出现错误，捕获错误，然后退出；  
3. 严重错误（非自愿的）：比如引用不存在的内存、除数是0等，这类错误中，进程可以通知操作系统来处理；  
4. 被其他进程杀死（非自愿的）：其他进程通过执行一个系统调用：``kill``来杀死某个进程。  

## 进程的层次结构

当一个进程创建出来了后，父进程和子进程以某种形式继续保持联系。自进程可以接着再创建进程，这就形成了进程的层次结构。  

## 进程的状态

1. 运行态（该时刻进程实际占用CPU）；  
2. 就绪态（可运行，但因为其他进程正在运行而暂时停止）；  
3. 阻塞态（除非某种外部事件发生，否则进程不能运行）。  

运行态可以转变成就绪态和阻塞态，就绪态可以转变成运行态，阻塞态可以转变成就绪态。  

## 进程的实现

为了实现进程模型，操作系统维护一张表格，即进程表。每个进程占用一个进程表项。该表项包含了进程状态的重要信息：程序计数器、堆栈指针、内存分配情况、所打开文件的状态、账号和调度信息，以及其他在进程由运行态转换成就绪态或阻塞态时需要保存的信息。


# 线程

为什么需要多线程：在许多应用中同时发生着多种活动。其中某些活动随着时间的推移会被阻塞。通过将这些应用程序分解成可以准并行运行的多个顺序线程，程序设计模型会变得更简单。  
这其实和前面所说的进程看起来并无区别，但是线程引入了一个新的元素：并行实体共享同一地址空间和所有可用数据的能力；另一方面，线程更加轻量级，创建一个线程需要的时间较创建一个进程快10-100倍。  
需要多线程的第三个原因涉及性能方面的讨论：若多个线程都是CPU密集型的，那么并不能获得性能上的增强，但是如果存在大量的计算和I/O，同游多个线程允许这些活动彼此重叠进行，从而会加快应用程序执行的速度。

## 经典的线程模型

<table>
  <tr>
    <th>每个进程中的内容</th>
    <th>每个线程中的内容</th>
  </tr>
  <tr>
    <td>地址空间</td>
    <td>程序计数器</td>
  </tr>
  <tr>
    <td>全局变量</td>
    <td>寄存器</td>
  </tr>
  <tr>
    <td>打开文件</td>
    <td>堆栈</td>
  </tr>
  <tr>
    <td>子进程</td>
    <td>状态</td>
  </tr>
  <tr>
    <td>即将发生的报警</td>
    <td></td>
  </tr>
  <tr>
    <td>信号与信号处理程序</td>
    <td></td>
  </tr>
  <tr>
    <td>账户信息</td>
    <td></td>
  </tr>
</table>



## 用户级线程和内核级线程


用户级线程是指不需要内核支持，在用户程序中实现的线程。它的内核的切换由用户程序自己控制，不需要内核的干涉。但是不能像内核级线程一样更好的运用多核CPU。  
优点：  
1. 线程调度不需要内核参与，控制起来简单；  
2. 可以在不支持线程的操作系统中实现。  

缺点：  
1. 用户级线程的阻塞回引起整个进程的阻塞；  
2. 用户级线程不能利用系统的多重处理，只有一个用户级线程可以被执行。  

内核级线程：切换由内核控制，由用户态转化为内核态。切换完毕要从内核态返回用户态。可以很好地运用多核CPU。  
优点：  
1. 多核时，一个进程的多个线程可以同时执行；  
2. 由于内核级线程只有很小的数据结构和堆栈，切换速度快。  

缺点：  
线程在用户态的运行，而线程的调度和管理在内核实现，在控制权从一个线程传送到另一个线程需要用户态到内核态再到用户态的模式切换，比较占用系统资源。（就是必须要受到内核的监控）。  

区别：  
1. 内核支持线程是OS内核可感知的，而用户级线程是OS内核不可感知的；  
2. 用户级线程的创建、撤消和调度不需要OS内核的支持，所以性能上差一些；  
3. 用户级线程执行系统调用指令时将导致其所属进程被中断，而内核支持线程执行系统调用指令时，只导致该线程被中断。  


## 混合实现

编程人员可以决定有多少内核级线程和多少用户级线程彼此多路复用，这一模型最灵活。  

# 进程间通信

三个问题：  
1. 一个进程如何把信息传递给另一个进程？  
2. 确保两个或更多进程在关键活动中不会出现交叉；  
3. 进程运行顺序。  

## 竞争条件

两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序，称为竞争条件。  

## 临界区

我们需要互斥，即以某种手短确保当一个进程在使用某个共享变量或文件时，其他进程不能做同样的操作。  
我们把对共享内存进行访问的程序片段称作临界区域或临界区。如果我们能够适当地安排，使得两个进程不可能同时处于临界区中，就能够避免竞争条件。  

## 忙等待的互斥

1. 屏蔽中断：当进程进入临界区后立即屏蔽所有中断，并在就要离开时打开中断。这样子的问题是将屏蔽中断的权力交给用户进程是不明智的，如果没有打开中断，可能导致系统因此终止。  
2. 锁变量；  
3. 严格轮换法；  
4. Peterson解法；  
5. TSL指令  
那些设计为多处理器的计算机，都有下面一条指令：  
``TSL RX, LOCK``  

这个指令可以将一个内存字lock读到寄存器RX中，然后该内存地址上存一个非零值。这个读操作和写操作是不可分割的，即该指令结束之前其他处理器不允许访问该内存字。这通过锁住内存总线来实现，静止其他CPU在本指令结束之前访问内存。  

## 信号量&&互斥量

信号量、互斥量可以参考我在《CSAPP》的读书笔记第12章的内容。  

## 条件变量

条件变量允许线程由于一些未达到的条件而阻塞。直到另外的线程向它发送信号。

## 死锁

举例：  
消费者-生产者问题中，如果缓冲区大小为0，这时候消费者先对互斥量加锁，再对信号量进行P操作，将被阻塞，而由于互斥量加锁，生产者也无法对信号量进行V操作，这种现象叫做死锁。  

## 管程

管程是一种程序结构，由过程、变量及数据结构等组成的一个集合。管程是在编译器层次实现的，在编写程序时可以理解成一个软件包，它提供如下服务：  
- 多个彼此可以交互并共用资源的线程  
- 多个与资源使用有关的变量  
- 一个互斥锁  
- 一个用来避免竞态条件的不变量  

# 调度

当计算机系统是多道程序设计系统时，就会发生多个进程或者多个线程竞争CPU。在操作系统中，完成选择工作得这一部分称为调度程序。  

## 调度介绍
- 进程行为：  
几乎所有进程都是I/O或计算交替突发的，典型地，CPU不停顿地运行一段时间，然后发出一个系统调用以便读写文件。  
进程也可以分为I/O密集型和计算密集型。  

- 何时调度：  

第一，在创建一个新进程时，选择运行父进程还是子进程；  
第二，在进程退出时必须做出调度决策，一个进程不再运行，所以必须从就绪进程中选择另外的某个进程；  
第三，当一个进程阻塞在I/O和信号量上或由于其他原因阻塞时，必须选择另一个进程运行。有时，阻塞原因会成为选择的因素。  

- 调度算法分类和目标：  
不同环境需要不通的调度算法，这里有必要划出的三种环境。  
1）批处理（吞吐量、周转时间、CPU利用率）；  
2）交互式（响应时间、均衡性）；  
3）实时（满足截止时间、可预测性）。  

# 经典的IPC问题

## 哲学家就餐问题

问题：5个哲学家5把叉子，需要两把叉子才能吃饭：  
如果同时拿起右边的叉子，则会发生死锁。  
如何解决：  
用信号量对5个哲学家提供保护，在开始拿叉子之前，先对相邻两个哲学家的互斥量进行访问，如果他们都没有在吃饭，则拿起叉子。  
这种解法可以获得最大的并行度。  

## 读者-写者问题

举例：一个进程正在更新数据库，而这时候，其他读数据库的请求将被阻塞；而一个进程在读数据，其他进程也可以读数据库。这就是典型的读者-写者问题，读者不具有排他性，而写者会排他。  
解决方法：
```C++
typedef int semaphore;
semaphore mutex = 1;
semaphore db = 1;
int rc = 0;

void reader(void)
{
	while(true){
		down(&mutex);
		rc = rc + 1;
		if(rc==1)down(&db);
		up(&mutex);
		read_data_base();
		down(&mutex);
		rc = rc - 1;
		if(rc == 0)up(&db);
		up(&mutex);
		use_data_read();
	}
}

void writer(void)
{
	while(true){
		think_up_data();
		down(&db);
		write(&db);
		write_data_base();
		up(&db);
   }
}
```

# 进程和线程需要维护的状态