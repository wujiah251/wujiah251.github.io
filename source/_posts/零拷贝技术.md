title: 零拷贝技术
author: Jiahao Wu
tags: []
categories:
  - 操作系统
date: 2021-03-18 09:53:00
---
服务端中通常需要传输文件，即将磁盘中的文件不做修改的通过socket发送出去。比如下面的代码：  
```C++
while((n=read(disk_fd,buf,BUG_SIZE))>0)
	write(sock_fd,buf,n);
```

基本操作就是从磁盘循环读取字符到用户缓冲区buf，发送到Socket。但是由于Linux的I/O操作默认是缓冲I/O。这里面主要使用的也就是 Read 和 Write 两个系统调用，我们并不知道操作系统在其中做了什么。实际上在以上 I/O 操作中，发生了多次的数据拷贝。 当应用程序访问某块数据时，操作系统首先会检查，是不是最近访问过此文件，文件内容是否缓存在内核缓冲区。如果是，操作系统则直接根据 Read 系统调用提供的 buf 地址，将内核缓冲区的内容拷贝到 buf 所指定的用户空间缓冲区中去。 如果不是，操作系统则首先将磁盘上的数据拷贝的内核缓冲区，这一步目前主要依靠 DMA 来传输，然后再把内核缓冲区上的内容拷贝到用户缓冲区中。 接下来，Write 系统调用再把用户缓冲区的内容拷贝到网络堆栈相关的内核缓冲区中，最后 Socket 再把内核缓冲区的内容发送到网卡上。  
这种数据拷贝方式总共需要拷贝4次，分别是:  
1. 磁盘拷贝进内核缓冲区（DMA copy）；  
2. 内核缓冲区拷贝进用户缓冲区（read：CPU copy）；  
3. 用户缓冲区拷贝进内核socket缓冲区（write：CPU copy）；  
4. socket内核缓冲区拷贝进网络（DMA copy）。  

拷贝次数不但多，而且CPU负担重，故我们引入零拷贝技术来优化。零拷背用mmap+write的方式替代了read+write的方式。mmap的使用方式大致如下：  
```C++
buf = mmap(diskfd, len);
write(sockfd, buf, len);
```
应用程序调用 mmap()，磁盘上的数据会通过 DMA 被拷贝的内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享，这样就不需要把内核缓冲区的内容往用户空间拷贝。 应用程序再调用 write()，操作系统直接将内核缓冲区的内容拷贝到 Socket 缓冲区中，这一切都发生在内核态，最后，Socket 缓冲区再把数据发到网卡去。  
注：mmap想当于建立文件和虚拟内存的映射关系，使得能够像操作数组一样访问文件，但是调用mmap不会立刻将磁盘文件换入到物理内存而是设置了相应的访问标识，如果访问的话，会触发缺页异常，然后将文件换入到物理内存中。  
零拷贝技术中总共发生了三次拷贝：  
1.磁盘拷贝进内核缓冲区（DMA copy）；  
2.内核缓冲区拷贝进socket缓冲区（CPU copy）；  
3.socket缓冲区拷贝进网络（DMA copy）。  


















